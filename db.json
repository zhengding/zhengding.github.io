{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1510912922000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1510912922000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1510912922000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1510912922000},{"_id":"themes/next/.DS_Store","hash":"7edcfc62759076ddec6c6e3c3ed80108ac5cce0d","modified":1511152599000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1510912922000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1510912922000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1510912922000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1510912922000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1510912922000},{"_id":"themes/next/_config.yml","hash":"ce8b246a7cd4be210b44bd52e03cd2e4037f2e6c","modified":1511162112000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1510912922000},{"_id":"themes/next/README.cn.md","hash":"02713071ef9e260b3fe77f4403942189d55a00e9","modified":1510912922000},{"_id":"themes/next/README.md","hash":"529d53dfa97678f8ce4c95620b26e61154162a29","modified":1510912922000},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1510912922000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1510912922000},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1510912922000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1510912922000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1510912922000},{"_id":"themes/next/.git/index","hash":"76e98d1eb37858e8d5cdc69a53846634617bc179","modified":1513818752000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1510912922000},{"_id":"themes/next/.git/packed-refs","hash":"f1fe33b8cdc221749eb26034a82b483cd86ef1b6","modified":1510912922000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1510912913000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1510912922000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1510912922000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1510912922000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1510912922000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1510912922000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1510912922000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1510912922000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1510912922000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1510912922000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1510912922000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1510912922000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1510912922000},{"_id":"source/.DS_Store","hash":"5a92089a58b463c9cffeb51ec2eb1edf47924ca6","modified":1513763755000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1510912922000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1510912922000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1510912922000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1510912922000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1510912922000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1510912922000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1510912922000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1510912922000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1510912922000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1510912922000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1510912922000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1510912922000},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1510912922000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1510912922000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1510912922000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1510912922000},{"_id":"themes/next/scripts/.DS_Store","hash":"71fa005daae49ff9dfe0ef93889ed26118f25c89","modified":1511152599000},{"_id":"themes/next/source/.DS_Store","hash":"22018f3ebdfdb707b5bc1cce872cdc0315d24302","modified":1511149757000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1510912922000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1510912922000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1510912922000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1510912913000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1510912913000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1510912913000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1510912913000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1510912913000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1510912913000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1510912913000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1510912913000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1510912913000},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1510912913000},{"_id":"themes/next/.git/logs/HEAD","hash":"9d594502bc4cdd735255cec561bc4e6d2a191763","modified":1510912922000},{"_id":"source/about/index.md","hash":"ef65bd43bd489cabc1544872114dee5b710e5e01","modified":1513763703000},{"_id":"source/categories/index.md","hash":"f84d5d2fc3fa9af4f4c18221b19919b5f86d68a8","modified":1513763703000},{"_id":"source/tags/index.md","hash":"7aa25004ab71a8fd8aa9d37eb0ddc4a3492c05e8","modified":1513763703000},{"_id":"source/_posts/Centos7.0 中的中iptables、firewall和SELINUX.md","hash":"ff9b770ad7f54e8789ebb1e3b11e1494217e82a2","modified":1512978076000},{"_id":"source/_posts/Docker常用命令.md","hash":"a8d6cf33486c1d33b3405505706128f27999bd02","modified":1513058840000},{"_id":"source/_posts/Git撤销&回滚操作.md","hash":"f54092d0bc086bcaa44391d5aa7f57c83dcd5aa3","modified":1512614720000},{"_id":"source/_posts/Mac系统安装PHP7教程.md","hash":"708c044811a3768c238ff76c77a70b6fcfd5fb39","modified":1512625273000},{"_id":"source/_posts/React总结.md","hash":"c5d205ff711f9c721b4710c5250c9cb36e690ca2","modified":1512637691000},{"_id":"source/_posts/[转]全文搜索引擎 Elasticsearch 入门教程.md","hash":"0e85b0bbf8d4b9e645b369a0a2dc6390e116e135","modified":1512019702000},{"_id":"source/_posts/componentWillReceiveProps详解（this.props）状态改变检测机制.md","hash":"b33e9f84cb73c1a989a489280f1f1b1384a93b65","modified":1513678607000},{"_id":"source/_posts/filter配置跨域访问.md","hash":"939a961e6e8eea8bd70ebbcb11c920124eacf705","modified":1513677631000},{"_id":"source/_posts/git reset revert 回退回滚取消提交返回上一版本.md","hash":"910aa538dc8ef7bd470060ae3b70dbaffe388b43","modified":1512612389000},{"_id":"source/_posts/git教程.md","hash":"581b0402fc5565a2f360ebed51f57b37f2483c89","modified":1511346284000},{"_id":"source/_posts/nrm -- NPM registry 管理工具.md","hash":"e325fe4869a8d3207af3b6efa3bd795d75dcce19","modified":1513152878000},{"_id":"source/_posts/.Ulysses-Group.plist","hash":"05b5563702dc1be61e061cf430148333aa42caac","modified":1513763703000},{"_id":"source/_posts/安装 node-sass 的正确姿势 - 2.md","hash":"63b304fc547336d743103aa7455cdbd3354702d3","modified":1512106157000},{"_id":"source/_posts/travis测试.md","hash":"f78fc5faa8e67d754e411e95325979b4850876c6","modified":1513821758000},{"_id":"source/_posts/.Ulysses-favorites.plist","hash":"f4c7e3b0fde4814bac2c2b4d849a7116bea99c90","modified":1513821460000},{"_id":"source/_posts/把项目同时托管到github和oschina.md","hash":"d69ab705cb62c3804346369a688daaca32daa019","modified":1513731456000},{"_id":"source/_posts/快速掌握dockerfile.md","hash":"7f1d39e6287994d7dd23a697c0c6b2cd725be059","modified":1513042457000},{"_id":"source/_posts/搭建ShadowSocks.md","hash":"ed02d5427c8dae43adb8cc4287e01067a5b85b92","modified":1512975355000},{"_id":"source/_posts/手把手搭建Hexo+OSChina博客.md","hash":"51f82062b271bb575dd76c163c91d0dae3157769","modified":1512013024000},{"_id":"source/_posts/解决 mac （windows）终端上代理的难题.md","hash":"c21a2cc7939fe8c6e3ec4438903370907831acba","modified":1513061430000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1510912922000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1510912922000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1510912922000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1510912922000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1510912922000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1510912922000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1510912922000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1510912922000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1510912922000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1510912922000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1510912922000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1510912922000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1510912922000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1510912922000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1510912922000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1510912922000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1510912922000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1510912922000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1510912922000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1510912922000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1510912922000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1510912922000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1510912922000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1510912922000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1510912922000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1510912922000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1510912922000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1510912922000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1510912922000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1510912922000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1510912922000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1510912922000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1510912922000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1510912922000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1510912922000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1510912922000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1510912922000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1510912922000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1510912922000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1510912922000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1510912922000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1510912922000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1510912922000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1510912922000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1510912922000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1510912922000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1510912922000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510912922000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1510912922000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1510912922000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1510912922000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1510912922000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1510912922000},{"_id":"themes/next/source/js/.DS_Store","hash":"2f7cd6f8e5c038cdc17ecd460f7ce78814ae3309","modified":1511149757000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1510912922000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1510912922000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1510912922000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1510912922000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1510912922000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1510912922000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1510912922000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1510912922000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1510912922000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1510912922000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1510912922000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1510912922000},{"_id":"themes/next/.git/refs/heads/master","hash":"53814d46a4f19b2e026339024c8c1e2f179bdb6c","modified":1510912922000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1510912922000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1510912922000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1510912922000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1510912922000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1510912922000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1510912922000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1510912922000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1510912922000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1510912922000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1510912922000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1510912922000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1510912922000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1510912922000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1510912922000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1510912922000},{"_id":"themes/next/source/js/src/.DS_Store","hash":"5f0d4fc239f2008f81d15348ff528bbec8c52be0","modified":1511149784000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1510912922000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1510912922000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1510912922000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1510912922000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1510912922000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1510912922000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1510912922000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1510912922000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1510912922000},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1510912922000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1510912922000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1510912922000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1510912922000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1510912922000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1510912922000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1510912922000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1510912922000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1510912922000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1510912922000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1510912922000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1510912922000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1510912922000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1510912922000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1510912922000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1510912922000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1510912922000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1510912922000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1510912922000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1510912922000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1510912922000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1510912922000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1510912922000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1510912922000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1510912922000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1510912922000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1510912922000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1510912922000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1510912922000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"9d594502bc4cdd735255cec561bc4e6d2a191763","modified":1510912922000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1510912922000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1510912922000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1510912922000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1510912922000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1510912922000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1510912922000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1510912922000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1510912922000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1510912922000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1510912922000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1510912922000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1510912922000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1510912922000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1510912922000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1510912922000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"9d594502bc4cdd735255cec561bc4e6d2a191763","modified":1510912922000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1510912922000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1510912922000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1510912922000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1510912922000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1510912922000},{"_id":"themes/next/.git/objects/pack/pack-28d87b026b5370a385755d143050e3ce0ce161e2.idx","hash":"db365f2626516321010a95981bdf898fb0c79a82","modified":1510912921000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1510912922000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1510912922000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1510912922000},{"_id":"themes/next/.git/objects/pack/pack-28d87b026b5370a385755d143050e3ce0ce161e2.pack","hash":"bb95fb2e0a3eaefe07c90c71ef4e9be7ca80c5eb","modified":1510912921000},{"_id":"public/about/index.html","hash":"f0a02ce8130ac2a679f72d83c599c6e6b158843a","modified":1513822143695},{"_id":"public/tags/index.html","hash":"b109e476b692ca07b6c1698f5a736f7bcc1948dd","modified":1513822143696},{"_id":"public/categories/index.html","hash":"28a437287d07d02be1fc97ab59088daf5dae3f72","modified":1513822143696},{"_id":"public/2017/12/12/Docker常用命令/index.html","hash":"f9ddf2d7eb88617586ae2707289941adf6901fe9","modified":1513822143697},{"_id":"public/tags/防火墙/index.html","hash":"3d9ecd9ecf48202b7eccd2a312aea01331bf65c3","modified":1513822143697},{"_id":"public/tags/iptables/index.html","hash":"cee52abf435b138978743e64e544b87301d47539","modified":1513822143698},{"_id":"public/tags/firewall/index.html","hash":"8c207be77dcd066b223382a3e421a9c80a39e1a1","modified":1513822143698},{"_id":"public/tags/SELINUX/index.html","hash":"87594ba8c6e929c071a6df0547911dbaf80a8bbb","modified":1513822143698},{"_id":"public/tags/Docker/index.html","hash":"3908f913d7078796a69138cc199ad3632a912c76","modified":1513822143698},{"_id":"public/tags/Git/index.html","hash":"4058100090f4ba5fa49c9769f0b13de53ac5ce20","modified":1513822143698},{"_id":"public/tags/Mac/index.html","hash":"928443ce982ca94411ed889870c0c771a32c33ee","modified":1513822143699},{"_id":"public/tags/PHP7/index.html","hash":"e2d01a54937a21abf0a2c60324e035ebf9cc9739","modified":1513822143700},{"_id":"public/tags/React/index.html","hash":"88e1e1b0db655141aa02dc54248199f081f436f8","modified":1513822143700},{"_id":"public/tags/全文搜索/index.html","hash":"e484f36b1e64d86defbf0407df3fce1026bd7242","modified":1513822143700},{"_id":"public/tags/Elasticsearch/index.html","hash":"3e6458360994934230ef9436d58d6fa3b39c8c29","modified":1513822143700},{"_id":"public/tags/componentWillReceiveProps/index.html","hash":"1131770b2345f597fbd14a4f1c5cb73eafafd832","modified":1513822143700},{"_id":"public/tags/filter/index.html","hash":"099b513368576791c6fe45788682f00e0fc09705","modified":1513822143700},{"_id":"public/tags/跨域/index.html","hash":"5c1d5bbea7ff66b838e201ffced9e13b15aea4bd","modified":1513822143700},{"_id":"public/tags/NPM/index.html","hash":"c98bf9d5fcf7b280d579becb4bc1318489e3df3d","modified":1513822143700},{"_id":"public/tags/nrm/index.html","hash":"596a551890e5ef058f35a4101a4c69504e3af498","modified":1513822143700},{"_id":"public/tags/node-sass/index.html","hash":"fca5bbc3ba17d4e255835f707b8ad9b5fab4913c","modified":1513822143700},{"_id":"public/tags/Dockerfile/index.html","hash":"9249e26bc964e9413acabd5705b4d919f2c20392","modified":1513822143701},{"_id":"public/tags/ShadowSocks/index.html","hash":"192b965ccd5384e1fac14b2bbc4396a5297b562f","modified":1513822143701},{"_id":"public/tags/Hexo/index.html","hash":"8526ee3de0122d0dffb100093ef7293053ae2866","modified":1513822143701},{"_id":"public/tags/OSChina/index.html","hash":"57a839a701a64e3415ba465243ec8ca3e93accad","modified":1513822143702},{"_id":"public/tags/博客/index.html","hash":"dcd2047ffbf5dd40125060844a2362639f865e1f","modified":1513822143702},{"_id":"public/archives/page/2/index.html","hash":"623f9d59f63c1258ab21ade42cdde3bef0954622","modified":1513822143697},{"_id":"public/archives/2017/page/2/index.html","hash":"a33a18db42fe3c9c73fac11834dcd7c646864fff","modified":1513822143697},{"_id":"public/archives/2017/11/index.html","hash":"221662e32567cfd82a705f7ed2e65ca18addf13b","modified":1513822143697},{"_id":"public/archives/2017/12/page/2/index.html","hash":"73472af26dcfce90f2149928c34c56c60986d2fe","modified":1513822143697},{"_id":"public/categories/Linux/index.html","hash":"69f1a0aec5d09298c2cf25fd7d94fbf895258335","modified":1513822143697},{"_id":"public/categories/Docker/index.html","hash":"ce605c0826f51f1aa01719e5669afb917bf12969","modified":1513822143697},{"_id":"public/categories/Git/index.html","hash":"0c18401f917853d683790897c9721e8e1364e4b8","modified":1513822143697},{"_id":"public/categories/PHP/index.html","hash":"1e15e58f376636fc5978d024c5338ab9df8855e1","modified":1513822143697},{"_id":"public/categories/前端/index.html","hash":"92b7e4172eb9cbb22d475a383a2988fe619830ad","modified":1513822143697},{"_id":"public/categories/后端/index.html","hash":"5952e9dae33675561a8a9c3888b8dcbd0adafa1c","modified":1513822143697},{"_id":"public/categories/干货/index.html","hash":"4a3d2e002edfb561bcf3bc727a79fdc57590a653","modified":1513822143697},{"_id":"public/2017/12/20/把项目同时托管到github和oschina/index.html","hash":"7dab6bd6c9e93211dc2f0f0c13ac130e6a4ac740","modified":1513822143702},{"_id":"public/2017/12/19/componentWillReceiveProps详解（this.props）状态改变检测机制/index.html","hash":"83bff6bbf622976eb6c745bda577fca13ec841e2","modified":1513822143702},{"_id":"public/2017/12/13/nrm -- NPM registry 管理工具/index.html","hash":"b0821bcb2e809f8b13870ecd48fc81ef7f4578d2","modified":1513822143702},{"_id":"public/2017/12/12/解决 mac （windows）终端上代理的难题/index.html","hash":"3576c8c8dc442c14d2bf41de99314cc1614072f6","modified":1513822143702},{"_id":"public/2017/12/12/快速掌握dockerfile/index.html","hash":"5e850c4e83bd63179b5134a94dfe6c54fb86e6ad","modified":1513822143702},{"_id":"public/2017/12/11/搭建ShadowSocks/index.html","hash":"b5186433b7853dd5837c6e2ebb80975f1cec8958","modified":1513822143702},{"_id":"public/2017/12/08/Centos7.0 中的中iptables、firewall和SELINUX/index.html","hash":"1a9f0e1680920a7e2f04a59d21c85716c19d7b16","modified":1513822143702},{"_id":"public/2017/12/07/React总结/index.html","hash":"4cda59c5ece0071e04e6726f66bee8048a89217a","modified":1513822143702},{"_id":"public/2017/12/07/Git撤销&回滚操作/index.html","hash":"ba4e0a9641f6c5d51d9cd7db4f760dd93a9e116f","modified":1513822143703},{"_id":"public/2017/12/07/git reset revert 回退回滚取消提交返回上一版本/index.html","hash":"dd5f263a02feb8a9b32cb3a6fb0f89ee9a390a47","modified":1513822143703},{"_id":"public/2017/12/01/安装 node-sass 的正确姿势 - 2/index.html","hash":"53f38a19a0fcfea1068877e5526d80522b1b5efe","modified":1513822143703},{"_id":"public/2017/12/01/Mac系统安装PHP7教程/index.html","hash":"751b45ba4ed23e3c39e4ff1ce7e76483bc3d76f6","modified":1513822143703},{"_id":"public/2017/11/30/[转]全文搜索引擎 Elasticsearch 入门教程/index.html","hash":"64f4b5c74150f0fe5f94b71247c50480cbf6d973","modified":1513822143703},{"_id":"public/2017/11/20/filter配置跨域访问/index.html","hash":"3308597c2737e9a9738b83eba7405ab6114a471a","modified":1513822143703},{"_id":"public/2017/11/20/git教程/index.html","hash":"f7e17c3be95f478a775f17fa6d85cbc9c4516fb1","modified":1513822143703},{"_id":"public/2017/11/17/手把手搭建Hexo+OSChina博客/index.html","hash":"5bf6dbd30ce6dac71c8799204fff736f81dc5803","modified":1513822143703},{"_id":"public/archives/index.html","hash":"0087049b50246ad897195335900befaed914c969","modified":1513822143703},{"_id":"public/archives/2017/index.html","hash":"cb4be680798a332e09b33faa72d3466a58fb7334","modified":1513822143703},{"_id":"public/archives/2017/12/index.html","hash":"6679c49ec03818e66d112c89abad19b7f93c4cd8","modified":1513822143703},{"_id":"public/index.html","hash":"38be6936d1985fa1a1b121dba8038a26013c4667","modified":1513822143703},{"_id":"public/page/2/index.html","hash":"d7c84d5937daff2c989c367e74b55c39d65900f2","modified":1513822143703},{"_id":"public/tags/travis/index.html","hash":"176a5a1e821631eb2c3af27814d0af73007aa67a","modified":1513822143701},{"_id":"public/2017/12/20/travis测试/index.html","hash":"a81b43627668fd2ca1c5a0b8fb230e6a236010a5","modified":1513822143696},{"_id":"public/tags/git/index.html","hash":"f66e93ffc3f32ad948506a0d76324dc06897e374","modified":1513822143700},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1513822143724},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1513822143724},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1513822143724},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1513822143724},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1513822143725},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1513822143725},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1513822143725},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1513822143725},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1513822143725},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1513822143725},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1513822143725},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1513822143725},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513822143725},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1513822143725},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513822143725},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1513822143753},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1513822143754},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1513822143805},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1513822143805},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513822143805},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513822143805},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513822143805},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1513822143825},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513822143806},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513822143806},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513822143815},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1513822143822},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1513822143825},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1513822143825},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1513822143825},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513822143826},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1513822143827},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1513822143827},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1513822145720},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1513822145750},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1513822145771},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1513822145771},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1513822145778},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1513822145778},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1513822145778},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1513822145778},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1513822145778},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1513822145778},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1513822145778},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1513822145778},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1513822145778},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1513822145778},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1513822145778},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1513822145778},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1513822145778},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1513822145778},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1513822145779},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1513822145779},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1513822145779},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1513822145779},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1513822145779},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1513822145779},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1513822145780},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1513822145780},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1513822145780},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1513822145780},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1513822145780},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1513822145781},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1513822145781},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1513822145781},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1513822145781},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1513822145781},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1513822145781},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1513822145781},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1513822145781},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513822145782},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1513822145782},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1513822145782},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513822145782},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1513822145782},{"_id":"public/css/main.css","hash":"e71b34a920a4f5e4039596a58abae15f04dab52c","modified":1513822145718},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1513822145782},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1513822145782},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1513822145782},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1513822145782},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1513822145782},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1513822145782},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1513822145782},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1513822145783},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1513822145782},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1513822145783},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1513822145783},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1513822145783},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1513822145783},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1513822145783},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1513822145783},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1513822145783},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1513822145783},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1513822145783},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1513822145811},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1513822145811},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1513822145812},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1513822145812},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1513822145812},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1513822145859}],"Category":[{"name":"Linux","_id":"cjbfukjwn0004xqs6jc8u3o2p"},{"name":"Docker","_id":"cjbfukjxj000axqs6jhxsfjrc"},{"name":"Git","_id":"cjbfukjxu000fxqs6gaaxsndl"},{"name":"PHP","_id":"cjbfukjy4000kxqs6r1mq6fsc"},{"name":"前端","_id":"cjbfukjye000pxqs60oog87lm"},{"name":"后端","_id":"cjbfukjzb001cxqs65r8h1tz5"},{"name":"干货","_id":"cjbfukjzf001hxqs6wrz5pygs"}],"Data":[],"Page":[{"title":"about","date":"2017-11-20T04:59:39.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-11-20 12:59:39\ncomments: false\n---","updated":"2017-12-20T09:55:03.000Z","path":"about/index.html","layout":"page","_id":"cjbfukjvt0000xqs6lzoczdfo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-11-20T04:45:11.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-11-20 12:45:11\ntype: \"tags\"\ncomments: false\n---","updated":"2017-12-20T09:55:03.000Z","path":"tags/index.html","layout":"page","_id":"cjbfukjwf0002xqs6hz7i841l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-11-20T04:52:19.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-11-20 12:52:19\ntype: \"categories\"\ncomments: false\n---","updated":"2017-12-20T09:55:03.000Z","path":"categories/index.html","layout":"page","_id":"cjbfukjww0006xqs6y78t1vjy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Centos7.0 中的中iptables、firewall和SELINUX","data":"2017-12-08T09:14:01.000Z","_content":"\nCentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。\n\n## firewall\nfirewall能够允许哪些服务可用，那些端口可用.... 属于更高一层的防火墙。\nfirewall的底层是使用iptables进行数据过滤，建立在iptables之上。\n\nfirewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。  \n\n## 关闭firewall\n\n```bash\nsystemctl stop firewalld.service #停止firewall\nsystemctl disable firewalld.service #禁止firewall开机启动\nfirewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）  \n```\n\n## iptables\niptables用于过滤数据包，属于网络层防火墙.  \n\n在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。  \n\n## iptables防火墙\n```bash\nyum install iptables-services #安装iptables\nvi /etc/sysconfig/iptables #编辑iptables防火墙配置文件\n```\n\n```bash\nFirewall configuration written by system-config-firewall\nManual customization of this file is not recommended.\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n-A INPUT -j REJECT --reject-with icmp-host-prohibited\n-A FORWARD -j REJECT --reject-with icmp-host-prohibited\nCOMMIT\n:wq! #保存退出\n```\n\n```bash\nsystemctl restart iptables.service #最后重启防火墙使配置生效\nsystemctl enable iptables.service #设置防火墙开机启动\nyum remove iptables   #卸载iptables\n```\n\n## SELinux\n\nSELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。它不是用来防火墙设置的。但它对Linux系统的安全很有用。Linux内核(Kernel)从2.6就有了SELinux。  \n\nSELinux是一种基于 域-类型 模型（domain-type）的强制访问控制（MAC）安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略。任何程序对其资源享有完全的控制权。假设某个程序打算把含有潜在重要信息的文件扔到/tmp目录下，那么在DAC情况下没人能阻止他。SELinux提供了比传统的UNⅨ权限更好的访问控制。\n\n## 关闭SELinux\n\n```bash\nvi  /etc/selinux/config\n```\n\n```bash\nSELINUX=enforcing #注释掉  \nSELINUXTYPE=targeted #注释掉  \nSELINUX=disabled #增加  \n```\n\n:wq! #保存退出\nsetenforce 0 #使配置立即生效","source":"_posts/Centos7.0 中的中iptables、firewall和SELINUX.md","raw":"---\ntitle: Centos7.0 中的中iptables、firewall和SELINUX\ndata:  2017-12-8 17:14:01\ntag:\n- 防火墙\n- iptables\n- firewall\n- SELINUX\ncategories: Linux\n---\n\nCentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。\n\n## firewall\nfirewall能够允许哪些服务可用，那些端口可用.... 属于更高一层的防火墙。\nfirewall的底层是使用iptables进行数据过滤，建立在iptables之上。\n\nfirewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。  \n\n## 关闭firewall\n\n```bash\nsystemctl stop firewalld.service #停止firewall\nsystemctl disable firewalld.service #禁止firewall开机启动\nfirewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）  \n```\n\n## iptables\niptables用于过滤数据包，属于网络层防火墙.  \n\n在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。  \n\n## iptables防火墙\n```bash\nyum install iptables-services #安装iptables\nvi /etc/sysconfig/iptables #编辑iptables防火墙配置文件\n```\n\n```bash\nFirewall configuration written by system-config-firewall\nManual customization of this file is not recommended.\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n-A INPUT -j REJECT --reject-with icmp-host-prohibited\n-A FORWARD -j REJECT --reject-with icmp-host-prohibited\nCOMMIT\n:wq! #保存退出\n```\n\n```bash\nsystemctl restart iptables.service #最后重启防火墙使配置生效\nsystemctl enable iptables.service #设置防火墙开机启动\nyum remove iptables   #卸载iptables\n```\n\n## SELinux\n\nSELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。它不是用来防火墙设置的。但它对Linux系统的安全很有用。Linux内核(Kernel)从2.6就有了SELinux。  \n\nSELinux是一种基于 域-类型 模型（domain-type）的强制访问控制（MAC）安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略。任何程序对其资源享有完全的控制权。假设某个程序打算把含有潜在重要信息的文件扔到/tmp目录下，那么在DAC情况下没人能阻止他。SELinux提供了比传统的UNⅨ权限更好的访问控制。\n\n## 关闭SELinux\n\n```bash\nvi  /etc/selinux/config\n```\n\n```bash\nSELINUX=enforcing #注释掉  \nSELINUXTYPE=targeted #注释掉  \nSELINUX=disabled #增加  \n```\n\n:wq! #保存退出\nsetenforce 0 #使配置立即生效","slug":"Centos7.0 中的中iptables、firewall和SELINUX","published":1,"date":"2017-12-08T09:13:59.000Z","updated":"2017-12-11T07:41:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjw20001xqs6zhdbu3ed","content":"<p>CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。</p>\n<h2 id=\"firewall\"><a href=\"#firewall\" class=\"headerlink\" title=\"firewall\"></a>firewall</h2><p>firewall能够允许哪些服务可用，那些端口可用…. 属于更高一层的防火墙。<br>firewall的底层是使用iptables进行数据过滤，建立在iptables之上。</p>\n<p>firewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。  </p>\n<h2 id=\"关闭firewall\"><a href=\"#关闭firewall\" class=\"headerlink\" title=\"关闭firewall\"></a>关闭firewall</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld.service <span class=\"comment\">#停止firewall</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld.service <span class=\"comment\">#禁止firewall开机启动</span></span><br><span class=\"line\">firewall-cmd --state <span class=\"comment\">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h2><p>iptables用于过滤数据包，属于网络层防火墙.  </p>\n<p>在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。  </p>\n<h2 id=\"iptables防火墙\"><a href=\"#iptables防火墙\" class=\"headerlink\" title=\"iptables防火墙\"></a>iptables防火墙</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install iptables-services <span class=\"comment\">#安装iptables</span></span><br><span class=\"line\">vi /etc/sysconfig/iptables <span class=\"comment\">#编辑iptables防火墙配置文件</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Firewall configuration written by system-config-firewall</span><br><span class=\"line\">Manual customization of this file is not recommended.</span><br><span class=\"line\">*filter</span><br><span class=\"line\">:INPUT ACCEPT [0:0]</span><br><span class=\"line\">:FORWARD ACCEPT [0:0]</span><br><span class=\"line\">:OUTPUT ACCEPT [0:0]</span><br><span class=\"line\">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class=\"line\">-A INPUT -p icmp -j ACCEPT</span><br><span class=\"line\">-A INPUT -i lo -j ACCEPT</span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class=\"line\">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class=\"line\">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class=\"line\">COMMIT</span><br><span class=\"line\">:wq! <span class=\"comment\">#保存退出</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart iptables.service <span class=\"comment\">#最后重启防火墙使配置生效</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> iptables.service <span class=\"comment\">#设置防火墙开机启动</span></span><br><span class=\"line\">yum remove iptables   <span class=\"comment\">#卸载iptables</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h2><p>SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。它不是用来防火墙设置的。但它对Linux系统的安全很有用。Linux内核(Kernel)从2.6就有了SELinux。  </p>\n<p>SELinux是一种基于 域-类型 模型（domain-type）的强制访问控制（MAC）安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略。任何程序对其资源享有完全的控制权。假设某个程序打算把含有潜在重要信息的文件扔到/tmp目录下，那么在DAC情况下没人能阻止他。SELinux提供了比传统的UNⅨ权限更好的访问控制。</p>\n<h2 id=\"关闭SELinux\"><a href=\"#关闭SELinux\" class=\"headerlink\" title=\"关闭SELinux\"></a>关闭SELinux</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi  /etc/selinux/config</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELINUX=enforcing <span class=\"comment\">#注释掉  </span></span><br><span class=\"line\">SELINUXTYPE=targeted <span class=\"comment\">#注释掉  </span></span><br><span class=\"line\">SELINUX=disabled <span class=\"comment\">#增加</span></span><br></pre></td></tr></table></figure>\n<p>:wq! #保存退出<br>setenforce 0 #使配置立即生效</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。</p>\n<h2 id=\"firewall\"><a href=\"#firewall\" class=\"headerlink\" title=\"firewall\"></a>firewall</h2><p>firewall能够允许哪些服务可用，那些端口可用…. 属于更高一层的防火墙。<br>firewall的底层是使用iptables进行数据过滤，建立在iptables之上。</p>\n<p>firewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。  </p>\n<h2 id=\"关闭firewall\"><a href=\"#关闭firewall\" class=\"headerlink\" title=\"关闭firewall\"></a>关闭firewall</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld.service <span class=\"comment\">#停止firewall</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld.service <span class=\"comment\">#禁止firewall开机启动</span></span><br><span class=\"line\">firewall-cmd --state <span class=\"comment\">#查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h2><p>iptables用于过滤数据包，属于网络层防火墙.  </p>\n<p>在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。  </p>\n<h2 id=\"iptables防火墙\"><a href=\"#iptables防火墙\" class=\"headerlink\" title=\"iptables防火墙\"></a>iptables防火墙</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install iptables-services <span class=\"comment\">#安装iptables</span></span><br><span class=\"line\">vi /etc/sysconfig/iptables <span class=\"comment\">#编辑iptables防火墙配置文件</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Firewall configuration written by system-config-firewall</span><br><span class=\"line\">Manual customization of this file is not recommended.</span><br><span class=\"line\">*filter</span><br><span class=\"line\">:INPUT ACCEPT [0:0]</span><br><span class=\"line\">:FORWARD ACCEPT [0:0]</span><br><span class=\"line\">:OUTPUT ACCEPT [0:0]</span><br><span class=\"line\">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class=\"line\">-A INPUT -p icmp -j ACCEPT</span><br><span class=\"line\">-A INPUT -i lo -j ACCEPT</span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class=\"line\">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class=\"line\">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class=\"line\">COMMIT</span><br><span class=\"line\">:wq! <span class=\"comment\">#保存退出</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart iptables.service <span class=\"comment\">#最后重启防火墙使配置生效</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> iptables.service <span class=\"comment\">#设置防火墙开机启动</span></span><br><span class=\"line\">yum remove iptables   <span class=\"comment\">#卸载iptables</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h2><p>SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。它不是用来防火墙设置的。但它对Linux系统的安全很有用。Linux内核(Kernel)从2.6就有了SELinux。  </p>\n<p>SELinux是一种基于 域-类型 模型（domain-type）的强制访问控制（MAC）安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略。任何程序对其资源享有完全的控制权。假设某个程序打算把含有潜在重要信息的文件扔到/tmp目录下，那么在DAC情况下没人能阻止他。SELinux提供了比传统的UNⅨ权限更好的访问控制。</p>\n<h2 id=\"关闭SELinux\"><a href=\"#关闭SELinux\" class=\"headerlink\" title=\"关闭SELinux\"></a>关闭SELinux</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi  /etc/selinux/config</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELINUX=enforcing <span class=\"comment\">#注释掉  </span></span><br><span class=\"line\">SELINUXTYPE=targeted <span class=\"comment\">#注释掉  </span></span><br><span class=\"line\">SELINUX=disabled <span class=\"comment\">#增加</span></span><br></pre></td></tr></table></figure>\n<p>:wq! #保存退出<br>setenforce 0 #使配置立即生效</p>\n"},{"title":"Docker常用命令","data":"2017-12-12T06:07:01.000Z","_content":"\n停止容器  \ndocker stop $(docker ps -a | grep \"Exited\" | awk '{print $1 }')  \n删除容器\ndocker rm $(docker ps -a | grep \"Exited\" | awk '{print $1 }') \n或\ndocker rm -v $(docker ps -aq -f status=exited)\n删除镜像\ndocker rmi $(docker images | grep \"none\" | awk '{print $3}')\n","source":"_posts/Docker常用命令.md","raw":"---\ntitle: Docker常用命令\ndata:  2017-12-12 14:07:01\ntag:\n- Docker\ncategories: Docker\n---\n\n停止容器  \ndocker stop $(docker ps -a | grep \"Exited\" | awk '{print $1 }')  \n删除容器\ndocker rm $(docker ps -a | grep \"Exited\" | awk '{print $1 }') \n或\ndocker rm -v $(docker ps -aq -f status=exited)\n删除镜像\ndocker rmi $(docker images | grep \"none\" | awk '{print $3}')\n","slug":"Docker常用命令","published":1,"date":"2017-12-12T06:06:15.000Z","updated":"2017-12-12T06:07:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjwi0003xqs61ssjcb3y","content":"<p>停止容器<br>docker stop $(docker ps -a | grep “Exited” | awk ‘{print $1 }’)<br>删除容器<br>docker rm $(docker ps -a | grep “Exited” | awk ‘{print $1 }’)<br>或<br>docker rm -v $(docker ps -aq -f status=exited)<br>删除镜像<br>docker rmi $(docker images | grep “none” | awk ‘{print $3}’)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>停止容器<br>docker stop $(docker ps -a | grep “Exited” | awk ‘{print $1 }’)<br>删除容器<br>docker rm $(docker ps -a | grep “Exited” | awk ‘{print $1 }’)<br>或<br>docker rm -v $(docker ps -aq -f status=exited)<br>删除镜像<br>docker rmi $(docker images | grep “none” | awk ‘{print $3}’)</p>\n"},{"title":"Git撤销&回滚操作","data":"2017-12-07T02:05:01.000Z","_content":"\n开发过程中，你肯定会遇到这样的场景：\n## 场景一：\n> 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！\n\n## 场景二：\n> 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！\n\n## 场景三：\n> 刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！\n\n# 撤销\n上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！\n## 情况一：文件被修改了，但未执行git add操作(working tree内撤销)\n\n```bash\ngit checkout fileName\ngit checkout .\n```\n\n## 情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件\n\n```bash\n$ git add *\n$ git status\n# 取消暂存\n$ git reset HEAD <filename>\n```\n\n## 情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）\n\n```bash\n# 取消暂存\ngit reset HEAD fileName\n# 撤销修改\ngit checkout fileName\n```\n\n## 情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit\n```bash\n# 修改最后一次提交 \n$ git add sample.txt\n$ git commit --amend -m\"说明\"\n```\n\n## 情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit\n\n```bash\ngit reset [--hard|soft|mixed|merge|keep] [commit|HEAD]\n```\n\n# 回滚\n上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！\n如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况\n\n```bash\ngit checkout <tag>\n```\n\n如果你回到当前HEAD指向\n\n```bash\ngit checkout <branch_name>\n```\n\n## 情况一：撤销指定文件到指定版本\n\n```bash\n# 查看指定文件的历史版本\ngit log <filename>\n# 回滚到指定commitID\ngit checkout <commitID> <filename>\n```\n\n## 情况二：删除最后一次远程提交\n### 方式一：使用revert\n\n```bash\ngit revert HEAD\ngit push origin master\n```\n\n### 方式二：使用reset\n\n```bash\ngit reset --hard HEAD^\ngit push origin master -f\n```\n\n二者区别：\n1. revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；\n2. reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。\n## 情况三：回滚某次提交\n\n```bash\n# 找到要回滚的commitID\ngit log\ngit revert commitID\n```\n\n### 删除某次提交\n\n```bash\ngit log --oneline -n5\n\t\t\ngit rebase -i \"commit id\"^\n```\n\n注意：需要注意最后的^号，意思是commit id的前一次提交\n\n```bash\ngit rebase -i \"5b3ba7a\"^\n```\n\n在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！\n\n```bash\ngit push origin master -f\n```\n\n通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。","source":"_posts/Git撤销&回滚操作.md","raw":"---\ntitle: Git撤销&回滚操作\ndata:  2017-12-7 10:05:01\ntag:\n- Git\ncategories: Git\n---\n\n开发过程中，你肯定会遇到这样的场景：\n## 场景一：\n> 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！\n\n## 场景二：\n> 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！\n\n## 场景三：\n> 刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！\n\n# 撤销\n上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！\n## 情况一：文件被修改了，但未执行git add操作(working tree内撤销)\n\n```bash\ngit checkout fileName\ngit checkout .\n```\n\n## 情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件\n\n```bash\n$ git add *\n$ git status\n# 取消暂存\n$ git reset HEAD <filename>\n```\n\n## 情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）\n\n```bash\n# 取消暂存\ngit reset HEAD fileName\n# 撤销修改\ngit checkout fileName\n```\n\n## 情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit\n```bash\n# 修改最后一次提交 \n$ git add sample.txt\n$ git commit --amend -m\"说明\"\n```\n\n## 情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit\n\n```bash\ngit reset [--hard|soft|mixed|merge|keep] [commit|HEAD]\n```\n\n# 回滚\n上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！\n如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况\n\n```bash\ngit checkout <tag>\n```\n\n如果你回到当前HEAD指向\n\n```bash\ngit checkout <branch_name>\n```\n\n## 情况一：撤销指定文件到指定版本\n\n```bash\n# 查看指定文件的历史版本\ngit log <filename>\n# 回滚到指定commitID\ngit checkout <commitID> <filename>\n```\n\n## 情况二：删除最后一次远程提交\n### 方式一：使用revert\n\n```bash\ngit revert HEAD\ngit push origin master\n```\n\n### 方式二：使用reset\n\n```bash\ngit reset --hard HEAD^\ngit push origin master -f\n```\n\n二者区别：\n1. revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；\n2. reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。\n## 情况三：回滚某次提交\n\n```bash\n# 找到要回滚的commitID\ngit log\ngit revert commitID\n```\n\n### 删除某次提交\n\n```bash\ngit log --oneline -n5\n\t\t\ngit rebase -i \"commit id\"^\n```\n\n注意：需要注意最后的^号，意思是commit id的前一次提交\n\n```bash\ngit rebase -i \"5b3ba7a\"^\n```\n\n在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！\n\n```bash\ngit push origin master -f\n```\n\n通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。","slug":"Git撤销&回滚操作","published":1,"date":"2017-12-07T02:35:59.000Z","updated":"2017-12-07T02:45:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjwy0007xqs622jixcnp","content":"<p>开发过程中，你肯定会遇到这样的场景：</p>\n<h2 id=\"场景一：\"><a href=\"#场景一：\" class=\"headerlink\" title=\"场景一：\"></a>场景一：</h2><blockquote>\n<p>糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！</p>\n</blockquote>\n<h2 id=\"场景二：\"><a href=\"#场景二：\" class=\"headerlink\" title=\"场景二：\"></a>场景二：</h2><blockquote>\n<p>彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！</p>\n</blockquote>\n<h2 id=\"场景三：\"><a href=\"#场景三：\" class=\"headerlink\" title=\"场景三：\"></a>场景三：</h2><blockquote>\n<p>刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！</p>\n</blockquote>\n<h1 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h1><p>上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！</p>\n<h2 id=\"情况一：文件被修改了，但未执行git-add操作-working-tree内撤销\"><a href=\"#情况一：文件被修改了，但未执行git-add操作-working-tree内撤销\" class=\"headerlink\" title=\"情况一：文件被修改了，但未执行git add操作(working tree内撤销)\"></a>情况一：文件被修改了，但未执行git add操作(working tree内撤销)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout fileName</span><br><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况二：同时对多个文件执行了git-add操作，但本次只想提交其中一部分文件\"><a href=\"#情况二：同时对多个文件执行了git-add操作，但本次只想提交其中一部分文件\" class=\"headerlink\" title=\"情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件\"></a>情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add *</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># 取消暂存</span></span><br><span class=\"line\">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况三：文件执行了git-add操作，但想撤销对其的修改（index内回滚）\"><a href=\"#情况三：文件执行了git-add操作，但想撤销对其的修改（index内回滚）\" class=\"headerlink\" title=\"情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）\"></a>情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 取消暂存</span></span><br><span class=\"line\">git reset HEAD fileName</span><br><span class=\"line\"><span class=\"comment\"># 撤销修改</span></span><br><span class=\"line\">git checkout fileName</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况四：修改的文件已被git-commit，但想再次修改不再产生新的Commit\"><a href=\"#情况四：修改的文件已被git-commit，但想再次修改不再产生新的Commit\" class=\"headerlink\" title=\"情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit\"></a>情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改最后一次提交 </span></span><br><span class=\"line\">$ git add sample.txt</span><br><span class=\"line\">$ git commit --amend -m<span class=\"string\">\"说明\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"情况五：已在本地进行了多次git-commit操作，现在想撤销到其中某次Commit\"><a href=\"#情况五：已在本地进行了多次git-commit操作，现在想撤销到其中某次Commit\" class=\"headerlink\" title=\"情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit\"></a>情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</span><br></pre></td></tr></table></figure>\n<h1 id=\"回滚\"><a href=\"#回滚\" class=\"headerlink\" title=\"回滚\"></a>回滚</h1><p>上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！<br>如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;tag&gt;</span><br></pre></td></tr></table></figure>\n<p>如果你回到当前HEAD指向</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况一：撤销指定文件到指定版本\"><a href=\"#情况一：撤销指定文件到指定版本\" class=\"headerlink\" title=\"情况一：撤销指定文件到指定版本\"></a>情况一：撤销指定文件到指定版本</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定文件的历史版本</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> &lt;filename&gt;</span><br><span class=\"line\"><span class=\"comment\"># 回滚到指定commitID</span></span><br><span class=\"line\">git checkout &lt;commitID&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况二：删除最后一次远程提交\"><a href=\"#情况二：删除最后一次远程提交\" class=\"headerlink\" title=\"情况二：删除最后一次远程提交\"></a>情况二：删除最后一次远程提交</h2><h3 id=\"方式一：使用revert\"><a href=\"#方式一：使用revert\" class=\"headerlink\" title=\"方式一：使用revert\"></a>方式一：使用revert</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert HEAD</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"方式二：使用reset\"><a href=\"#方式二：使用reset\" class=\"headerlink\" title=\"方式二：使用reset\"></a>方式二：使用reset</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br><span class=\"line\">git push origin master -f</span><br></pre></td></tr></table></figure>\n<p>二者区别：</p>\n<ol>\n<li>revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>\n<li>reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。<h2 id=\"情况三：回滚某次提交\"><a href=\"#情况三：回滚某次提交\" class=\"headerlink\" title=\"情况三：回滚某次提交\"></a>情况三：回滚某次提交</h2></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 找到要回滚的commitID</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\">git revert commitID</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除某次提交\"><a href=\"#删除某次提交\" class=\"headerlink\" title=\"删除某次提交\"></a>删除某次提交</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --oneline -n5</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">git rebase -i <span class=\"string\">\"commit id\"</span>^</span><br></pre></td></tr></table></figure>\n<p>注意：需要注意最后的^号，意思是commit id的前一次提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i <span class=\"string\">\"5b3ba7a\"</span>^</span><br></pre></td></tr></table></figure>\n<p>在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master -f</span><br></pre></td></tr></table></figure>\n<p>通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>开发过程中，你肯定会遇到这样的场景：</p>\n<h2 id=\"场景一：\"><a href=\"#场景一：\" class=\"headerlink\" title=\"场景一：\"></a>场景一：</h2><blockquote>\n<p>糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！</p>\n</blockquote>\n<h2 id=\"场景二：\"><a href=\"#场景二：\" class=\"headerlink\" title=\"场景二：\"></a>场景二：</h2><blockquote>\n<p>彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！</p>\n</blockquote>\n<h2 id=\"场景三：\"><a href=\"#场景三：\" class=\"headerlink\" title=\"场景三：\"></a>场景三：</h2><blockquote>\n<p>刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！</p>\n</blockquote>\n<h1 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h1><p>上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！</p>\n<h2 id=\"情况一：文件被修改了，但未执行git-add操作-working-tree内撤销\"><a href=\"#情况一：文件被修改了，但未执行git-add操作-working-tree内撤销\" class=\"headerlink\" title=\"情况一：文件被修改了，但未执行git add操作(working tree内撤销)\"></a>情况一：文件被修改了，但未执行git add操作(working tree内撤销)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout fileName</span><br><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况二：同时对多个文件执行了git-add操作，但本次只想提交其中一部分文件\"><a href=\"#情况二：同时对多个文件执行了git-add操作，但本次只想提交其中一部分文件\" class=\"headerlink\" title=\"情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件\"></a>情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add *</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># 取消暂存</span></span><br><span class=\"line\">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况三：文件执行了git-add操作，但想撤销对其的修改（index内回滚）\"><a href=\"#情况三：文件执行了git-add操作，但想撤销对其的修改（index内回滚）\" class=\"headerlink\" title=\"情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）\"></a>情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 取消暂存</span></span><br><span class=\"line\">git reset HEAD fileName</span><br><span class=\"line\"><span class=\"comment\"># 撤销修改</span></span><br><span class=\"line\">git checkout fileName</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况四：修改的文件已被git-commit，但想再次修改不再产生新的Commit\"><a href=\"#情况四：修改的文件已被git-commit，但想再次修改不再产生新的Commit\" class=\"headerlink\" title=\"情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit\"></a>情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改最后一次提交 </span></span><br><span class=\"line\">$ git add sample.txt</span><br><span class=\"line\">$ git commit --amend -m<span class=\"string\">\"说明\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"情况五：已在本地进行了多次git-commit操作，现在想撤销到其中某次Commit\"><a href=\"#情况五：已在本地进行了多次git-commit操作，现在想撤销到其中某次Commit\" class=\"headerlink\" title=\"情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit\"></a>情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</span><br></pre></td></tr></table></figure>\n<h1 id=\"回滚\"><a href=\"#回滚\" class=\"headerlink\" title=\"回滚\"></a>回滚</h1><p>上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！<br>如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;tag&gt;</span><br></pre></td></tr></table></figure>\n<p>如果你回到当前HEAD指向</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况一：撤销指定文件到指定版本\"><a href=\"#情况一：撤销指定文件到指定版本\" class=\"headerlink\" title=\"情况一：撤销指定文件到指定版本\"></a>情况一：撤销指定文件到指定版本</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看指定文件的历史版本</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> &lt;filename&gt;</span><br><span class=\"line\"><span class=\"comment\"># 回滚到指定commitID</span></span><br><span class=\"line\">git checkout &lt;commitID&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"情况二：删除最后一次远程提交\"><a href=\"#情况二：删除最后一次远程提交\" class=\"headerlink\" title=\"情况二：删除最后一次远程提交\"></a>情况二：删除最后一次远程提交</h2><h3 id=\"方式一：使用revert\"><a href=\"#方式一：使用revert\" class=\"headerlink\" title=\"方式一：使用revert\"></a>方式一：使用revert</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert HEAD</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h3 id=\"方式二：使用reset\"><a href=\"#方式二：使用reset\" class=\"headerlink\" title=\"方式二：使用reset\"></a>方式二：使用reset</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br><span class=\"line\">git push origin master -f</span><br></pre></td></tr></table></figure>\n<p>二者区别：</p>\n<ol>\n<li>revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>\n<li>reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。<h2 id=\"情况三：回滚某次提交\"><a href=\"#情况三：回滚某次提交\" class=\"headerlink\" title=\"情况三：回滚某次提交\"></a>情况三：回滚某次提交</h2></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 找到要回滚的commitID</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\">git revert commitID</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除某次提交\"><a href=\"#删除某次提交\" class=\"headerlink\" title=\"删除某次提交\"></a>删除某次提交</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --oneline -n5</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">git rebase -i <span class=\"string\">\"commit id\"</span>^</span><br></pre></td></tr></table></figure>\n<p>注意：需要注意最后的^号，意思是commit id的前一次提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i <span class=\"string\">\"5b3ba7a\"</span>^</span><br></pre></td></tr></table></figure>\n<p>在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master -f</span><br></pre></td></tr></table></figure>\n<p>通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。</p>\n"},{"title":"Mac系统安装PHP7教程","data":"2017-12-05T08:21:01.000Z","_content":"\n安装教程：\n## 1.首先我们需要安装Homebrew\n一条命令完美安装：[http://brew.sh/index\\_zh-cn.html][1]\n## 2.终端输入以下命令\n\n```bash\n// 创建目录,如果你没有创建过该目录\nsudo mkdir /usr/local/var\nsudo chmod 777 /usr/local/var\n//修改成你自己的用户名和组,如果你没有创建过该目录\nsudo mkdir /usr/local/sbin/\nsudo chown -R <username>:<group> /usr/local/sbin//由于我本身一直在使用5.6版本，故上述步骤省略，下面进入正题\n//添加PHP库\nbrew tap homebrew/dupes\nbrew tap homebrew/versions\nbrew tap homebrew/homebrew-php\n//关闭老版本的PHP56或55或更早版本 进程\nbrew unlink php56\n//开始安装PHP7\nbrew install php70\n//开启PHP70进程\nbrew link php70\n//输入命令，查看是否成功\nphp -v\n//成功后显示下面信息\nPHP 7.0.8 (cli) (built: Jul 13 2016 15:19:21) ( NTS )\nCopyright (c) 1997-2016 The PHP Group\nZend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies\n```\n\n注：遇未生成libphp7.so\n\n```bash\nbrew install php70 --with-apxs2  --with-apache --with-gmp --with-imap --with-tidy --with-debug\n```\n\n## 3.配置Apache\n```bash\n$ sudo vim /etc/apache2/httpd.conf\n找到这行注释掉(大概在168行）\nComment out the PHP5 module   \nLoadModule php5_module libexec/apache2/libphp5.so\n\nEnable PHP 7 module  \nLoadModule php7_module /usr/local/opt/php70/libexec/apache2/libphp7.so  <FilesMatch \\.php$>\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n## 4.重启Apache\n\n```bash\nsudo apachectl restart\n```\n\n## 5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件\n```bash\n<?php    \nphpinfo();    \n?>\n```\n\n最后到你的 http://localhost/info.php 去看看测试以下，如果看到相关的信息，就说明已经安装好了。\n\n\n\n[1]:\thttp://brew.sh/index_zh-cn.html","source":"_posts/Mac系统安装PHP7教程.md","raw":"---\ntitle: Mac系统安装PHP7教程\ndata:  2017-12-5 16:21:01\ntag:\n- Mac\n- PHP7\ncategories: PHP\n---\n\n安装教程：\n## 1.首先我们需要安装Homebrew\n一条命令完美安装：[http://brew.sh/index\\_zh-cn.html][1]\n## 2.终端输入以下命令\n\n```bash\n// 创建目录,如果你没有创建过该目录\nsudo mkdir /usr/local/var\nsudo chmod 777 /usr/local/var\n//修改成你自己的用户名和组,如果你没有创建过该目录\nsudo mkdir /usr/local/sbin/\nsudo chown -R <username>:<group> /usr/local/sbin//由于我本身一直在使用5.6版本，故上述步骤省略，下面进入正题\n//添加PHP库\nbrew tap homebrew/dupes\nbrew tap homebrew/versions\nbrew tap homebrew/homebrew-php\n//关闭老版本的PHP56或55或更早版本 进程\nbrew unlink php56\n//开始安装PHP7\nbrew install php70\n//开启PHP70进程\nbrew link php70\n//输入命令，查看是否成功\nphp -v\n//成功后显示下面信息\nPHP 7.0.8 (cli) (built: Jul 13 2016 15:19:21) ( NTS )\nCopyright (c) 1997-2016 The PHP Group\nZend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies\n```\n\n注：遇未生成libphp7.so\n\n```bash\nbrew install php70 --with-apxs2  --with-apache --with-gmp --with-imap --with-tidy --with-debug\n```\n\n## 3.配置Apache\n```bash\n$ sudo vim /etc/apache2/httpd.conf\n找到这行注释掉(大概在168行）\nComment out the PHP5 module   \nLoadModule php5_module libexec/apache2/libphp5.so\n\nEnable PHP 7 module  \nLoadModule php7_module /usr/local/opt/php70/libexec/apache2/libphp7.so  <FilesMatch \\.php$>\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n## 4.重启Apache\n\n```bash\nsudo apachectl restart\n```\n\n## 5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件\n```bash\n<?php    \nphpinfo();    \n?>\n```\n\n最后到你的 http://localhost/info.php 去看看测试以下，如果看到相关的信息，就说明已经安装好了。\n\n\n\n[1]:\thttp://brew.sh/index_zh-cn.html","slug":"Mac系统安装PHP7教程","published":1,"date":"2017-12-01T05:26:56.000Z","updated":"2017-12-07T05:41:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjxd0008xqs6emzejmio","content":"<p>安装教程：</p>\n<h2 id=\"1-首先我们需要安装Homebrew\"><a href=\"#1-首先我们需要安装Homebrew\" class=\"headerlink\" title=\"1.首先我们需要安装Homebrew\"></a>1.首先我们需要安装Homebrew</h2><p>一条命令完美安装：<a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">http://brew.sh/index_zh-cn.html</a></p>\n<h2 id=\"2-终端输入以下命令\"><a href=\"#2-终端输入以下命令\" class=\"headerlink\" title=\"2.终端输入以下命令\"></a>2.终端输入以下命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建目录,如果你没有创建过该目录</span><br><span class=\"line\">sudo mkdir /usr/<span class=\"built_in\">local</span>/var</span><br><span class=\"line\">sudo chmod 777 /usr/<span class=\"built_in\">local</span>/var</span><br><span class=\"line\">//修改成你自己的用户名和组,如果你没有创建过该目录</span><br><span class=\"line\">sudo mkdir /usr/<span class=\"built_in\">local</span>/sbin/</span><br><span class=\"line\">sudo chown -R &lt;username&gt;:&lt;group&gt; /usr/<span class=\"built_in\">local</span>/sbin//由于我本身一直在使用5.6版本，故上述步骤省略，下面进入正题</span><br><span class=\"line\">//添加PHP库</span><br><span class=\"line\">brew tap homebrew/dupes</span><br><span class=\"line\">brew tap homebrew/versions</span><br><span class=\"line\">brew tap homebrew/homebrew-php</span><br><span class=\"line\">//关闭老版本的PHP56或55或更早版本 进程</span><br><span class=\"line\">brew unlink php56</span><br><span class=\"line\">//开始安装PHP7</span><br><span class=\"line\">brew install php70</span><br><span class=\"line\">//开启PHP70进程</span><br><span class=\"line\">brew link php70</span><br><span class=\"line\">//输入命令，查看是否成功</span><br><span class=\"line\">php -v</span><br><span class=\"line\">//成功后显示下面信息</span><br><span class=\"line\">PHP 7.0.8 (cli) (built: Jul 13 2016 15:19:21) ( NTS )</span><br><span class=\"line\">Copyright (c) 1997-2016 The PHP Group</span><br><span class=\"line\">Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies</span><br></pre></td></tr></table></figure>\n<p>注：遇未生成libphp7.so</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install php70 --with-apxs2  --with-apache --with-gmp --with-imap --with-tidy --with-debug</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-配置Apache\"><a href=\"#3-配置Apache\" class=\"headerlink\" title=\"3.配置Apache\"></a>3.配置Apache</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim /etc/apache2/httpd.conf</span><br><span class=\"line\">找到这行注释掉(大概在168行）</span><br><span class=\"line\">Comment out the PHP5 module   </span><br><span class=\"line\">LoadModule php5_module libexec/apache2/libphp5.so</span><br><span class=\"line\"></span><br><span class=\"line\">Enable PHP 7 module  </span><br><span class=\"line\">LoadModule php7_module /usr/<span class=\"built_in\">local</span>/opt/php70/libexec/apache2/libphp7.so  &lt;FilesMatch \\.php$&gt;</span><br><span class=\"line\">SetHandler application/x-httpd-php</span><br><span class=\"line\">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-重启Apache\"><a href=\"#4-重启Apache\" class=\"headerlink\" title=\"4.重启Apache\"></a>4.重启Apache</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apachectl restart</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-到你的Apache的默认目录-Library-WebServer-Documents下面去增加一个info-php的文件\"><a href=\"#5-到你的Apache的默认目录-Library-WebServer-Documents下面去增加一个info-php的文件\" class=\"headerlink\" title=\"5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件\"></a>5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php    </span><br><span class=\"line\">phpinfo();    </span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>最后到你的 <a href=\"http://localhost/info.php\" target=\"_blank\" rel=\"noopener\">http://localhost/info.php</a> 去看看测试以下，如果看到相关的信息，就说明已经安装好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>安装教程：</p>\n<h2 id=\"1-首先我们需要安装Homebrew\"><a href=\"#1-首先我们需要安装Homebrew\" class=\"headerlink\" title=\"1.首先我们需要安装Homebrew\"></a>1.首先我们需要安装Homebrew</h2><p>一条命令完美安装：<a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">http://brew.sh/index_zh-cn.html</a></p>\n<h2 id=\"2-终端输入以下命令\"><a href=\"#2-终端输入以下命令\" class=\"headerlink\" title=\"2.终端输入以下命令\"></a>2.终端输入以下命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建目录,如果你没有创建过该目录</span><br><span class=\"line\">sudo mkdir /usr/<span class=\"built_in\">local</span>/var</span><br><span class=\"line\">sudo chmod 777 /usr/<span class=\"built_in\">local</span>/var</span><br><span class=\"line\">//修改成你自己的用户名和组,如果你没有创建过该目录</span><br><span class=\"line\">sudo mkdir /usr/<span class=\"built_in\">local</span>/sbin/</span><br><span class=\"line\">sudo chown -R &lt;username&gt;:&lt;group&gt; /usr/<span class=\"built_in\">local</span>/sbin//由于我本身一直在使用5.6版本，故上述步骤省略，下面进入正题</span><br><span class=\"line\">//添加PHP库</span><br><span class=\"line\">brew tap homebrew/dupes</span><br><span class=\"line\">brew tap homebrew/versions</span><br><span class=\"line\">brew tap homebrew/homebrew-php</span><br><span class=\"line\">//关闭老版本的PHP56或55或更早版本 进程</span><br><span class=\"line\">brew unlink php56</span><br><span class=\"line\">//开始安装PHP7</span><br><span class=\"line\">brew install php70</span><br><span class=\"line\">//开启PHP70进程</span><br><span class=\"line\">brew link php70</span><br><span class=\"line\">//输入命令，查看是否成功</span><br><span class=\"line\">php -v</span><br><span class=\"line\">//成功后显示下面信息</span><br><span class=\"line\">PHP 7.0.8 (cli) (built: Jul 13 2016 15:19:21) ( NTS )</span><br><span class=\"line\">Copyright (c) 1997-2016 The PHP Group</span><br><span class=\"line\">Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies</span><br></pre></td></tr></table></figure>\n<p>注：遇未生成libphp7.so</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install php70 --with-apxs2  --with-apache --with-gmp --with-imap --with-tidy --with-debug</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-配置Apache\"><a href=\"#3-配置Apache\" class=\"headerlink\" title=\"3.配置Apache\"></a>3.配置Apache</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vim /etc/apache2/httpd.conf</span><br><span class=\"line\">找到这行注释掉(大概在168行）</span><br><span class=\"line\">Comment out the PHP5 module   </span><br><span class=\"line\">LoadModule php5_module libexec/apache2/libphp5.so</span><br><span class=\"line\"></span><br><span class=\"line\">Enable PHP 7 module  </span><br><span class=\"line\">LoadModule php7_module /usr/<span class=\"built_in\">local</span>/opt/php70/libexec/apache2/libphp7.so  &lt;FilesMatch \\.php$&gt;</span><br><span class=\"line\">SetHandler application/x-httpd-php</span><br><span class=\"line\">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-重启Apache\"><a href=\"#4-重启Apache\" class=\"headerlink\" title=\"4.重启Apache\"></a>4.重启Apache</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apachectl restart</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-到你的Apache的默认目录-Library-WebServer-Documents下面去增加一个info-php的文件\"><a href=\"#5-到你的Apache的默认目录-Library-WebServer-Documents下面去增加一个info-php的文件\" class=\"headerlink\" title=\"5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件\"></a>5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php    </span><br><span class=\"line\">phpinfo();    </span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n<p>最后到你的 <a href=\"http://localhost/info.php\" target=\"_blank\" rel=\"noopener\">http://localhost/info.php</a> 去看看测试以下，如果看到相关的信息，就说明已经安装好了。</p>\n"},{"title":"React总结","data":"2017-12-07T02:05:01.000Z","_content":"\n## 做React需要会什么？\nreact的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试。。。。\n\n\n## React 是什么\n用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。\n\n\n## React的组件化\n\nreact的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。\n\n\n## React的 Diff算法\nreact的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。\n\n对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。\n\n![][image-1]\n\n## React组件是怎么来的\n\n组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。\n\n![][image-2]\n\n这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。\n\n当我们使用组件\\< Main /\\>时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。\n\n有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。\n\n\n\n\n## 组件的生命周期\n\n![][image-3]\n\n**组件在初始化时会触发5个钩子函数：**\n\n  **1、getDefaultProps()**\n> 设置默认的props，也可以用dufaultProps设置组件的默认属性。\n\n\n  **2、getInitialState()**  \n> 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。\n\n\n **3、componentWillMount()**\n> 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。\n\n\n **4、 render()**\n>  react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。\n\n\n **5、componentDidMount()**\n> 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。\n\n\n**在更新时也会触发5个钩子函数：**\n\n  **6、componentWillReceivePorps(nextProps)**\n> 组件初始化时不调用，组件接受新的props时调用。\n\n\n  **7、shouldComponentUpdate(nextProps, nextState)**\n> react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。\n\n\n  **8、componentWillUpdate(nextProps, nextState)**\n> 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state\n\n\n  **9、render()**\n> 不多说\n\n\n  **10、componentDidUpdate()**\n> 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。\n\n\n还有一个卸载钩子函数\n\n  **11、componentWillUnmount()**\n> 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。\n\n\n以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。\n\n\n## React-Router路由\n\nRouter就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。\n\n当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。\n\n```javascript\n`const chooseProducts = (location, cb) =\\> {\nrequire.ensure([](), require =\\> {\ncb(null, require('../Component/chooseProducts').default)\n},'chooseProducts')\n}\n\nconst helpCenter = (location, cb) =\\> {\nrequire.ensure([](), require =\\> {\ncb(null, require('../Component/helpCenter').default)\n},'helpCenter')\n}\n\nconst saleRecord = (location, cb) =\\> {\nrequire.ensure([](), require =\\> {\ncb(null, require('../Component/saleRecord').default)\n},'saleRecord')\n}\n\nconst RouteConfig = (\n\\<Router history={history}\\>\n\\<Route path=\"/\" component={Roots}\\>\n\\<IndexRoute component={index} /\\>//首页\n\\<Route path=\"index\" component={index} /\\>\n\\<Route path=\"helpCenter\" getComponent={helpCenter} /\\>//帮助中心\n\\<Route path=\"saleRecord\" getComponent={saleRecord} /\\>//销售记录\n\\<Redirect from='*' to='/'  /\\>\n\\</Route\\>\n\\</Router\\>\n);\n\n```\n`## 组件之间的通信\n\n\nreact推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。\n\n组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。\n\n兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。\n\n组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。\n\n## Redux\n\n\n首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。\n\n先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。\n\n\n\n\n#### 流程是这个样子的：\n\n![][image-4]\n\n值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。\n\n\n#### 接下来具体分析一下，redux以及react-redux到底是怎么实现的。\n\n\n#### 先上一张图\n\n![][image-5]\n\n明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析：\n\n### 先说说redux：\n\n#### redux主要由三部分组成：store，reducer，action。\n\n\n**store**是一个对象，它有四个主要的方法：\n\n**1、dispatch:**\n>  用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。\n\n**2、subscribe：**\n> 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。\nlet unsubscribe = store.subscribe(() =\\> {console.log('state发生了变化')})\n\n**3、getState：**\n> 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。\n\n**4、replaceReducer:**\n> 替换reducer，改变state修改的逻辑。\n\nstore可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。\n\n\n**action:**\n> action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。\n\n**reducer:**\n> reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。\n\n像这个样子：\n```javascript\n`const reducer = combineReducers({\n a: doSomethingWithA,\n b: processB,\n c: c\n})\n```\n`**combineReducers:**\n> 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。\n\n接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。\n\nredux的state和react的state两者完全没有关系，除了名字一样。\n\n**上面分析了redux的主要功能，那么react-redux到底做了什么？**\n\n\n## React-Redux\n\n如果只使用redux，那么流程是这样的：\n> component --\\> dispatch(action) --\\> reducer --\\> subscribe --\\> getState --\\> component\n\n用了react-redux之后流程是这样的：\n> component --\\> actionCreator(data) --\\> reducer --\\> component\n\nstore的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。\n\n**Provider**是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。\n\n__connect --connect(mapStateToProps, mapDispatchToProps, mergeProps, options)__ 是一个函数，它接受四个参数并且再返回一个函数--wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。\n\n所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component)\n\n**mapStateToProps(state, [ownProps]())：**\n> mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps\n\n```javascript\n`function mapStateToProps(state) {\n   return { todos: state.todos };\n}\n```\n`\n**mapDispatchToProps(dispatch, [ownProps]())：**\n\n> mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的\n\n```javascript\n`function mapDispatchToProps(dispatch) {\n   return {\n  todoActions: bindActionCreators(todoActionCreators, dispatch),\n  counterActions: bindActionCreators(counterActionCreators, dispatch)\n   };\n}\n```\n`\nmapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。\n\n**mergeProps(stateProps, dispatchProps, ownProps)：**\n> 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。\n\n**options：**\n> pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。\n\n其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。\n\n### 下面是一个完整的 react --\\> redux --\\> react 流程：\n\n\n一、Provider组件接受redux的store作为props，然后通过context往下传。\n\n二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。\n\n三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react --\\> redux --\\> react 的一次流程结束。\n\n\n**上面的有点复杂，简化版的流程是：**\n\n一、Provider组件接受redux的store作为props，然后通过context往下传。\n\n二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。\n\nconnect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。\n\n简化版本：\n```javascript\n`connect(state =\\> state, action)(Component);\n```\n`\n## 项目搭建\n\n上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。\n\n1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。\n\n2、从 react.js，redux，react-router 中引入所需要的对象和方法。\n```javascript\n`import React, {Component, PropTypes} from 'react';\nimport ReactDOM, {render} from 'react-dom';\nimport {Provider, connect} from 'react-redux';\nimport {createStore, combineReducers, applyMiddleware} from 'redux';\nimport { Router, Route, Redirect, IndexRoute, browserHistory, hashHistory } from 'react-router';\n```\n`3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。\n\n4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。\n\n5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。\n\n6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。\n\n7、将Router放入最顶层组件Provider，引入store作为Provider的属性。\n\n8、调用render渲染Provider组件且放入页面的标签中。\n\n可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。\n\n通常我们在顶层的ui组件打印props时可以看到一堆属性：\n\n![][image-6]\n\n上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方：\n\n组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。\n\n\n\n[image-1]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/diff.png\n[image-2]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/icon_class.png\n[image-3]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/react-lifecycle.png\n[image-4]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/simple_redux.jpg\n[image-5]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/all_redux.png\n[image-6]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/react_props.png","source":"_posts/React总结.md","raw":"---\ntitle: React总结\ndata:  2017-12-7 10:05:01\ntag:\n- React\ncategories: 前端\n---\n\n## 做React需要会什么？\nreact的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试。。。。\n\n\n## React 是什么\n用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。\n\n\n## React的组件化\n\nreact的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。\n\n\n## React的 Diff算法\nreact的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。\n\n对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。\n\n![][image-1]\n\n## React组件是怎么来的\n\n组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。\n\n![][image-2]\n\n这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。\n\n当我们使用组件\\< Main /\\>时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。\n\n有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。\n\n\n\n\n## 组件的生命周期\n\n![][image-3]\n\n**组件在初始化时会触发5个钩子函数：**\n\n  **1、getDefaultProps()**\n> 设置默认的props，也可以用dufaultProps设置组件的默认属性。\n\n\n  **2、getInitialState()**  \n> 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。\n\n\n **3、componentWillMount()**\n> 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。\n\n\n **4、 render()**\n>  react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。\n\n\n **5、componentDidMount()**\n> 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。\n\n\n**在更新时也会触发5个钩子函数：**\n\n  **6、componentWillReceivePorps(nextProps)**\n> 组件初始化时不调用，组件接受新的props时调用。\n\n\n  **7、shouldComponentUpdate(nextProps, nextState)**\n> react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。\n\n\n  **8、componentWillUpdate(nextProps, nextState)**\n> 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state\n\n\n  **9、render()**\n> 不多说\n\n\n  **10、componentDidUpdate()**\n> 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。\n\n\n还有一个卸载钩子函数\n\n  **11、componentWillUnmount()**\n> 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。\n\n\n以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。\n\n\n## React-Router路由\n\nRouter就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。\n\n当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。\n\n```javascript\n`const chooseProducts = (location, cb) =\\> {\nrequire.ensure([](), require =\\> {\ncb(null, require('../Component/chooseProducts').default)\n},'chooseProducts')\n}\n\nconst helpCenter = (location, cb) =\\> {\nrequire.ensure([](), require =\\> {\ncb(null, require('../Component/helpCenter').default)\n},'helpCenter')\n}\n\nconst saleRecord = (location, cb) =\\> {\nrequire.ensure([](), require =\\> {\ncb(null, require('../Component/saleRecord').default)\n},'saleRecord')\n}\n\nconst RouteConfig = (\n\\<Router history={history}\\>\n\\<Route path=\"/\" component={Roots}\\>\n\\<IndexRoute component={index} /\\>//首页\n\\<Route path=\"index\" component={index} /\\>\n\\<Route path=\"helpCenter\" getComponent={helpCenter} /\\>//帮助中心\n\\<Route path=\"saleRecord\" getComponent={saleRecord} /\\>//销售记录\n\\<Redirect from='*' to='/'  /\\>\n\\</Route\\>\n\\</Router\\>\n);\n\n```\n`## 组件之间的通信\n\n\nreact推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。\n\n组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。\n\n兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。\n\n组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。\n\n## Redux\n\n\n首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。\n\n先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。\n\n\n\n\n#### 流程是这个样子的：\n\n![][image-4]\n\n值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。\n\n\n#### 接下来具体分析一下，redux以及react-redux到底是怎么实现的。\n\n\n#### 先上一张图\n\n![][image-5]\n\n明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析：\n\n### 先说说redux：\n\n#### redux主要由三部分组成：store，reducer，action。\n\n\n**store**是一个对象，它有四个主要的方法：\n\n**1、dispatch:**\n>  用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。\n\n**2、subscribe：**\n> 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。\nlet unsubscribe = store.subscribe(() =\\> {console.log('state发生了变化')})\n\n**3、getState：**\n> 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。\n\n**4、replaceReducer:**\n> 替换reducer，改变state修改的逻辑。\n\nstore可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。\n\n\n**action:**\n> action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。\n\n**reducer:**\n> reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。\n\n像这个样子：\n```javascript\n`const reducer = combineReducers({\n a: doSomethingWithA,\n b: processB,\n c: c\n})\n```\n`**combineReducers:**\n> 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。\n\n接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。\n\nredux的state和react的state两者完全没有关系，除了名字一样。\n\n**上面分析了redux的主要功能，那么react-redux到底做了什么？**\n\n\n## React-Redux\n\n如果只使用redux，那么流程是这样的：\n> component --\\> dispatch(action) --\\> reducer --\\> subscribe --\\> getState --\\> component\n\n用了react-redux之后流程是这样的：\n> component --\\> actionCreator(data) --\\> reducer --\\> component\n\nstore的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。\n\n**Provider**是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。\n\n__connect --connect(mapStateToProps, mapDispatchToProps, mergeProps, options)__ 是一个函数，它接受四个参数并且再返回一个函数--wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。\n\n所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component)\n\n**mapStateToProps(state, [ownProps]())：**\n> mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps\n\n```javascript\n`function mapStateToProps(state) {\n   return { todos: state.todos };\n}\n```\n`\n**mapDispatchToProps(dispatch, [ownProps]())：**\n\n> mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的\n\n```javascript\n`function mapDispatchToProps(dispatch) {\n   return {\n  todoActions: bindActionCreators(todoActionCreators, dispatch),\n  counterActions: bindActionCreators(counterActionCreators, dispatch)\n   };\n}\n```\n`\nmapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。\n\n**mergeProps(stateProps, dispatchProps, ownProps)：**\n> 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。\n\n**options：**\n> pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。\n\n其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。\n\n### 下面是一个完整的 react --\\> redux --\\> react 流程：\n\n\n一、Provider组件接受redux的store作为props，然后通过context往下传。\n\n二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。\n\n三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react --\\> redux --\\> react 的一次流程结束。\n\n\n**上面的有点复杂，简化版的流程是：**\n\n一、Provider组件接受redux的store作为props，然后通过context往下传。\n\n二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。\n\nconnect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。\n\n简化版本：\n```javascript\n`connect(state =\\> state, action)(Component);\n```\n`\n## 项目搭建\n\n上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。\n\n1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。\n\n2、从 react.js，redux，react-router 中引入所需要的对象和方法。\n```javascript\n`import React, {Component, PropTypes} from 'react';\nimport ReactDOM, {render} from 'react-dom';\nimport {Provider, connect} from 'react-redux';\nimport {createStore, combineReducers, applyMiddleware} from 'redux';\nimport { Router, Route, Redirect, IndexRoute, browserHistory, hashHistory } from 'react-router';\n```\n`3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。\n\n4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。\n\n5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。\n\n6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。\n\n7、将Router放入最顶层组件Provider，引入store作为Provider的属性。\n\n8、调用render渲染Provider组件且放入页面的标签中。\n\n可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。\n\n通常我们在顶层的ui组件打印props时可以看到一堆属性：\n\n![][image-6]\n\n上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方：\n\n组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。\n\n\n\n[image-1]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/diff.png\n[image-2]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/icon_class.png\n[image-3]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/react-lifecycle.png\n[image-4]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/simple_redux.jpg\n[image-5]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/all_redux.png\n[image-6]:\thttps://github.com/bailicangdu/pxq/blob/master/src/images/react_props.png","slug":"React总结","published":1,"date":"2017-12-07T08:53:30.000Z","updated":"2017-12-07T09:08:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjxh0009xqs66haioy6p","content":"<h2 id=\"做React需要会什么？\"><a href=\"#做React需要会什么？\" class=\"headerlink\" title=\"做React需要会什么？\"></a>做React需要会什么？</h2><p>react的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试。。。。</p>\n<h2 id=\"React-是什么\"><a href=\"#React-是什么\" class=\"headerlink\" title=\"React 是什么\"></a>React 是什么</h2><p>用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。</p>\n<h2 id=\"React的组件化\"><a href=\"#React的组件化\" class=\"headerlink\" title=\"React的组件化\"></a>React的组件化</h2><p>react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。</p>\n<h2 id=\"React的-Diff算法\"><a href=\"#React的-Diff算法\" class=\"headerlink\" title=\"React的 Diff算法\"></a>React的 Diff算法</h2><p>react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。</p>\n<p>对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。</p>\n<p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/diff.png\" alt=\"\"></p>\n<h2 id=\"React组件是怎么来的\"><a href=\"#React组件是怎么来的\" class=\"headerlink\" title=\"React组件是怎么来的\"></a>React组件是怎么来的</h2><p>组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。</p>\n<p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/icon_class.png\" alt=\"\"></p>\n<p>这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。</p>\n<p>当我们使用组件\\&lt; Main />时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。</p>\n<p>有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。</p>\n<h2 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h2><p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/react-lifecycle.png\" alt=\"\"></p>\n<p><strong>组件在初始化时会触发5个钩子函数：</strong></p>\n<p>  <strong>1、getDefaultProps()</strong></p>\n<blockquote>\n<p>设置默认的props，也可以用dufaultProps设置组件的默认属性。</p>\n</blockquote>\n<p>  <strong>2、getInitialState()</strong>  </p>\n<blockquote>\n<p>在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。</p>\n</blockquote>\n<p> <strong>3、componentWillMount()</strong></p>\n<blockquote>\n<p>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</p>\n</blockquote>\n<p> <strong>4、 render()</strong></p>\n<blockquote>\n<p> react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</p>\n</blockquote>\n<p> <strong>5、componentDidMount()</strong></p>\n<blockquote>\n<p>组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。</p>\n</blockquote>\n<p><strong>在更新时也会触发5个钩子函数：</strong></p>\n<p>  <strong>6、componentWillReceivePorps(nextProps)</strong></p>\n<blockquote>\n<p>组件初始化时不调用，组件接受新的props时调用。</p>\n</blockquote>\n<p>  <strong>7、shouldComponentUpdate(nextProps, nextState)</strong></p>\n<blockquote>\n<p>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。</p>\n</blockquote>\n<p>  <strong>8、componentWillUpdate(nextProps, nextState)</strong></p>\n<blockquote>\n<p>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state</p>\n</blockquote>\n<p>  <strong>9、render()</strong></p>\n<blockquote>\n<p>不多说</p>\n</blockquote>\n<p>  <strong>10、componentDidUpdate()</strong></p>\n<blockquote>\n<p>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p>\n</blockquote>\n<p>还有一个卸载钩子函数</p>\n<p>  <strong>11、componentWillUnmount()</strong></p>\n<blockquote>\n<p>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</p>\n</blockquote>\n<p>以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。</p>\n<h2 id=\"React-Router路由\"><a href=\"#React-Router路由\" class=\"headerlink\" title=\"React-Router路由\"></a>React-Router路由</h2><p>Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。</p>\n<p>当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`const chooseProducts = (location, cb) =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">require.ensure([](), require =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">cb(null, require('../Component/chooseProducts').default)</span></span><br><span class=\"line\"><span class=\"string\">&#125;,'chooseProducts')</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">const helpCenter = (location, cb) =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">require.ensure([](), require =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">cb(null, require('../Component/helpCenter').default)</span></span><br><span class=\"line\"><span class=\"string\">&#125;,'helpCenter')</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">const saleRecord = (location, cb) =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">require.ensure([](), require =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">cb(null, require('../Component/saleRecord').default)</span></span><br><span class=\"line\"><span class=\"string\">&#125;,'saleRecord')</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">const RouteConfig = (</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Router history=&#123;history&#125;\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"/\" component=&#123;Roots&#125;\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;IndexRoute component=&#123;index&#125; /\\&gt;//首页</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"index\" component=&#123;index&#125; /\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"helpCenter\" getComponent=&#123;helpCenter&#125; /\\&gt;//帮助中心</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"saleRecord\" getComponent=&#123;saleRecord&#125; /\\&gt;//销售记录</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Redirect from='*' to='/'  /\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;/Route\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;/Router\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">);</span></span><br></pre></td></tr></table></figure>\n<p>`## 组件之间的通信</p>\n<p>react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。</p>\n<p>组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。</p>\n<p>兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。</p>\n<p>组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。</p>\n<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p>首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。</p>\n<p>先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。</p>\n<h4 id=\"流程是这个样子的：\"><a href=\"#流程是这个样子的：\" class=\"headerlink\" title=\"流程是这个样子的：\"></a>流程是这个样子的：</h4><p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/simple_redux.jpg\" alt=\"\"></p>\n<p>值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。</p>\n<h4 id=\"接下来具体分析一下，redux以及react-redux到底是怎么实现的。\"><a href=\"#接下来具体分析一下，redux以及react-redux到底是怎么实现的。\" class=\"headerlink\" title=\"接下来具体分析一下，redux以及react-redux到底是怎么实现的。\"></a>接下来具体分析一下，redux以及react-redux到底是怎么实现的。</h4><h4 id=\"先上一张图\"><a href=\"#先上一张图\" class=\"headerlink\" title=\"先上一张图\"></a>先上一张图</h4><p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/all_redux.png\" alt=\"\"></p>\n<p>明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析：</p>\n<h3 id=\"先说说redux：\"><a href=\"#先说说redux：\" class=\"headerlink\" title=\"先说说redux：\"></a>先说说redux：</h3><h4 id=\"redux主要由三部分组成：store，reducer，action。\"><a href=\"#redux主要由三部分组成：store，reducer，action。\" class=\"headerlink\" title=\"redux主要由三部分组成：store，reducer，action。\"></a>redux主要由三部分组成：store，reducer，action。</h4><p><strong>store</strong>是一个对象，它有四个主要的方法：</p>\n<p><strong>1、dispatch:</strong></p>\n<blockquote>\n<p> 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</p>\n</blockquote>\n<p><strong>2、subscribe：</strong></p>\n<blockquote>\n<p>监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。<br>let unsubscribe = store.subscribe(() => {console.log(‘state发生了变化’)})</p>\n</blockquote>\n<p><strong>3、getState：</strong></p>\n<blockquote>\n<p>获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</p>\n</blockquote>\n<p><strong>4、replaceReducer:</strong></p>\n<blockquote>\n<p>替换reducer，改变state修改的逻辑。</p>\n</blockquote>\n<p>store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。</p>\n<p><strong>action:</strong></p>\n<blockquote>\n<p>action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。</p>\n</blockquote>\n<p><strong>reducer:</strong></p>\n<blockquote>\n<p>reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。</p>\n</blockquote>\n<p>像这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`const reducer = combineReducers(&#123;</span></span><br><span class=\"line\"><span class=\"string\"> a: doSomethingWithA,</span></span><br><span class=\"line\"><span class=\"string\"> b: processB,</span></span><br><span class=\"line\"><span class=\"string\"> c: c</span></span><br><span class=\"line\"><span class=\"string\">&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p>`<strong>combineReducers:</strong></p>\n<blockquote>\n<p>其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。</p>\n</blockquote>\n<p>接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。</p>\n<p>redux的state和react的state两者完全没有关系，除了名字一样。</p>\n<p><strong>上面分析了redux的主要功能，那么react-redux到底做了什么？</strong></p>\n<h2 id=\"React-Redux\"><a href=\"#React-Redux\" class=\"headerlink\" title=\"React-Redux\"></a>React-Redux</h2><p>如果只使用redux，那么流程是这样的：</p>\n<blockquote>\n<p>component –> dispatch(action) –> reducer –> subscribe –> getState –> component</p>\n</blockquote>\n<p>用了react-redux之后流程是这样的：</p>\n<blockquote>\n<p>component –> actionCreator(data) –> reducer –> component</p>\n</blockquote>\n<p>store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。</p>\n<p><strong>Provider</strong>是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。</p>\n<p><strong>connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options)</strong> 是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。</p>\n<p>所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component)</p>\n<p><strong>mapStateToProps(state, <a href=\"\">ownProps</a>)：</strong></p>\n<blockquote>\n<p>mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`function mapStateToProps(state) &#123;</span></span><br><span class=\"line\"><span class=\"string\">   return &#123; todos: state.todos &#125;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>`<br><strong>mapDispatchToProps(dispatch, <a href=\"\">ownProps</a>)：</strong></p>\n<blockquote>\n<p>mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`function mapDispatchToProps(dispatch) &#123;</span></span><br><span class=\"line\"><span class=\"string\">   return &#123;</span></span><br><span class=\"line\"><span class=\"string\">  todoActions: bindActionCreators(todoActionCreators, dispatch),</span></span><br><span class=\"line\"><span class=\"string\">  counterActions: bindActionCreators(counterActionCreators, dispatch)</span></span><br><span class=\"line\"><span class=\"string\">   &#125;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>`<br>mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。</p>\n<p><strong>mergeProps(stateProps, dispatchProps, ownProps)：</strong></p>\n<blockquote>\n<p>将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。</p>\n</blockquote>\n<p><strong>options：</strong></p>\n<blockquote>\n<p>pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。</p>\n</blockquote>\n<p>其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。</p>\n<h3 id=\"下面是一个完整的-react-–-redux-–-react-流程：\"><a href=\"#下面是一个完整的-react-–-redux-–-react-流程：\" class=\"headerlink\" title=\"下面是一个完整的 react –> redux –> react 流程：\"></a>下面是一个完整的 react –> redux –> react 流程：</h3><p>一、Provider组件接受redux的store作为props，然后通过context往下传。</p>\n<p>二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。</p>\n<p>三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –> redux –> react 的一次流程结束。</p>\n<p><strong>上面的有点复杂，简化版的流程是：</strong></p>\n<p>一、Provider组件接受redux的store作为props，然后通过context往下传。</p>\n<p>二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。</p>\n<p>connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。</p>\n<p>简化版本：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`connect(state =\\&gt; state, action)(Component);</span></span><br></pre></td></tr></table></figure></p>\n<p>`</p>\n<h2 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h2><p>上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。</p>\n<p>1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。</p>\n<p>2、从 react.js，redux，react-router 中引入所需要的对象和方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`import React, &#123;Component, PropTypes&#125; from 'react';</span></span><br><span class=\"line\"><span class=\"string\">import ReactDOM, &#123;render&#125; from 'react-dom';</span></span><br><span class=\"line\"><span class=\"string\">import &#123;Provider, connect&#125; from 'react-redux';</span></span><br><span class=\"line\"><span class=\"string\">import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';</span></span><br><span class=\"line\"><span class=\"string\">import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router';</span></span><br></pre></td></tr></table></figure></p>\n<p>`3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。</p>\n<p>4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。</p>\n<p>5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。</p>\n<p>6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。</p>\n<p>7、将Router放入最顶层组件Provider，引入store作为Provider的属性。</p>\n<p>8、调用render渲染Provider组件且放入页面的标签中。</p>\n<p>可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。</p>\n<p>通常我们在顶层的ui组件打印props时可以看到一堆属性：</p>\n<p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/react_props.png\" alt=\"\"></p>\n<p>上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方：</p>\n<p>组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"做React需要会什么？\"><a href=\"#做React需要会什么？\" class=\"headerlink\" title=\"做React需要会什么？\"></a>做React需要会什么？</h2><p>react的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试。。。。</p>\n<h2 id=\"React-是什么\"><a href=\"#React-是什么\" class=\"headerlink\" title=\"React 是什么\"></a>React 是什么</h2><p>用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。</p>\n<h2 id=\"React的组件化\"><a href=\"#React的组件化\" class=\"headerlink\" title=\"React的组件化\"></a>React的组件化</h2><p>react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。</p>\n<h2 id=\"React的-Diff算法\"><a href=\"#React的-Diff算法\" class=\"headerlink\" title=\"React的 Diff算法\"></a>React的 Diff算法</h2><p>react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。</p>\n<p>对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。</p>\n<p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/diff.png\" alt=\"\"></p>\n<h2 id=\"React组件是怎么来的\"><a href=\"#React组件是怎么来的\" class=\"headerlink\" title=\"React组件是怎么来的\"></a>React组件是怎么来的</h2><p>组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。</p>\n<p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/icon_class.png\" alt=\"\"></p>\n<p>这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。</p>\n<p>当我们使用组件\\&lt; Main />时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。</p>\n<p>有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。</p>\n<h2 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h2><p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/react-lifecycle.png\" alt=\"\"></p>\n<p><strong>组件在初始化时会触发5个钩子函数：</strong></p>\n<p>  <strong>1、getDefaultProps()</strong></p>\n<blockquote>\n<p>设置默认的props，也可以用dufaultProps设置组件的默认属性。</p>\n</blockquote>\n<p>  <strong>2、getInitialState()</strong>  </p>\n<blockquote>\n<p>在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。</p>\n</blockquote>\n<p> <strong>3、componentWillMount()</strong></p>\n<blockquote>\n<p>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</p>\n</blockquote>\n<p> <strong>4、 render()</strong></p>\n<blockquote>\n<p> react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</p>\n</blockquote>\n<p> <strong>5、componentDidMount()</strong></p>\n<blockquote>\n<p>组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。</p>\n</blockquote>\n<p><strong>在更新时也会触发5个钩子函数：</strong></p>\n<p>  <strong>6、componentWillReceivePorps(nextProps)</strong></p>\n<blockquote>\n<p>组件初始化时不调用，组件接受新的props时调用。</p>\n</blockquote>\n<p>  <strong>7、shouldComponentUpdate(nextProps, nextState)</strong></p>\n<blockquote>\n<p>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。</p>\n</blockquote>\n<p>  <strong>8、componentWillUpdate(nextProps, nextState)</strong></p>\n<blockquote>\n<p>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state</p>\n</blockquote>\n<p>  <strong>9、render()</strong></p>\n<blockquote>\n<p>不多说</p>\n</blockquote>\n<p>  <strong>10、componentDidUpdate()</strong></p>\n<blockquote>\n<p>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p>\n</blockquote>\n<p>还有一个卸载钩子函数</p>\n<p>  <strong>11、componentWillUnmount()</strong></p>\n<blockquote>\n<p>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</p>\n</blockquote>\n<p>以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。</p>\n<h2 id=\"React-Router路由\"><a href=\"#React-Router路由\" class=\"headerlink\" title=\"React-Router路由\"></a>React-Router路由</h2><p>Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。</p>\n<p>当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`const chooseProducts = (location, cb) =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">require.ensure([](), require =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">cb(null, require('../Component/chooseProducts').default)</span></span><br><span class=\"line\"><span class=\"string\">&#125;,'chooseProducts')</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">const helpCenter = (location, cb) =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">require.ensure([](), require =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">cb(null, require('../Component/helpCenter').default)</span></span><br><span class=\"line\"><span class=\"string\">&#125;,'helpCenter')</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">const saleRecord = (location, cb) =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">require.ensure([](), require =\\&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">cb(null, require('../Component/saleRecord').default)</span></span><br><span class=\"line\"><span class=\"string\">&#125;,'saleRecord')</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">const RouteConfig = (</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Router history=&#123;history&#125;\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"/\" component=&#123;Roots&#125;\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;IndexRoute component=&#123;index&#125; /\\&gt;//首页</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"index\" component=&#123;index&#125; /\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"helpCenter\" getComponent=&#123;helpCenter&#125; /\\&gt;//帮助中心</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Route path=\"saleRecord\" getComponent=&#123;saleRecord&#125; /\\&gt;//销售记录</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;Redirect from='*' to='/'  /\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;/Route\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">\\&lt;/Router\\&gt;</span></span><br><span class=\"line\"><span class=\"string\">);</span></span><br></pre></td></tr></table></figure>\n<p>`## 组件之间的通信</p>\n<p>react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。</p>\n<p>组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。</p>\n<p>兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。</p>\n<p>组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。</p>\n<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p>首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。</p>\n<p>先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。</p>\n<h4 id=\"流程是这个样子的：\"><a href=\"#流程是这个样子的：\" class=\"headerlink\" title=\"流程是这个样子的：\"></a>流程是这个样子的：</h4><p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/simple_redux.jpg\" alt=\"\"></p>\n<p>值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。</p>\n<h4 id=\"接下来具体分析一下，redux以及react-redux到底是怎么实现的。\"><a href=\"#接下来具体分析一下，redux以及react-redux到底是怎么实现的。\" class=\"headerlink\" title=\"接下来具体分析一下，redux以及react-redux到底是怎么实现的。\"></a>接下来具体分析一下，redux以及react-redux到底是怎么实现的。</h4><h4 id=\"先上一张图\"><a href=\"#先上一张图\" class=\"headerlink\" title=\"先上一张图\"></a>先上一张图</h4><p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/all_redux.png\" alt=\"\"></p>\n<p>明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析：</p>\n<h3 id=\"先说说redux：\"><a href=\"#先说说redux：\" class=\"headerlink\" title=\"先说说redux：\"></a>先说说redux：</h3><h4 id=\"redux主要由三部分组成：store，reducer，action。\"><a href=\"#redux主要由三部分组成：store，reducer，action。\" class=\"headerlink\" title=\"redux主要由三部分组成：store，reducer，action。\"></a>redux主要由三部分组成：store，reducer，action。</h4><p><strong>store</strong>是一个对象，它有四个主要的方法：</p>\n<p><strong>1、dispatch:</strong></p>\n<blockquote>\n<p> 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</p>\n</blockquote>\n<p><strong>2、subscribe：</strong></p>\n<blockquote>\n<p>监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。<br>let unsubscribe = store.subscribe(() => {console.log(‘state发生了变化’)})</p>\n</blockquote>\n<p><strong>3、getState：</strong></p>\n<blockquote>\n<p>获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</p>\n</blockquote>\n<p><strong>4、replaceReducer:</strong></p>\n<blockquote>\n<p>替换reducer，改变state修改的逻辑。</p>\n</blockquote>\n<p>store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。</p>\n<p><strong>action:</strong></p>\n<blockquote>\n<p>action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。</p>\n</blockquote>\n<p><strong>reducer:</strong></p>\n<blockquote>\n<p>reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。</p>\n</blockquote>\n<p>像这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`const reducer = combineReducers(&#123;</span></span><br><span class=\"line\"><span class=\"string\"> a: doSomethingWithA,</span></span><br><span class=\"line\"><span class=\"string\"> b: processB,</span></span><br><span class=\"line\"><span class=\"string\"> c: c</span></span><br><span class=\"line\"><span class=\"string\">&#125;)</span></span><br></pre></td></tr></table></figure></p>\n<p>`<strong>combineReducers:</strong></p>\n<blockquote>\n<p>其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。</p>\n</blockquote>\n<p>接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。</p>\n<p>redux的state和react的state两者完全没有关系，除了名字一样。</p>\n<p><strong>上面分析了redux的主要功能，那么react-redux到底做了什么？</strong></p>\n<h2 id=\"React-Redux\"><a href=\"#React-Redux\" class=\"headerlink\" title=\"React-Redux\"></a>React-Redux</h2><p>如果只使用redux，那么流程是这样的：</p>\n<blockquote>\n<p>component –> dispatch(action) –> reducer –> subscribe –> getState –> component</p>\n</blockquote>\n<p>用了react-redux之后流程是这样的：</p>\n<blockquote>\n<p>component –> actionCreator(data) –> reducer –> component</p>\n</blockquote>\n<p>store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。</p>\n<p><strong>Provider</strong>是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。</p>\n<p><strong>connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options)</strong> 是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。</p>\n<p>所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component)</p>\n<p><strong>mapStateToProps(state, <a href=\"\">ownProps</a>)：</strong></p>\n<blockquote>\n<p>mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`function mapStateToProps(state) &#123;</span></span><br><span class=\"line\"><span class=\"string\">   return &#123; todos: state.todos &#125;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>`<br><strong>mapDispatchToProps(dispatch, <a href=\"\">ownProps</a>)：</strong></p>\n<blockquote>\n<p>mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`function mapDispatchToProps(dispatch) &#123;</span></span><br><span class=\"line\"><span class=\"string\">   return &#123;</span></span><br><span class=\"line\"><span class=\"string\">  todoActions: bindActionCreators(todoActionCreators, dispatch),</span></span><br><span class=\"line\"><span class=\"string\">  counterActions: bindActionCreators(counterActionCreators, dispatch)</span></span><br><span class=\"line\"><span class=\"string\">   &#125;;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>`<br>mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。</p>\n<p><strong>mergeProps(stateProps, dispatchProps, ownProps)：</strong></p>\n<blockquote>\n<p>将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。</p>\n</blockquote>\n<p><strong>options：</strong></p>\n<blockquote>\n<p>pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。</p>\n</blockquote>\n<p>其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。</p>\n<h3 id=\"下面是一个完整的-react-–-redux-–-react-流程：\"><a href=\"#下面是一个完整的-react-–-redux-–-react-流程：\" class=\"headerlink\" title=\"下面是一个完整的 react –> redux –> react 流程：\"></a>下面是一个完整的 react –> redux –> react 流程：</h3><p>一、Provider组件接受redux的store作为props，然后通过context往下传。</p>\n<p>二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。</p>\n<p>三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –> redux –> react 的一次流程结束。</p>\n<p><strong>上面的有点复杂，简化版的流程是：</strong></p>\n<p>一、Provider组件接受redux的store作为props，然后通过context往下传。</p>\n<p>二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。</p>\n<p>connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。</p>\n<p>简化版本：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`connect(state =\\&gt; state, action)(Component);</span></span><br></pre></td></tr></table></figure></p>\n<p>`</p>\n<h2 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h2><p>上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。</p>\n<p>1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。</p>\n<p>2、从 react.js，redux，react-router 中引入所需要的对象和方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`import React, &#123;Component, PropTypes&#125; from 'react';</span></span><br><span class=\"line\"><span class=\"string\">import ReactDOM, &#123;render&#125; from 'react-dom';</span></span><br><span class=\"line\"><span class=\"string\">import &#123;Provider, connect&#125; from 'react-redux';</span></span><br><span class=\"line\"><span class=\"string\">import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';</span></span><br><span class=\"line\"><span class=\"string\">import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router';</span></span><br></pre></td></tr></table></figure></p>\n<p>`3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。</p>\n<p>4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。</p>\n<p>5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。</p>\n<p>6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。</p>\n<p>7、将Router放入最顶层组件Provider，引入store作为Provider的属性。</p>\n<p>8、调用render渲染Provider组件且放入页面的标签中。</p>\n<p>可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。</p>\n<p>通常我们在顶层的ui组件打印props时可以看到一堆属性：</p>\n<p><img src=\"https://github.com/bailicangdu/pxq/blob/master/src/images/react_props.png\" alt=\"\"></p>\n<p>上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方：</p>\n<p>组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。</p>\n"},{"title":"全文搜索引擎 Elasticsearch 入门教程","data":"2017-11-30T01:06:01.000Z","_content":"\n本文转载自：[阮一峰的网络日志][1]\n\n[全文搜索][2]属于最常见的需求，开源的[ Elasticsearch][3] （以下简称 Elastic）是目前全文搜索引擎的首选。\n它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。\n\nElastic 的底层是开源库[Lucene][4]。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。\n本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。\n# 一、安装\nElastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考[这篇文章][5]，注意要保证环境变量JAVA_HOME正确设置。\n安装完 Java，就可以跟着[官方文档][6]安装 Elastic。直接下载压缩包比较简单。\n\n```\n$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip\n$ unzip elasticsearch-5.5.1.zip\n$ cd elasticsearch-5.5.1/ \n```\n\n接着，进入解压后的目录，运行下面的命令，启动 Elastic。\n\n```bash\n$ ./bin/elasticsearch\n```\n\n如果这时报错\"max virtual memory areas vm.maxmapcount [65530]() is too low\"，要运行下面的命令。\n\n```\n$ sudo sysctl -w vm.max_map_count=262144\n```\n\n如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。\n\n```bash\n$ curl localhost:9200\n\n{\n  \"name\" : \"atntrTf\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"tf9250XhQ6ee4h7YI11anA\",\n  \"version\" : {\n\"number\" : \"5.5.1\",\n\"build_hash\" : \"19c13d0\",\n\"build_date\" : \"2017-07-18T20:44:24.823Z\",\n\"build_snapshot\" : false,\n\"lucene_version\" : \"6.6.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n\n上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。\n按下 Ctrl + C，Elastic 就会停止运行。\n默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动 Elastic。\nnetwork.host: 0.0.0.0\n上面代码中，设成0.0.0.0让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。\n# 二、基本概念\n## 2.1 Node 与 Cluster\nElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。\n单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。\n## 2.2 Index\nElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。\n所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。\n下面的命令可以查看当前节点的所有 Index。\n\n```bash\n$ curl -X GET 'http://localhost:9200/_cat/indices?v'\n```\n\n## 2.3 Document\nIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。\nDocument 使用 JSON 格式表示，下面是一个例子。\n\n```bash\n{\n  \"user\": \"张三\",\n  \"title\": \"工程师\",\n  \"desc\": \"数据库管理\"\n}\n```\n\n同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。\n## 2.4 Type\nDocument 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。\n不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。\n下面的命令可以列出每个 Index 所包含的 Type。\n\n```bash\n$ curl 'localhost:9200/_mapping?pretty=true'\n```\n\n根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。\n# 三、新建和删除 Index\n新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。\n\n```bash\n$ curl -X PUT 'localhost:9200/weather'\n\t```\n\n服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。\n\n```bash\n{\n \"acknowledged\":true,\n \"shards_acknowledged\":true\n}\n```\n\n然后，我们发出 DELETE 请求，删除这个 Index。\n$ curl -X DELETE 'localhost:9200/weather'\n# 四、中文分词设置\n首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。\n\n```bash\n$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip\n```\n\n上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。\n接着，重新启动 Elastic，就会自动加载这个新安装的插件。\n然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。\n\n```bash\n$ curl -X PUT 'localhost:9200/accounts' -d '\n{\n  \"mappings\": {\n\"person\": {\n  \"properties\": {\n\"user\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n},\n\"title\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n},\n\"desc\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n}\n  }\n}\n  }\n}'\n```\n\n上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。\nuser\ntitle\ndesc\n这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。\nElastic 的分词器称为 analyzer。我们对每个字段指定分词器。\n\n```bash\n\"user\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n}\n```\n\n上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。\n# 五、数据操作\n## 5.1 新增记录\n向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。\n\n```bash\n$ curl -X PUT 'localhost:9200/accounts/person/1' -d '\n{\n  \"user\": \"张三\",\n  \"title\": \"工程师\",\n  \"desc\": \"数据库管理\"\n}' \n```\n\n服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。\n\n```bash\n{\n  \"_index\":\"accounts\",\n  \"_type\":\"person\",\n  \"_id\":\"1\",\n  \"_version\":1,\n  \"result\":\"created\",\n  \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0},\n  \"created\":true\n}\n```\n\n如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。\n新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。\n\n```bash\n$ curl -X POST 'localhost:9200/accounts/person' -d '\n{\n  \"user\": \"李四\",\n  \"title\": \"工程师\",\n  \"desc\": \"系统管理\"\n}'\n```\n\n上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。\n\n```bash\n{\n  \"_index\":\"accounts\",\n  \"_type\":\"person\",\n  \"_id\":\"AV3qGfrC6jMbsbXb6k1p\",\n  \"_version\":1,\n  \"result\":\"created\",\n  \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0},\n  \"created\":true\n}\n```\n\n注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。\n## 5.2 查看记录\n向/Index/Type/Id发出 GET 请求，就可以查看这条记录。\n\n```bash\n$ curl 'localhost:9200/accounts/person/1?pretty=true'\n```\n\n上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。\n返回的数据中，found字段表示查询成功，_source字段返回原始记录。\n\n```bash\n{\n  \"_index\" : \"accounts\",\n  \"_type\" : \"person\",\n  \"_id\" : \"1\",\n  \"_version\" : 1,\n  \"found\" : true,\n  \"_source\" : {\n\"user\" : \"张三\",\n\"title\" : \"工程师\",\n\"desc\" : \"数据库管理\"\n  }\n}\n```\n\n如果 Id 不正确，就查不到数据，found字段就是false。\n\n```bash\n$ curl 'localhost:9200/weather/beijing/abc?pretty=true'\n\n{\n  \"_index\" : \"accounts\",\n  \"_type\" : \"person\",\n  \"_id\" : \"abc\",\n  \"found\" : false\n}\n```\n\n## 5.3 删除记录\n删除记录就是发出 DELETE 请求。\n\n```bash\n$ curl -X DELETE 'localhost:9200/accounts/person/1'\n\t```\n\n这里先不要删除这条记录，后面还要用到。\n## 5.4 更新记录\n更新记录就是使用 PUT 请求，重新发送一次数据。\n\n```bash\n$ curl -X PUT 'localhost:9200/accounts/person/1' -d '\n{\n\"user\" : \"张三\",\n\"title\" : \"工程师\",\n\"desc\" : \"数据库管理，软件开发\"\n}' \n\n{\n  \"_index\":\"accounts\",\n  \"_type\":\"person\",\n  \"_id\":\"1\",\n  \"_version\":2,\n  \"result\":\"updated\",\n  \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0},\n  \"created\":false\n}\n```\n\n上面代码中，我们将原始数据从\"数据库管理\"改成\"数据库管理，软件开发\"。 返回结果里面，有几个字段发生了变化。\n\n```bash\n\"_version\" : 2,\n\"result\" : \"updated\",\n\"created\" : false\n```\n\n可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。\n# 六、数据查询\n## 6.1 返回所有记录\n使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。_\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'\n\n{\n  \"took\":2,\n  \"timed_out\":false,\n  \"_shards\":{\"total\":5,\"successful\":5,\"failed\":0},\n  \"hits\":{\n\"total\":2,\n\"max_score\":1.0,\n\"hits\":[\n  {\n\"_index\":\"accounts\",\n\"_type\":\"person\",\n\"_id\":\"AV3qGfrC6jMbsbXb6k1p\",\n\"_score\":1.0,\n\"_source\": {\n  \"user\": \"李四\",\n  \"title\": \"工程师\",\n  \"desc\": \"系统管理\"\n}\n  },\n  {\n\"_index\":\"accounts\",\n\"_type\":\"person\",\n\"_id\":\"1\",\n\"_score\":1.0,\n\"_source\": {\n  \"user\" : \"张三\",\n  \"title\" : \"工程师\",\n  \"desc\" : \"数据库管理，软件开发\"\n}\n  }\n]\n  }\n}\n```\n\n上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。\ntotal：返回记录数，本例是2条。\nmax_score：最高的匹配程度，本例是1.0。\nhits：返回的记录组成的数组。\n返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。\n\n## 6.2 全文搜索\nElastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"软件\" }}\n}'\n```\n\n上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含\"软件\"这个词。返回结果如下。\n\n```bash\n{\n  \"took\":3,\n  \"timed_out\":false,\n  \"_shards\":{\"total\":5,\"successful\":5,\"failed\":0},\n  \"hits\":{\n\"total\":1,\n\"max_score\":0.28582606,\n\"hits\":[\n  {\n\"_index\":\"accounts\",\n\"_type\":\"person\",\n\"_id\":\"1\",\n\"_score\":0.28582606,\n\"_source\": {\n  \"user\" : \"张三\",\n  \"title\" : \"工程师\",\n  \"desc\" : \"数据库管理，软件开发\"\n}\n  }\n]\n  }\n}\n```\n\nElastic 默认一次返回10条结果，可以通过size字段改变这个设置。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"管理\" }},\n  \"size\": 1\n}'\n```\n\n上面代码指定，每次只返回一条结果。\n还可以通过from字段，指定位移。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"管理\" }},\n  \"from\": 1,\n  \"size\": 1\n}'\n```\n\n上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。\n## 6.3 逻辑运算\n如果有多个搜索关键字， Elastic 认为它们是or关系。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"软件 系统\" }}\n}'\n```\n\n上面代码搜索的是软件 or 系统。\n如果要执行多个关键词的and搜索，必须使用布尔查询。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\": {\n\"bool\": {\n  \"must\": [\n{ \"match\": { \"desc\": \"软件\" } },\n{ \"match\": { \"desc\": \"系统\" } }\n  ]\n}\n  }\n}'\n```\n\n# 七、参考链接\n&nbsp;&nbsp; &nbsp;&nbsp;\t[ ElasticSearch 官方手册][8]\n&nbsp;&nbsp; &nbsp;&nbsp;\t[A Practical Introduction to Elasticsearch][9]\n\n（完）\n\n[1]:\thttp://www.ruanyifeng.com/blog/2017/08/elasticsearch.html\n[2]:\thttps://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\n[3]:\thttps://www.elastic.co/cn/\n[4]:\thttps://lucene.apache.org/\n[5]:\thttps://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8\n[6]:\thttps://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html\n[8]:\thttps://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html\n[9]:\thttps://www.elastic.co/blog/a-practical-introduction-to-elasticsearch","source":"_posts/[转]全文搜索引擎 Elasticsearch 入门教程.md","raw":"---\ntitle: 全文搜索引擎 Elasticsearch 入门教程\ndata:  2017-11-30 09:06:01\ntag:\n- 全文搜索\n- Elasticsearch\ncategories: 前端\n---\n\n本文转载自：[阮一峰的网络日志][1]\n\n[全文搜索][2]属于最常见的需求，开源的[ Elasticsearch][3] （以下简称 Elastic）是目前全文搜索引擎的首选。\n它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。\n\nElastic 的底层是开源库[Lucene][4]。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。\n本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。\n# 一、安装\nElastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考[这篇文章][5]，注意要保证环境变量JAVA_HOME正确设置。\n安装完 Java，就可以跟着[官方文档][6]安装 Elastic。直接下载压缩包比较简单。\n\n```\n$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip\n$ unzip elasticsearch-5.5.1.zip\n$ cd elasticsearch-5.5.1/ \n```\n\n接着，进入解压后的目录，运行下面的命令，启动 Elastic。\n\n```bash\n$ ./bin/elasticsearch\n```\n\n如果这时报错\"max virtual memory areas vm.maxmapcount [65530]() is too low\"，要运行下面的命令。\n\n```\n$ sudo sysctl -w vm.max_map_count=262144\n```\n\n如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。\n\n```bash\n$ curl localhost:9200\n\n{\n  \"name\" : \"atntrTf\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"tf9250XhQ6ee4h7YI11anA\",\n  \"version\" : {\n\"number\" : \"5.5.1\",\n\"build_hash\" : \"19c13d0\",\n\"build_date\" : \"2017-07-18T20:44:24.823Z\",\n\"build_snapshot\" : false,\n\"lucene_version\" : \"6.6.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n\n上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。\n按下 Ctrl + C，Elastic 就会停止运行。\n默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动 Elastic。\nnetwork.host: 0.0.0.0\n上面代码中，设成0.0.0.0让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。\n# 二、基本概念\n## 2.1 Node 与 Cluster\nElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。\n单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。\n## 2.2 Index\nElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。\n所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。\n下面的命令可以查看当前节点的所有 Index。\n\n```bash\n$ curl -X GET 'http://localhost:9200/_cat/indices?v'\n```\n\n## 2.3 Document\nIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。\nDocument 使用 JSON 格式表示，下面是一个例子。\n\n```bash\n{\n  \"user\": \"张三\",\n  \"title\": \"工程师\",\n  \"desc\": \"数据库管理\"\n}\n```\n\n同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。\n## 2.4 Type\nDocument 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。\n不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。\n下面的命令可以列出每个 Index 所包含的 Type。\n\n```bash\n$ curl 'localhost:9200/_mapping?pretty=true'\n```\n\n根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。\n# 三、新建和删除 Index\n新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。\n\n```bash\n$ curl -X PUT 'localhost:9200/weather'\n\t```\n\n服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。\n\n```bash\n{\n \"acknowledged\":true,\n \"shards_acknowledged\":true\n}\n```\n\n然后，我们发出 DELETE 请求，删除这个 Index。\n$ curl -X DELETE 'localhost:9200/weather'\n# 四、中文分词设置\n首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。\n\n```bash\n$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip\n```\n\n上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。\n接着，重新启动 Elastic，就会自动加载这个新安装的插件。\n然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。\n\n```bash\n$ curl -X PUT 'localhost:9200/accounts' -d '\n{\n  \"mappings\": {\n\"person\": {\n  \"properties\": {\n\"user\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n},\n\"title\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n},\n\"desc\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n}\n  }\n}\n  }\n}'\n```\n\n上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。\nuser\ntitle\ndesc\n这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。\nElastic 的分词器称为 analyzer。我们对每个字段指定分词器。\n\n```bash\n\"user\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\",\n  \"search_analyzer\": \"ik_max_word\"\n}\n```\n\n上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。\n# 五、数据操作\n## 5.1 新增记录\n向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。\n\n```bash\n$ curl -X PUT 'localhost:9200/accounts/person/1' -d '\n{\n  \"user\": \"张三\",\n  \"title\": \"工程师\",\n  \"desc\": \"数据库管理\"\n}' \n```\n\n服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。\n\n```bash\n{\n  \"_index\":\"accounts\",\n  \"_type\":\"person\",\n  \"_id\":\"1\",\n  \"_version\":1,\n  \"result\":\"created\",\n  \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0},\n  \"created\":true\n}\n```\n\n如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。\n新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。\n\n```bash\n$ curl -X POST 'localhost:9200/accounts/person' -d '\n{\n  \"user\": \"李四\",\n  \"title\": \"工程师\",\n  \"desc\": \"系统管理\"\n}'\n```\n\n上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。\n\n```bash\n{\n  \"_index\":\"accounts\",\n  \"_type\":\"person\",\n  \"_id\":\"AV3qGfrC6jMbsbXb6k1p\",\n  \"_version\":1,\n  \"result\":\"created\",\n  \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0},\n  \"created\":true\n}\n```\n\n注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。\n## 5.2 查看记录\n向/Index/Type/Id发出 GET 请求，就可以查看这条记录。\n\n```bash\n$ curl 'localhost:9200/accounts/person/1?pretty=true'\n```\n\n上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。\n返回的数据中，found字段表示查询成功，_source字段返回原始记录。\n\n```bash\n{\n  \"_index\" : \"accounts\",\n  \"_type\" : \"person\",\n  \"_id\" : \"1\",\n  \"_version\" : 1,\n  \"found\" : true,\n  \"_source\" : {\n\"user\" : \"张三\",\n\"title\" : \"工程师\",\n\"desc\" : \"数据库管理\"\n  }\n}\n```\n\n如果 Id 不正确，就查不到数据，found字段就是false。\n\n```bash\n$ curl 'localhost:9200/weather/beijing/abc?pretty=true'\n\n{\n  \"_index\" : \"accounts\",\n  \"_type\" : \"person\",\n  \"_id\" : \"abc\",\n  \"found\" : false\n}\n```\n\n## 5.3 删除记录\n删除记录就是发出 DELETE 请求。\n\n```bash\n$ curl -X DELETE 'localhost:9200/accounts/person/1'\n\t```\n\n这里先不要删除这条记录，后面还要用到。\n## 5.4 更新记录\n更新记录就是使用 PUT 请求，重新发送一次数据。\n\n```bash\n$ curl -X PUT 'localhost:9200/accounts/person/1' -d '\n{\n\"user\" : \"张三\",\n\"title\" : \"工程师\",\n\"desc\" : \"数据库管理，软件开发\"\n}' \n\n{\n  \"_index\":\"accounts\",\n  \"_type\":\"person\",\n  \"_id\":\"1\",\n  \"_version\":2,\n  \"result\":\"updated\",\n  \"_shards\":{\"total\":2,\"successful\":1,\"failed\":0},\n  \"created\":false\n}\n```\n\n上面代码中，我们将原始数据从\"数据库管理\"改成\"数据库管理，软件开发\"。 返回结果里面，有几个字段发生了变化。\n\n```bash\n\"_version\" : 2,\n\"result\" : \"updated\",\n\"created\" : false\n```\n\n可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。\n# 六、数据查询\n## 6.1 返回所有记录\n使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。_\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'\n\n{\n  \"took\":2,\n  \"timed_out\":false,\n  \"_shards\":{\"total\":5,\"successful\":5,\"failed\":0},\n  \"hits\":{\n\"total\":2,\n\"max_score\":1.0,\n\"hits\":[\n  {\n\"_index\":\"accounts\",\n\"_type\":\"person\",\n\"_id\":\"AV3qGfrC6jMbsbXb6k1p\",\n\"_score\":1.0,\n\"_source\": {\n  \"user\": \"李四\",\n  \"title\": \"工程师\",\n  \"desc\": \"系统管理\"\n}\n  },\n  {\n\"_index\":\"accounts\",\n\"_type\":\"person\",\n\"_id\":\"1\",\n\"_score\":1.0,\n\"_source\": {\n  \"user\" : \"张三\",\n  \"title\" : \"工程师\",\n  \"desc\" : \"数据库管理，软件开发\"\n}\n  }\n]\n  }\n}\n```\n\n上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。\ntotal：返回记录数，本例是2条。\nmax_score：最高的匹配程度，本例是1.0。\nhits：返回的记录组成的数组。\n返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。\n\n## 6.2 全文搜索\nElastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"软件\" }}\n}'\n```\n\n上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含\"软件\"这个词。返回结果如下。\n\n```bash\n{\n  \"took\":3,\n  \"timed_out\":false,\n  \"_shards\":{\"total\":5,\"successful\":5,\"failed\":0},\n  \"hits\":{\n\"total\":1,\n\"max_score\":0.28582606,\n\"hits\":[\n  {\n\"_index\":\"accounts\",\n\"_type\":\"person\",\n\"_id\":\"1\",\n\"_score\":0.28582606,\n\"_source\": {\n  \"user\" : \"张三\",\n  \"title\" : \"工程师\",\n  \"desc\" : \"数据库管理，软件开发\"\n}\n  }\n]\n  }\n}\n```\n\nElastic 默认一次返回10条结果，可以通过size字段改变这个设置。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"管理\" }},\n  \"size\": 1\n}'\n```\n\n上面代码指定，每次只返回一条结果。\n还可以通过from字段，指定位移。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"管理\" }},\n  \"from\": 1,\n  \"size\": 1\n}'\n```\n\n上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。\n## 6.3 逻辑运算\n如果有多个搜索关键字， Elastic 认为它们是or关系。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\" : { \"match\" : { \"desc\" : \"软件 系统\" }}\n}'\n```\n\n上面代码搜索的是软件 or 系统。\n如果要执行多个关键词的and搜索，必须使用布尔查询。\n\n```bash\n$ curl 'localhost:9200/accounts/person/_search'  -d '\n{\n  \"query\": {\n\"bool\": {\n  \"must\": [\n{ \"match\": { \"desc\": \"软件\" } },\n{ \"match\": { \"desc\": \"系统\" } }\n  ]\n}\n  }\n}'\n```\n\n# 七、参考链接\n&nbsp;&nbsp; &nbsp;&nbsp;\t[ ElasticSearch 官方手册][8]\n&nbsp;&nbsp; &nbsp;&nbsp;\t[A Practical Introduction to Elasticsearch][9]\n\n（完）\n\n[1]:\thttp://www.ruanyifeng.com/blog/2017/08/elasticsearch.html\n[2]:\thttps://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\n[3]:\thttps://www.elastic.co/cn/\n[4]:\thttps://lucene.apache.org/\n[5]:\thttps://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8\n[6]:\thttps://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html\n[8]:\thttps://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html\n[9]:\thttps://www.elastic.co/blog/a-practical-introduction-to-elasticsearch","slug":"[转]全文搜索引擎 Elasticsearch 入门教程","published":1,"date":"2017-11-30T01:04:37.000Z","updated":"2017-11-30T05:28:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjxl000cxqs6byv10yhw","content":"<p>本文转载自：<a href=\"http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\" target=\"_blank\" rel=\"noopener\">全文搜索</a>属于最常见的需求，开源的<a href=\"https://www.elastic.co/cn/\" target=\"_blank\" rel=\"noopener\"> Elasticsearch</a> （以下简称 Elastic）是目前全文搜索引擎的首选。<br>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>\n<p>Elastic 的底层是开源库<a href=\"https://lucene.apache.org/\" target=\"_blank\" rel=\"noopener\">Lucene</a>。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。<br>本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。</p>\n<h1 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h1><p>Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，注意要保证环境变量JAVA_HOME正确设置。<br>安装完 Java，就可以跟着<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>安装 Elastic。直接下载压缩包比较简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class=\"line\">$ unzip elasticsearch-5.5.1.zip</span><br><span class=\"line\">$ cd elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure>\n<p>接着，进入解压后的目录，运行下面的命令，启动 Elastic。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure>\n<p>如果这时报错”max virtual memory areas vm.maxmapcount <a href=\"\">65530</a> is too low”，要运行下面的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>\n<p>如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl localhost:9200</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"atntrTf\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_name\"</span> : <span class=\"string\">\"elasticsearch\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_uuid\"</span> : <span class=\"string\">\"tf9250XhQ6ee4h7YI11anA\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span> : &#123;</span><br><span class=\"line\"><span class=\"string\">\"number\"</span> : <span class=\"string\">\"5.5.1\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build_hash\"</span> : <span class=\"string\">\"19c13d0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build_date\"</span> : <span class=\"string\">\"2017-07-18T20:44:24.823Z\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build_snapshot\"</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">\"lucene_version\"</span> : <span class=\"string\">\"6.6.0\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"tagline\"</span> : <span class=\"string\">\"You Know, for Search\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。<br>按下 Ctrl + C，Elastic 就会停止运行。<br>默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动 Elastic。<br>network.host: 0.0.0.0<br>上面代码中，设成0.0.0.0让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。</p>\n<h1 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h1><h2 id=\"2-1-Node-与-Cluster\"><a href=\"#2-1-Node-与-Cluster\" class=\"headerlink\" title=\"2.1 Node 与 Cluster\"></a>2.1 Node 与 Cluster</h2><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。<br>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>\n<h2 id=\"2-2-Index\"><a href=\"#2-2-Index\" class=\"headerlink\" title=\"2.2 Index\"></a>2.2 Index</h2><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。<br>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。<br>下面的命令可以查看当前节点的所有 Index。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X GET <span class=\"string\">'http://localhost:9200/_cat/indices?v'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-Document\"><a href=\"#2-3-Document\" class=\"headerlink\" title=\"2.3 Document\"></a>2.3 Document</h2><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。<br>Document 使用 JSON 格式表示，下面是一个例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span>: <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span>: <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span>: <span class=\"string\">\"数据库管理\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>\n<h2 id=\"2-4-Type\"><a href=\"#2-4-Type\" class=\"headerlink\" title=\"2.4 Type\"></a>2.4 Type</h2><p>Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。<br>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。<br>下面的命令可以列出每个 Index 所包含的 Type。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/_mapping?pretty=true'</span></span><br></pre></td></tr></table></figure>\n<p>根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>\n<h1 id=\"三、新建和删除-Index\"><a href=\"#三、新建和删除-Index\" class=\"headerlink\" title=\"三、新建和删除 Index\"></a>三、新建和删除 Index</h1><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/weather'</span></span><br></pre></td></tr></table></figure>\n<p>服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"acknowledged\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\"> <span class=\"string\">\"shards_acknowledged\"</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们发出 DELETE 请求，删除这个 Index。<br>$ curl -X DELETE ‘localhost:9200/weather’</p>\n<h1 id=\"四、中文分词设置\"><a href=\"#四、中文分词设置\" class=\"headerlink\" title=\"四、中文分词设置\"></a>四、中文分词设置</h1><p>首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span><br></pre></td></tr></table></figure>\n<p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。<br>接着，重新启动 Elastic，就会自动加载这个新安装的插件。<br>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/accounts'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"mappings\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">\"person\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"properties\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">\"user\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"type\": \"text\",</span></span><br><span class=\"line\"><span class=\"string\">  \"analyzer\": \"ik_max_word\",</span></span><br><span class=\"line\"><span class=\"string\">  \"search_analyzer\": \"ik_max_word\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;,</span></span><br><span class=\"line\"><span class=\"string\">\"title\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"type\": \"text\",</span></span><br><span class=\"line\"><span class=\"string\">  \"analyzer\": \"ik_max_word\",</span></span><br><span class=\"line\"><span class=\"string\">  \"search_analyzer\": \"ik_max_word\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;,</span></span><br><span class=\"line\"><span class=\"string\">\"desc\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"type\": \"text\",</span></span><br><span class=\"line\"><span class=\"string\">  \"analyzer\": \"ik_max_word\",</span></span><br><span class=\"line\"><span class=\"string\">  \"search_analyzer\": \"ik_max_word\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。<br>user<br>title<br>desc<br>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。<br>Elastic 的分词器称为 analyzer。我们对每个字段指定分词器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"user\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"ik_max_word\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"search_analyzer\"</span>: <span class=\"string\">\"ik_max_word\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。</p>\n<h1 id=\"五、数据操作\"><a href=\"#五、数据操作\" class=\"headerlink\" title=\"五、数据操作\"></a>五、数据操作</h1><h2 id=\"5-1-新增记录\"><a href=\"#5-1-新增记录\" class=\"headerlink\" title=\"5.1 新增记录\"></a>5.1 新增记录</h2><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/accounts/person/1'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"user\": \"张三\",</span></span><br><span class=\"line\"><span class=\"string\">  \"title\": \"工程师\",</span></span><br><span class=\"line\"><span class=\"string\">  \"desc\": \"数据库管理\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span>:1,</span><br><span class=\"line\">  <span class=\"string\">\"result\"</span>:<span class=\"string\">\"created\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:2,<span class=\"string\">\"successful\"</span>:1,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"created\"</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。<br>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X POST <span class=\"string\">'localhost:9200/accounts/person'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"user\": \"李四\",</span></span><br><span class=\"line\"><span class=\"string\">  \"title\": \"工程师\",</span></span><br><span class=\"line\"><span class=\"string\">  \"desc\": \"系统管理\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span>:<span class=\"string\">\"AV3qGfrC6jMbsbXb6k1p\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span>:1,</span><br><span class=\"line\">  <span class=\"string\">\"result\"</span>:<span class=\"string\">\"created\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:2,<span class=\"string\">\"successful\"</span>:1,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"created\"</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p>\n<h2 id=\"5-2-查看记录\"><a href=\"#5-2-查看记录\" class=\"headerlink\" title=\"5.2 查看记录\"></a>5.2 查看记录</h2><p>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/1?pretty=true'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。<br>返回的数据中，found字段表示查询成功，_source字段返回原始记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">\"found\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_source\"</span> : &#123;</span><br><span class=\"line\"><span class=\"string\">\"user\"</span> : <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"title\"</span> : <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"desc\"</span> : <span class=\"string\">\"数据库管理\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 Id 不正确，就查不到数据，found字段就是false。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/weather/beijing/abc?pretty=true'</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"abc\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"found\"</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3-删除记录\"><a href=\"#5-3-删除记录\" class=\"headerlink\" title=\"5.3 删除记录\"></a>5.3 删除记录</h2><p>删除记录就是发出 DELETE 请求。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X DELETE <span class=\"string\">'localhost:9200/accounts/person/1'</span></span><br></pre></td></tr></table></figure>\n<p>这里先不要删除这条记录，后面还要用到。</p>\n<h2 id=\"5-4-更新记录\"><a href=\"#5-4-更新记录\" class=\"headerlink\" title=\"5.4 更新记录\"></a>5.4 更新记录</h2><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/accounts/person/1'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">\"user\" : \"张三\",</span></span><br><span class=\"line\"><span class=\"string\">\"title\" : \"工程师\",</span></span><br><span class=\"line\"><span class=\"string\">\"desc\" : \"数据库管理，软件开发\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span>:2,</span><br><span class=\"line\">  <span class=\"string\">\"result\"</span>:<span class=\"string\">\"updated\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:2,<span class=\"string\">\"successful\"</span>:1,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"created\"</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"_version\"</span> : 2,</span><br><span class=\"line\"><span class=\"string\">\"result\"</span> : <span class=\"string\">\"updated\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"created\"</span> : <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。</p>\n<h1 id=\"六、数据查询\"><a href=\"#六、数据查询\" class=\"headerlink\" title=\"六、数据查询\"></a>六、数据查询</h1><h2 id=\"6-1-返回所有记录\"><a href=\"#6-1-返回所有记录\" class=\"headerlink\" title=\"6.1 返回所有记录\"></a>6.1 返回所有记录</h2><p>使用 GET 方法，直接请求/Index/Type/<em>search，就会返回所有记录。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"took\"</span>:2,</span><br><span class=\"line\">  <span class=\"string\">\"timed_out\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:5,<span class=\"string\">\"successful\"</span>:5,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"hits\"</span>:&#123;</span><br><span class=\"line\"><span class=\"string\">\"total\"</span>:2,</span><br><span class=\"line\"><span class=\"string\">\"max_score\"</span>:1.0,</span><br><span class=\"line\"><span class=\"string\">\"hits\"</span>:[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_id\"</span>:<span class=\"string\">\"AV3qGfrC6jMbsbXb6k1p\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_score\"</span>:1.0,</span><br><span class=\"line\"><span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span>: <span class=\"string\">\"李四\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span>: <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span>: <span class=\"string\">\"系统管理\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_score\"</span>:1.0,</span><br><span class=\"line\"><span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span> : <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span> : <span class=\"string\">\"数据库管理，软件开发\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。<br>total：返回记录数，本例是2条。<br>max_score：最高的匹配程度，本例是1.0。<br>hits：返回的记录组成的数组。<br>返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。</p>\n<h2 id=\"6-2-全文搜索\"><a href=\"#6-2-全文搜索\" class=\"headerlink\" title=\"6.2 全文搜索\"></a>6.2 全文搜索</h2><p>Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"软件\" &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含”软件”这个词。返回结果如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"took\"</span>:3,</span><br><span class=\"line\">  <span class=\"string\">\"timed_out\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:5,<span class=\"string\">\"successful\"</span>:5,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"hits\"</span>:&#123;</span><br><span class=\"line\"><span class=\"string\">\"total\"</span>:1,</span><br><span class=\"line\"><span class=\"string\">\"max_score\"</span>:0.28582606,</span><br><span class=\"line\"><span class=\"string\">\"hits\"</span>:[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_score\"</span>:0.28582606,</span><br><span class=\"line\"><span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span> : <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span> : <span class=\"string\">\"数据库管理，软件开发\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"管理\" &#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">  \"size\": 1</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码指定，每次只返回一条结果。<br>还可以通过from字段，指定位移。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"管理\" &#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">  \"from\": 1,</span></span><br><span class=\"line\"><span class=\"string\">  \"size\": 1</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p>\n<h2 id=\"6-3-逻辑运算\"><a href=\"#6-3-逻辑运算\" class=\"headerlink\" title=\"6.3 逻辑运算\"></a>6.3 逻辑运算</h2><p>如果有多个搜索关键字， Elastic 认为它们是or关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"软件 系统\" &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码搜索的是软件 or 系统。<br>如果要执行多个关键词的and搜索，必须使用布尔查询。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">\"bool\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"must\": [</span></span><br><span class=\"line\"><span class=\"string\">&#123; \"match\": &#123; \"desc\": \"软件\" &#125; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">&#123; \"match\": &#123; \"desc\": \"系统\" &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">  ]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"七、参考链接\"><a href=\"#七、参考链接\" class=\"headerlink\" title=\"七、参考链接\"></a>七、参考链接</h1><p>&nbsp;&nbsp; &nbsp;&nbsp;    <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html\" target=\"_blank\" rel=\"noopener\"> ElasticSearch 官方手册</a><br>&nbsp;&nbsp; &nbsp;&nbsp;    <a href=\"https://www.elastic.co/blog/a-practical-introduction-to-elasticsearch\" target=\"_blank\" rel=\"noopener\">A Practical Introduction to Elasticsearch</a></p>\n<p>（完）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文转载自：<a href=\"http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\" target=\"_blank\" rel=\"noopener\">全文搜索</a>属于最常见的需求，开源的<a href=\"https://www.elastic.co/cn/\" target=\"_blank\" rel=\"noopener\"> Elasticsearch</a> （以下简称 Elastic）是目前全文搜索引擎的首选。<br>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>\n<p>Elastic 的底层是开源库<a href=\"https://lucene.apache.org/\" target=\"_blank\" rel=\"noopener\">Lucene</a>。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。<br>本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。</p>\n<h1 id=\"一、安装\"><a href=\"#一、安装\" class=\"headerlink\" title=\"一、安装\"></a>一、安装</h1><p>Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，注意要保证环境变量JAVA_HOME正确设置。<br>安装完 Java，就可以跟着<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>安装 Elastic。直接下载压缩包比较简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class=\"line\">$ unzip elasticsearch-5.5.1.zip</span><br><span class=\"line\">$ cd elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure>\n<p>接着，进入解压后的目录，运行下面的命令，启动 Elastic。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./bin/elasticsearch</span><br></pre></td></tr></table></figure>\n<p>如果这时报错”max virtual memory areas vm.maxmapcount <a href=\"\">65530</a> is too low”，要运行下面的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>\n<p>如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl localhost:9200</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"atntrTf\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_name\"</span> : <span class=\"string\">\"elasticsearch\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_uuid\"</span> : <span class=\"string\">\"tf9250XhQ6ee4h7YI11anA\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span> : &#123;</span><br><span class=\"line\"><span class=\"string\">\"number\"</span> : <span class=\"string\">\"5.5.1\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build_hash\"</span> : <span class=\"string\">\"19c13d0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build_date\"</span> : <span class=\"string\">\"2017-07-18T20:44:24.823Z\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build_snapshot\"</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">\"lucene_version\"</span> : <span class=\"string\">\"6.6.0\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"tagline\"</span> : <span class=\"string\">\"You Know, for Search\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。<br>按下 Ctrl + C，Elastic 就会停止运行。<br>默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动 Elastic。<br>network.host: 0.0.0.0<br>上面代码中，设成0.0.0.0让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。</p>\n<h1 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h1><h2 id=\"2-1-Node-与-Cluster\"><a href=\"#2-1-Node-与-Cluster\" class=\"headerlink\" title=\"2.1 Node 与 Cluster\"></a>2.1 Node 与 Cluster</h2><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。<br>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>\n<h2 id=\"2-2-Index\"><a href=\"#2-2-Index\" class=\"headerlink\" title=\"2.2 Index\"></a>2.2 Index</h2><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。<br>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。<br>下面的命令可以查看当前节点的所有 Index。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X GET <span class=\"string\">'http://localhost:9200/_cat/indices?v'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-Document\"><a href=\"#2-3-Document\" class=\"headerlink\" title=\"2.3 Document\"></a>2.3 Document</h2><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。<br>Document 使用 JSON 格式表示，下面是一个例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span>: <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span>: <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span>: <span class=\"string\">\"数据库管理\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>\n<h2 id=\"2-4-Type\"><a href=\"#2-4-Type\" class=\"headerlink\" title=\"2.4 Type\"></a>2.4 Type</h2><p>Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。<br>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。<br>下面的命令可以列出每个 Index 所包含的 Type。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/_mapping?pretty=true'</span></span><br></pre></td></tr></table></figure>\n<p>根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>\n<h1 id=\"三、新建和删除-Index\"><a href=\"#三、新建和删除-Index\" class=\"headerlink\" title=\"三、新建和删除 Index\"></a>三、新建和删除 Index</h1><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/weather'</span></span><br></pre></td></tr></table></figure>\n<p>服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"acknowledged\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\"> <span class=\"string\">\"shards_acknowledged\"</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们发出 DELETE 请求，删除这个 Index。<br>$ curl -X DELETE ‘localhost:9200/weather’</p>\n<h1 id=\"四、中文分词设置\"><a href=\"#四、中文分词设置\" class=\"headerlink\" title=\"四、中文分词设置\"></a>四、中文分词设置</h1><p>首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span><br></pre></td></tr></table></figure>\n<p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。<br>接着，重新启动 Elastic，就会自动加载这个新安装的插件。<br>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/accounts'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"mappings\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">\"person\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"properties\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">\"user\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"type\": \"text\",</span></span><br><span class=\"line\"><span class=\"string\">  \"analyzer\": \"ik_max_word\",</span></span><br><span class=\"line\"><span class=\"string\">  \"search_analyzer\": \"ik_max_word\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;,</span></span><br><span class=\"line\"><span class=\"string\">\"title\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"type\": \"text\",</span></span><br><span class=\"line\"><span class=\"string\">  \"analyzer\": \"ik_max_word\",</span></span><br><span class=\"line\"><span class=\"string\">  \"search_analyzer\": \"ik_max_word\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;,</span></span><br><span class=\"line\"><span class=\"string\">\"desc\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"type\": \"text\",</span></span><br><span class=\"line\"><span class=\"string\">  \"analyzer\": \"ik_max_word\",</span></span><br><span class=\"line\"><span class=\"string\">  \"search_analyzer\": \"ik_max_word\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。<br>user<br>title<br>desc<br>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。<br>Elastic 的分词器称为 analyzer。我们对每个字段指定分词器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"user\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"ik_max_word\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"search_analyzer\"</span>: <span class=\"string\">\"ik_max_word\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。</p>\n<h1 id=\"五、数据操作\"><a href=\"#五、数据操作\" class=\"headerlink\" title=\"五、数据操作\"></a>五、数据操作</h1><h2 id=\"5-1-新增记录\"><a href=\"#5-1-新增记录\" class=\"headerlink\" title=\"5.1 新增记录\"></a>5.1 新增记录</h2><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/accounts/person/1'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"user\": \"张三\",</span></span><br><span class=\"line\"><span class=\"string\">  \"title\": \"工程师\",</span></span><br><span class=\"line\"><span class=\"string\">  \"desc\": \"数据库管理\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span>:1,</span><br><span class=\"line\">  <span class=\"string\">\"result\"</span>:<span class=\"string\">\"created\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:2,<span class=\"string\">\"successful\"</span>:1,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"created\"</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。<br>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X POST <span class=\"string\">'localhost:9200/accounts/person'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"user\": \"李四\",</span></span><br><span class=\"line\"><span class=\"string\">  \"title\": \"工程师\",</span></span><br><span class=\"line\"><span class=\"string\">  \"desc\": \"系统管理\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span>:<span class=\"string\">\"AV3qGfrC6jMbsbXb6k1p\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span>:1,</span><br><span class=\"line\">  <span class=\"string\">\"result\"</span>:<span class=\"string\">\"created\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:2,<span class=\"string\">\"successful\"</span>:1,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"created\"</span>:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p>\n<h2 id=\"5-2-查看记录\"><a href=\"#5-2-查看记录\" class=\"headerlink\" title=\"5.2 查看记录\"></a>5.2 查看记录</h2><p>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/1?pretty=true'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。<br>返回的数据中，found字段表示查询成功，_source字段返回原始记录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span> : 1,</span><br><span class=\"line\">  <span class=\"string\">\"found\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_source\"</span> : &#123;</span><br><span class=\"line\"><span class=\"string\">\"user\"</span> : <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"title\"</span> : <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"desc\"</span> : <span class=\"string\">\"数据库管理\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 Id 不正确，就查不到数据，found字段就是false。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/weather/beijing/abc?pretty=true'</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"abc\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"found\"</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3-删除记录\"><a href=\"#5-3-删除记录\" class=\"headerlink\" title=\"5.3 删除记录\"></a>5.3 删除记录</h2><p>删除记录就是发出 DELETE 请求。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X DELETE <span class=\"string\">'localhost:9200/accounts/person/1'</span></span><br></pre></td></tr></table></figure>\n<p>这里先不要删除这条记录，后面还要用到。</p>\n<h2 id=\"5-4-更新记录\"><a href=\"#5-4-更新记录\" class=\"headerlink\" title=\"5.4 更新记录\"></a>5.4 更新记录</h2><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">'localhost:9200/accounts/person/1'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">\"user\" : \"张三\",</span></span><br><span class=\"line\"><span class=\"string\">\"title\" : \"工程师\",</span></span><br><span class=\"line\"><span class=\"string\">\"desc\" : \"数据库管理，软件开发\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> </span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_version\"</span>:2,</span><br><span class=\"line\">  <span class=\"string\">\"result\"</span>:<span class=\"string\">\"updated\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:2,<span class=\"string\">\"successful\"</span>:1,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"created\"</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"_version\"</span> : 2,</span><br><span class=\"line\"><span class=\"string\">\"result\"</span> : <span class=\"string\">\"updated\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"created\"</span> : <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。</p>\n<h1 id=\"六、数据查询\"><a href=\"#六、数据查询\" class=\"headerlink\" title=\"六、数据查询\"></a>六、数据查询</h1><h2 id=\"6-1-返回所有记录\"><a href=\"#6-1-返回所有记录\" class=\"headerlink\" title=\"6.1 返回所有记录\"></a>6.1 返回所有记录</h2><p>使用 GET 方法，直接请求/Index/Type/<em>search，就会返回所有记录。</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"took\"</span>:2,</span><br><span class=\"line\">  <span class=\"string\">\"timed_out\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:5,<span class=\"string\">\"successful\"</span>:5,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"hits\"</span>:&#123;</span><br><span class=\"line\"><span class=\"string\">\"total\"</span>:2,</span><br><span class=\"line\"><span class=\"string\">\"max_score\"</span>:1.0,</span><br><span class=\"line\"><span class=\"string\">\"hits\"</span>:[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_id\"</span>:<span class=\"string\">\"AV3qGfrC6jMbsbXb6k1p\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_score\"</span>:1.0,</span><br><span class=\"line\"><span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span>: <span class=\"string\">\"李四\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span>: <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span>: <span class=\"string\">\"系统管理\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_score\"</span>:1.0,</span><br><span class=\"line\"><span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span> : <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span> : <span class=\"string\">\"数据库管理，软件开发\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。<br>total：返回记录数，本例是2条。<br>max_score：最高的匹配程度，本例是1.0。<br>hits：返回的记录组成的数组。<br>返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。</p>\n<h2 id=\"6-2-全文搜索\"><a href=\"#6-2-全文搜索\" class=\"headerlink\" title=\"6.2 全文搜索\"></a>6.2 全文搜索</h2><p>Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"软件\" &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含”软件”这个词。返回结果如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"took\"</span>:3,</span><br><span class=\"line\">  <span class=\"string\">\"timed_out\"</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"string\">\"_shards\"</span>:&#123;<span class=\"string\">\"total\"</span>:5,<span class=\"string\">\"successful\"</span>:5,<span class=\"string\">\"failed\"</span>:0&#125;,</span><br><span class=\"line\">  <span class=\"string\">\"hits\"</span>:&#123;</span><br><span class=\"line\"><span class=\"string\">\"total\"</span>:1,</span><br><span class=\"line\"><span class=\"string\">\"max_score\"</span>:0.28582606,</span><br><span class=\"line\"><span class=\"string\">\"hits\"</span>:[</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"string\">\"_index\"</span>:<span class=\"string\">\"accounts\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_type\"</span>:<span class=\"string\">\"person\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_id\"</span>:<span class=\"string\">\"1\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"_score\"</span>:0.28582606,</span><br><span class=\"line\"><span class=\"string\">\"_source\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"user\"</span> : <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"工程师\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"desc\"</span> : <span class=\"string\">\"数据库管理，软件开发\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"管理\" &#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">  \"size\": 1</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码指定，每次只返回一条结果。<br>还可以通过from字段，指定位移。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"管理\" &#125;&#125;,</span></span><br><span class=\"line\"><span class=\"string\">  \"from\": 1,</span></span><br><span class=\"line\"><span class=\"string\">  \"size\": 1</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p>\n<h2 id=\"6-3-逻辑运算\"><a href=\"#6-3-逻辑运算\" class=\"headerlink\" title=\"6.3 逻辑运算\"></a>6.3 逻辑运算</h2><p>如果有多个搜索关键字， Elastic 认为它们是or关系。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\" : &#123; \"match\" : &#123; \"desc\" : \"软件 系统\" &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>上面代码搜索的是软件 or 系统。<br>如果要执行多个关键词的and搜索，必须使用布尔查询。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">'localhost:9200/accounts/person/_search'</span>  -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"query\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">\"bool\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">  \"must\": [</span></span><br><span class=\"line\"><span class=\"string\">&#123; \"match\": &#123; \"desc\": \"软件\" &#125; &#125;,</span></span><br><span class=\"line\"><span class=\"string\">&#123; \"match\": &#123; \"desc\": \"系统\" &#125; &#125;</span></span><br><span class=\"line\"><span class=\"string\">  ]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"七、参考链接\"><a href=\"#七、参考链接\" class=\"headerlink\" title=\"七、参考链接\"></a>七、参考链接</h1><p>&nbsp;&nbsp; &nbsp;&nbsp;    <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html\" target=\"_blank\" rel=\"noopener\"> ElasticSearch 官方手册</a><br>&nbsp;&nbsp; &nbsp;&nbsp;    <a href=\"https://www.elastic.co/blog/a-practical-introduction-to-elasticsearch\" target=\"_blank\" rel=\"noopener\">A Practical Introduction to Elasticsearch</a></p>\n<p>（完）</p>\n"},{"title":"componentWillReceiveProps详解（this.props）状态改变检测机制","data":"2017-12-19T10:07:01.000Z","_content":"\n关于组件挂载的经典的图片：\n![][image-1]\n\n下面一一说一下这几个生命周期的意义：\n## getDefaultProps\nobject getDefaultProps()\n执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的   \n这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制\n\n## getInitialState\nobject getInitialState()\n控件加载之前执行，返回值会被用于state的初始化值\n\n## componentWillMount\nvoid componentWillMount()\n执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次\n\n## render\nReactElement render()\nrender的时候会调用render()会被调用   \n调用render()方法时，首先检查this.props和this.state返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现   \n如果不想渲染可以返回null或者false，这种场景下，react渲染一个\\<noscript\\>标签，当返回null或者false时，ReactDOM.findDOMNode(this)返回null   \nrender()方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互，如果必须如服务器交互，在componentDidMount()方法中实现或者其他生命周期的方法中实现，保持render()方法纯净使得服务器更准确，组件更简单\n\n## componentDidMount\nvoid componentDidMount()\n在初始化render之后只执行一次，在这个方法内，可以访问任何组件，componentDidMount()方法中的子组件在父组件之前执行\n从这个函数开始，就可以和 js 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求\n\n## shouldComponentUpdate\nboolean shouldComponentUpdate(\n  object nextProps, object nextState\n}\n这个方法在初始化render时不会执行，当props或者state发生变化时执行，并且是在render之前，当新的props或者state不需要更新组件时，返回false\nshouldComponentUpdate: function(nextProps, nextState) {\n  return nextProps.id !== this.props.id;\n}\n当shouldComponentUpdate方法返回false时，就不会执行render()方法，componentWillUpdate和componentDidUpdate方法也不会被调用\n默认情况下，shouldComponentUpdate方法返回true防止state快速变化时的问题，但是如果·state不变，props只读，可以直接覆盖shouldComponentUpdate用于比较props和state的变化，决定UI是否更新，当组件比较多时，使用这个方法能有效提高应用性能\n\n## componentWillUpdate\nvoid componentWillUpdate(\n  object nextProps, object nextState\n)\n当props和state发生变化时执行，并且在render方法之前执行，当然初始化render时不执行该方法，需要特别注意的是，在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。紧接着这个函数，就会调用render()来更新界面了\n\n## componentDidUpdate\nvoid componentDidUpdate(\n  object prevProps, object prevState\n)\n组件更新结束之后执行，在初始化render时不执行\n\n## componentWillReceiveProps\nvoid componentWillReceiveProps(\n  object nextProps\n)\n当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用\ncomponentWillReceiveProps: function(nextProps) {\n  this.setState({\nlikesIncreasing: nextProps.likeCount \\> this.props.likeCount\n  });\n}\n\n## componentWillUnmount\nvoid componentWillUnmount()\n当组件要被从界面上移除的时候，就会调用componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等\n\n\n[image-1]:\thttp://p09eeagrw.bkt.clouddn.com/1106982-20170811224737742-1564011484.jpg","source":"_posts/componentWillReceiveProps详解（this.props）状态改变检测机制.md","raw":"---\ntitle: componentWillReceiveProps详解（this.props）状态改变检测机制\ndata:  2017-12-19 18:07:01\ntag:\n-  componentWillReceiveProps\n- React\ncategories: 前端\n---\n\n关于组件挂载的经典的图片：\n![][image-1]\n\n下面一一说一下这几个生命周期的意义：\n## getDefaultProps\nobject getDefaultProps()\n执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的   \n这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制\n\n## getInitialState\nobject getInitialState()\n控件加载之前执行，返回值会被用于state的初始化值\n\n## componentWillMount\nvoid componentWillMount()\n执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次\n\n## render\nReactElement render()\nrender的时候会调用render()会被调用   \n调用render()方法时，首先检查this.props和this.state返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现   \n如果不想渲染可以返回null或者false，这种场景下，react渲染一个\\<noscript\\>标签，当返回null或者false时，ReactDOM.findDOMNode(this)返回null   \nrender()方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互，如果必须如服务器交互，在componentDidMount()方法中实现或者其他生命周期的方法中实现，保持render()方法纯净使得服务器更准确，组件更简单\n\n## componentDidMount\nvoid componentDidMount()\n在初始化render之后只执行一次，在这个方法内，可以访问任何组件，componentDidMount()方法中的子组件在父组件之前执行\n从这个函数开始，就可以和 js 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求\n\n## shouldComponentUpdate\nboolean shouldComponentUpdate(\n  object nextProps, object nextState\n}\n这个方法在初始化render时不会执行，当props或者state发生变化时执行，并且是在render之前，当新的props或者state不需要更新组件时，返回false\nshouldComponentUpdate: function(nextProps, nextState) {\n  return nextProps.id !== this.props.id;\n}\n当shouldComponentUpdate方法返回false时，就不会执行render()方法，componentWillUpdate和componentDidUpdate方法也不会被调用\n默认情况下，shouldComponentUpdate方法返回true防止state快速变化时的问题，但是如果·state不变，props只读，可以直接覆盖shouldComponentUpdate用于比较props和state的变化，决定UI是否更新，当组件比较多时，使用这个方法能有效提高应用性能\n\n## componentWillUpdate\nvoid componentWillUpdate(\n  object nextProps, object nextState\n)\n当props和state发生变化时执行，并且在render方法之前执行，当然初始化render时不执行该方法，需要特别注意的是，在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。紧接着这个函数，就会调用render()来更新界面了\n\n## componentDidUpdate\nvoid componentDidUpdate(\n  object prevProps, object prevState\n)\n组件更新结束之后执行，在初始化render时不执行\n\n## componentWillReceiveProps\nvoid componentWillReceiveProps(\n  object nextProps\n)\n当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用\ncomponentWillReceiveProps: function(nextProps) {\n  this.setState({\nlikesIncreasing: nextProps.likeCount \\> this.props.likeCount\n  });\n}\n\n## componentWillUnmount\nvoid componentWillUnmount()\n当组件要被从界面上移除的时候，就会调用componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等\n\n\n[image-1]:\thttp://p09eeagrw.bkt.clouddn.com/1106982-20170811224737742-1564011484.jpg","slug":"componentWillReceiveProps详解（this.props）状态改变检测机制","published":1,"date":"2017-12-19T10:05:41.000Z","updated":"2017-12-19T10:16:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjxr000dxqs6w68yjs56","content":"<p>关于组件挂载的经典的图片：<br><img src=\"http://p09eeagrw.bkt.clouddn.com/1106982-20170811224737742-1564011484.jpg\" alt=\"\"></p>\n<p>下面一一说一下这几个生命周期的意义：</p>\n<h2 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a>getDefaultProps</h2><p>object getDefaultProps()<br>执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的<br>这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制</p>\n<h2 id=\"getInitialState\"><a href=\"#getInitialState\" class=\"headerlink\" title=\"getInitialState\"></a>getInitialState</h2><p>object getInitialState()<br>控件加载之前执行，返回值会被用于state的初始化值</p>\n<h2 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a>componentWillMount</h2><p>void componentWillMount()<br>执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次</p>\n<h2 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h2><p>ReactElement render()<br>render的时候会调用render()会被调用<br>调用render()方法时，首先检查this.props和this.state返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现<br>如果不想渲染可以返回null或者false，这种场景下，react渲染一个\\<noscript\\>标签，当返回null或者false时，ReactDOM.findDOMNode(this)返回null<br>render()方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互，如果必须如服务器交互，在componentDidMount()方法中实现或者其他生命周期的方法中实现，保持render()方法纯净使得服务器更准确，组件更简单</noscript\\></p>\n<h2 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h2><p>void componentDidMount()<br>在初始化render之后只执行一次，在这个方法内，可以访问任何组件，componentDidMount()方法中的子组件在父组件之前执行<br>从这个函数开始，就可以和 js 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求</p>\n<h2 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h2><p>boolean shouldComponentUpdate(<br>  object nextProps, object nextState<br>}<br>这个方法在初始化render时不会执行，当props或者state发生变化时执行，并且是在render之前，当新的props或者state不需要更新组件时，返回false<br>shouldComponentUpdate: function(nextProps, nextState) {<br>  return nextProps.id !== this.props.id;<br>}<br>当shouldComponentUpdate方法返回false时，就不会执行render()方法，componentWillUpdate和componentDidUpdate方法也不会被调用<br>默认情况下，shouldComponentUpdate方法返回true防止state快速变化时的问题，但是如果·state不变，props只读，可以直接覆盖shouldComponentUpdate用于比较props和state的变化，决定UI是否更新，当组件比较多时，使用这个方法能有效提高应用性能</p>\n<h2 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a>componentWillUpdate</h2><p>void componentWillUpdate(<br>  object nextProps, object nextState<br>)<br>当props和state发生变化时执行，并且在render方法之前执行，当然初始化render时不执行该方法，需要特别注意的是，在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。紧接着这个函数，就会调用render()来更新界面了</p>\n<h2 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h2><p>void componentDidUpdate(<br>  object prevProps, object prevState<br>)<br>组件更新结束之后执行，在初始化render时不执行</p>\n<h2 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h2><p>void componentWillReceiveProps(<br>  object nextProps<br>)<br>当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用<br>componentWillReceiveProps: function(nextProps) {<br>  this.setState({<br>likesIncreasing: nextProps.likeCount > this.props.likeCount<br>  });<br>}</p>\n<h2 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h2><p>void componentWillUnmount()<br>当组件要被从界面上移除的时候，就会调用componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于组件挂载的经典的图片：<br><img src=\"http://p09eeagrw.bkt.clouddn.com/1106982-20170811224737742-1564011484.jpg\" alt=\"\"></p>\n<p>下面一一说一下这几个生命周期的意义：</p>\n<h2 id=\"getDefaultProps\"><a href=\"#getDefaultProps\" class=\"headerlink\" title=\"getDefaultProps\"></a>getDefaultProps</h2><p>object getDefaultProps()<br>执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的<br>这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制</p>\n<h2 id=\"getInitialState\"><a href=\"#getInitialState\" class=\"headerlink\" title=\"getInitialState\"></a>getInitialState</h2><p>object getInitialState()<br>控件加载之前执行，返回值会被用于state的初始化值</p>\n<h2 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount\"></a>componentWillMount</h2><p>void componentWillMount()<br>执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次</p>\n<h2 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h2><p>ReactElement render()<br>render的时候会调用render()会被调用<br>调用render()方法时，首先检查this.props和this.state返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现<br>如果不想渲染可以返回null或者false，这种场景下，react渲染一个\\<noscript\\>标签，当返回null或者false时，ReactDOM.findDOMNode(this)返回null<br>render()方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互，如果必须如服务器交互，在componentDidMount()方法中实现或者其他生命周期的方法中实现，保持render()方法纯净使得服务器更准确，组件更简单</noscript\\></p>\n<h2 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h2><p>void componentDidMount()<br>在初始化render之后只执行一次，在这个方法内，可以访问任何组件，componentDidMount()方法中的子组件在父组件之前执行<br>从这个函数开始，就可以和 js 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求</p>\n<h2 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h2><p>boolean shouldComponentUpdate(<br>  object nextProps, object nextState<br>}<br>这个方法在初始化render时不会执行，当props或者state发生变化时执行，并且是在render之前，当新的props或者state不需要更新组件时，返回false<br>shouldComponentUpdate: function(nextProps, nextState) {<br>  return nextProps.id !== this.props.id;<br>}<br>当shouldComponentUpdate方法返回false时，就不会执行render()方法，componentWillUpdate和componentDidUpdate方法也不会被调用<br>默认情况下，shouldComponentUpdate方法返回true防止state快速变化时的问题，但是如果·state不变，props只读，可以直接覆盖shouldComponentUpdate用于比较props和state的变化，决定UI是否更新，当组件比较多时，使用这个方法能有效提高应用性能</p>\n<h2 id=\"componentWillUpdate\"><a href=\"#componentWillUpdate\" class=\"headerlink\" title=\"componentWillUpdate\"></a>componentWillUpdate</h2><p>void componentWillUpdate(<br>  object nextProps, object nextState<br>)<br>当props和state发生变化时执行，并且在render方法之前执行，当然初始化render时不执行该方法，需要特别注意的是，在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。紧接着这个函数，就会调用render()来更新界面了</p>\n<h2 id=\"componentDidUpdate\"><a href=\"#componentDidUpdate\" class=\"headerlink\" title=\"componentDidUpdate\"></a>componentDidUpdate</h2><p>void componentDidUpdate(<br>  object prevProps, object prevState<br>)<br>组件更新结束之后执行，在初始化render时不执行</p>\n<h2 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h2><p>void componentWillReceiveProps(<br>  object nextProps<br>)<br>当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用<br>componentWillReceiveProps: function(nextProps) {<br>  this.setState({<br>likesIncreasing: nextProps.likeCount > this.props.likeCount<br>  });<br>}</p>\n<h2 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h2><p>void componentWillUnmount()<br>当组件要被从界面上移除的时候，就会调用componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p>\n"},{"title":"filter配置跨域访问","date":"2017-11-20T08:16:01.000Z","_content":"\n## Java代码：\n### CommonInterceptor.java\n```java\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\n\npublic class CommonInterceptor implements HandlerInterceptor {\n    private List<String> excludedUrls;\n\n    public List<String> getExcludedUrls() {\n        return excludedUrls;\n    }\n\n    public void setExcludedUrls(List<String> excludedUrls) {\n        this.excludedUrls = excludedUrls;\n    }\n\n    /**\n     * 在业务处理器处理请求之前被调用 如果返回false\n     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),\n     * 再退出拦截器链, 如果返回true 执行下一个拦截器,\n     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller\n     * 然后进入拦截器链,\n     * 从最后一个拦截器往回执行所有的postHandle()\n     * 接着再从最后一个拦截器往回执行所有的afterCompletion()\n     *\n     * @param request\n     * @param response\n     */\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"*\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\");\n        return true;\n    }\n\n    // 在业务处理器处理请求执行完成后,生成视图之前执行的动作\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    /**\n     * 在DispatcherServlet完全处理完请求后被调用\n     * 当有拦截器抛出异常时,\n     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()\n     *\n     * @param request\n     * @param response\n     * @param handler\n     */\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n}\n```\n### ServletContextConfig.java\n```java\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\n\npublic class CommonInterceptor implements HandlerInterceptor {\n    private List<String> excludedUrls;\n\n    public List<String> getExcludedUrls() {\n        return excludedUrls;\n    }\n\n    public void setExcludedUrls(List<String> excludedUrls) {\n        this.excludedUrls = excludedUrls;\n    }\n\n    /**\n     * 在业务处理器处理请求之前被调用 如果返回false\n     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),\n     * 再退出拦截器链, 如果返回true 执行下一个拦截器,\n     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller\n     * 然后进入拦截器链,\n     * 从最后一个拦截器往回执行所有的postHandle()\n     * 接着再从最后一个拦截器往回执行所有的afterCompletion()\n     *\n     * @param request\n     * @param response\n     */\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"*\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\");\n        return true;\n    }\n\n    // 在业务处理器处理请求执行完成后,生成视图之前执行的动作\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    /**\n     * 在DispatcherServlet完全处理完请求后被调用\n     * 当有拦截器抛出异常时,\n     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()\n     *\n     * @param request\n     * @param response\n     * @param handler\n     */\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n}\n```","source":"_posts/filter配置跨域访问.md","raw":"---\ntitle: filter配置跨域访问\ndate: 2017-11-20 16:16:01\ntags:\n- filter\n- 跨域\ncategories: 后端\n---\n\n## Java代码：\n### CommonInterceptor.java\n```java\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\n\npublic class CommonInterceptor implements HandlerInterceptor {\n    private List<String> excludedUrls;\n\n    public List<String> getExcludedUrls() {\n        return excludedUrls;\n    }\n\n    public void setExcludedUrls(List<String> excludedUrls) {\n        this.excludedUrls = excludedUrls;\n    }\n\n    /**\n     * 在业务处理器处理请求之前被调用 如果返回false\n     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),\n     * 再退出拦截器链, 如果返回true 执行下一个拦截器,\n     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller\n     * 然后进入拦截器链,\n     * 从最后一个拦截器往回执行所有的postHandle()\n     * 接着再从最后一个拦截器往回执行所有的afterCompletion()\n     *\n     * @param request\n     * @param response\n     */\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"*\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\");\n        return true;\n    }\n\n    // 在业务处理器处理请求执行完成后,生成视图之前执行的动作\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    /**\n     * 在DispatcherServlet完全处理完请求后被调用\n     * 当有拦截器抛出异常时,\n     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()\n     *\n     * @param request\n     * @param response\n     * @param handler\n     */\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n}\n```\n### ServletContextConfig.java\n```java\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.List;\n\npublic class CommonInterceptor implements HandlerInterceptor {\n    private List<String> excludedUrls;\n\n    public List<String> getExcludedUrls() {\n        return excludedUrls;\n    }\n\n    public void setExcludedUrls(List<String> excludedUrls) {\n        this.excludedUrls = excludedUrls;\n    }\n\n    /**\n     * 在业务处理器处理请求之前被调用 如果返回false\n     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),\n     * 再退出拦截器链, 如果返回true 执行下一个拦截器,\n     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller\n     * 然后进入拦截器链,\n     * 从最后一个拦截器往回执行所有的postHandle()\n     * 接着再从最后一个拦截器往回执行所有的afterCompletion()\n     *\n     * @param request\n     * @param response\n     */\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        response.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"*\");\n        response.setHeader(\"Access-Control-Max-Age\", \"3600\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\");\n        return true;\n    }\n\n    // 在业务处理器处理请求执行完成后,生成视图之前执行的动作\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    /**\n     * 在DispatcherServlet完全处理完请求后被调用\n     * 当有拦截器抛出异常时,\n     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()\n     *\n     * @param request\n     * @param response\n     * @param handler\n     */\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n}\n```","slug":"filter配置跨域访问","published":1,"updated":"2017-12-19T10:00:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjxv000hxqs60fmwg607","content":"<h2 id=\"Java代码：\"><a href=\"#Java代码：\" class=\"headerlink\" title=\"Java代码：\"></a>Java代码：</h2><h3 id=\"CommonInterceptor-java\"><a href=\"#CommonInterceptor-java\" class=\"headerlink\" title=\"CommonInterceptor.java\"></a>CommonInterceptor.java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; excludedUrls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">getExcludedUrls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setExcludedUrls</span><span class=\"params\">(List&lt;String&gt; excludedUrls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excludedUrls = excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在业务处理器处理请求之前被调用 如果返回false</span></span><br><span class=\"line\"><span class=\"comment\">     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),</span></span><br><span class=\"line\"><span class=\"comment\">     * 再退出拦截器链, 如果返回true 执行下一个拦截器,</span></span><br><span class=\"line\"><span class=\"comment\">     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller</span></span><br><span class=\"line\"><span class=\"comment\">     * 然后进入拦截器链,</span></span><br><span class=\"line\"><span class=\"comment\">     * 从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着再从最后一个拦截器往回执行所有的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Methods\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Max-Age\"</span>, <span class=\"string\">\"3600\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Headers\"</span>, <span class=\"string\">\"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在业务处理器处理请求执行完成后,生成视图之前执行的动作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在DispatcherServlet完全处理完请求后被调用</span></span><br><span class=\"line\"><span class=\"comment\">     * 当有拦截器抛出异常时,</span></span><br><span class=\"line\"><span class=\"comment\">     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ServletContextConfig-java\"><a href=\"#ServletContextConfig-java\" class=\"headerlink\" title=\"ServletContextConfig.java\"></a>ServletContextConfig.java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; excludedUrls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">getExcludedUrls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setExcludedUrls</span><span class=\"params\">(List&lt;String&gt; excludedUrls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excludedUrls = excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在业务处理器处理请求之前被调用 如果返回false</span></span><br><span class=\"line\"><span class=\"comment\">     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),</span></span><br><span class=\"line\"><span class=\"comment\">     * 再退出拦截器链, 如果返回true 执行下一个拦截器,</span></span><br><span class=\"line\"><span class=\"comment\">     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller</span></span><br><span class=\"line\"><span class=\"comment\">     * 然后进入拦截器链,</span></span><br><span class=\"line\"><span class=\"comment\">     * 从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着再从最后一个拦截器往回执行所有的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Methods\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Max-Age\"</span>, <span class=\"string\">\"3600\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Headers\"</span>, <span class=\"string\">\"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在业务处理器处理请求执行完成后,生成视图之前执行的动作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在DispatcherServlet完全处理完请求后被调用</span></span><br><span class=\"line\"><span class=\"comment\">     * 当有拦截器抛出异常时,</span></span><br><span class=\"line\"><span class=\"comment\">     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java代码：\"><a href=\"#Java代码：\" class=\"headerlink\" title=\"Java代码：\"></a>Java代码：</h2><h3 id=\"CommonInterceptor-java\"><a href=\"#CommonInterceptor-java\" class=\"headerlink\" title=\"CommonInterceptor.java\"></a>CommonInterceptor.java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; excludedUrls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">getExcludedUrls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setExcludedUrls</span><span class=\"params\">(List&lt;String&gt; excludedUrls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excludedUrls = excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在业务处理器处理请求之前被调用 如果返回false</span></span><br><span class=\"line\"><span class=\"comment\">     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),</span></span><br><span class=\"line\"><span class=\"comment\">     * 再退出拦截器链, 如果返回true 执行下一个拦截器,</span></span><br><span class=\"line\"><span class=\"comment\">     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller</span></span><br><span class=\"line\"><span class=\"comment\">     * 然后进入拦截器链,</span></span><br><span class=\"line\"><span class=\"comment\">     * 从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着再从最后一个拦截器往回执行所有的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Methods\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Max-Age\"</span>, <span class=\"string\">\"3600\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Headers\"</span>, <span class=\"string\">\"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在业务处理器处理请求执行完成后,生成视图之前执行的动作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在DispatcherServlet完全处理完请求后被调用</span></span><br><span class=\"line\"><span class=\"comment\">     * 当有拦截器抛出异常时,</span></span><br><span class=\"line\"><span class=\"comment\">     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ServletContextConfig-java\"><a href=\"#ServletContextConfig-java\" class=\"headerlink\" title=\"ServletContextConfig.java\"></a>ServletContextConfig.java</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; excludedUrls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">getExcludedUrls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setExcludedUrls</span><span class=\"params\">(List&lt;String&gt; excludedUrls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.excludedUrls = excludedUrls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在业务处理器处理请求之前被调用 如果返回false</span></span><br><span class=\"line\"><span class=\"comment\">     * 从当前的拦截器往回执行所有拦截器的afterCompletion(),</span></span><br><span class=\"line\"><span class=\"comment\">     * 再退出拦截器链, 如果返回true 执行下一个拦截器,</span></span><br><span class=\"line\"><span class=\"comment\">     * 直到所有的拦截器都执行完毕 再执行被拦截的Controller</span></span><br><span class=\"line\"><span class=\"comment\">     * 然后进入拦截器链,</span></span><br><span class=\"line\"><span class=\"comment\">     * 从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class=\"line\"><span class=\"comment\">     * 接着再从最后一个拦截器往回执行所有的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Methods\"</span>, <span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Max-Age\"</span>, <span class=\"string\">\"3600\"</span>);</span><br><span class=\"line\">        response.setHeader(<span class=\"string\">\"Access-Control-Allow-Headers\"</span>, <span class=\"string\">\"Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在业务处理器处理请求执行完成后,生成视图之前执行的动作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在DispatcherServlet完全处理完请求后被调用</span></span><br><span class=\"line\"><span class=\"comment\">     * 当有拦截器抛出异常时,</span></span><br><span class=\"line\"><span class=\"comment\">     * 会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"git reset revert 回退回滚取消提交返回上一版本","data":"2017-12-07T02:05:01.000Z","_content":"\n总有一天你会遇到下面的问题.\n(1)改完代码匆忙提交,上线发现有问题,怎么办? 赶紧回滚.\n(2)改完代码测试也没有问题,但是上线发现你的修改影响了之前运行正常的代码报错,必须回滚.\n\n这些开发中很常见的问题,所以git的取消提交,回退甚至返回上一版本都是特别重要的.\n大致分为下面2种情况:  \n\n1.没有push\n这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令\nreset\ngit reset [--soft | --mixed | --hard\n]()\n上面常见三种类型  \n\n--mixed\n会保留源码,只是将git commit和index 信息回退到了某个版本.\ngit reset 默认是 --mixed 模式 \ngit reset --mixed  等价于  git reset  \n\n--soft\n保留源码,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.\n\n--hard\n源码也会回退到某个版本,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)\n当然有人在push代码以后,也使用 reset --hard \\<commit...\\> 回退代码到某个版本之前,但是这样会有一个问题,你线上的代码没有变,线上commit,index都没有变,当你把本地代码修改完提交的时候你会发现权是冲突.....\n所以,这种情况你要使用下面的方式\n\n2.已经push\n对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令\n\nrevert\ngit revert用于反转提交,执行evert命令时要求工作树必须是干净的.\ngit revert用一个新提交来消除一个历史提交所做的任何修改.\nrevert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)\n\nrevert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.\ngit revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61\n通常,前几位即可\ngit revert c011eb3\n\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit\n看似达到的效果是一样的,其实完全不同.\n第一:\n上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.\n第二:\n如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.\n第三:\nreset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.\n\n","source":"_posts/git reset revert 回退回滚取消提交返回上一版本.md","raw":"---\ntitle: git reset revert 回退回滚取消提交返回上一版本\ndata:  2017-12-7 10:05:01\ntag:\n- Git\ncategories: Git\n---\n\n总有一天你会遇到下面的问题.\n(1)改完代码匆忙提交,上线发现有问题,怎么办? 赶紧回滚.\n(2)改完代码测试也没有问题,但是上线发现你的修改影响了之前运行正常的代码报错,必须回滚.\n\n这些开发中很常见的问题,所以git的取消提交,回退甚至返回上一版本都是特别重要的.\n大致分为下面2种情况:  \n\n1.没有push\n这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令\nreset\ngit reset [--soft | --mixed | --hard\n]()\n上面常见三种类型  \n\n--mixed\n会保留源码,只是将git commit和index 信息回退到了某个版本.\ngit reset 默认是 --mixed 模式 \ngit reset --mixed  等价于  git reset  \n\n--soft\n保留源码,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.\n\n--hard\n源码也会回退到某个版本,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)\n当然有人在push代码以后,也使用 reset --hard \\<commit...\\> 回退代码到某个版本之前,但是这样会有一个问题,你线上的代码没有变,线上commit,index都没有变,当你把本地代码修改完提交的时候你会发现权是冲突.....\n所以,这种情况你要使用下面的方式\n\n2.已经push\n对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令\n\nrevert\ngit revert用于反转提交,执行evert命令时要求工作树必须是干净的.\ngit revert用一个新提交来消除一个历史提交所做的任何修改.\nrevert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)\n\nrevert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.\ngit revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61\n通常,前几位即可\ngit revert c011eb3\n\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit\n看似达到的效果是一样的,其实完全不同.\n第一:\n上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.\n第二:\n如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.\n第三:\nreset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.\n\n","slug":"git reset revert 回退回滚取消提交返回上一版本","published":1,"date":"2017-12-07T02:05:01.000Z","updated":"2017-12-07T02:06:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjy1000ixqs6nzffymgn","content":"<p>总有一天你会遇到下面的问题.<br>(1)改完代码匆忙提交,上线发现有问题,怎么办? 赶紧回滚.<br>(2)改完代码测试也没有问题,但是上线发现你的修改影响了之前运行正常的代码报错,必须回滚.</p>\n<p>这些开发中很常见的问题,所以git的取消提交,回退甚至返回上一版本都是特别重要的.<br>大致分为下面2种情况:  </p>\n<p>1.没有push<br>这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令<br>reset<br>git reset <a href=\"\">–soft | –mixed | –hard\n</a><br>上面常见三种类型  </p>\n<p>–mixed<br>会保留源码,只是将git commit和index 信息回退到了某个版本.<br>git reset 默认是 –mixed 模式<br>git reset –mixed  等价于  git reset  </p>\n<p>–soft<br>保留源码,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.</p>\n<p>–hard<br>源码也会回退到某个版本,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)<br>当然有人在push代码以后,也使用 reset –hard \\<commit...\\> 回退代码到某个版本之前,但是这样会有一个问题,你线上的代码没有变,线上commit,index都没有变,当你把本地代码修改完提交的时候你会发现权是冲突…..<br>所以,这种情况你要使用下面的方式</commit...\\></p>\n<p>2.已经push<br>对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令</p>\n<p>revert<br>git revert用于反转提交,执行evert命令时要求工作树必须是干净的.<br>git revert用一个新提交来消除一个历史提交所做的任何修改.<br>revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)</p>\n<p>revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.<br>git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61<br>通常,前几位即可<br>git revert c011eb3</p>\n<p>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit<br>看似达到的效果是一样的,其实完全不同.<br>第一:<br>上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.<br>第二:<br>如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.<br>第三:<br>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>总有一天你会遇到下面的问题.<br>(1)改完代码匆忙提交,上线发现有问题,怎么办? 赶紧回滚.<br>(2)改完代码测试也没有问题,但是上线发现你的修改影响了之前运行正常的代码报错,必须回滚.</p>\n<p>这些开发中很常见的问题,所以git的取消提交,回退甚至返回上一版本都是特别重要的.<br>大致分为下面2种情况:  </p>\n<p>1.没有push<br>这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令<br>reset<br>git reset <a href=\"\">–soft | –mixed | –hard\n</a><br>上面常见三种类型  </p>\n<p>–mixed<br>会保留源码,只是将git commit和index 信息回退到了某个版本.<br>git reset 默认是 –mixed 模式<br>git reset –mixed  等价于  git reset  </p>\n<p>–soft<br>保留源码,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.</p>\n<p>–hard<br>源码也会回退到某个版本,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)<br>当然有人在push代码以后,也使用 reset –hard \\<commit...\\> 回退代码到某个版本之前,但是这样会有一个问题,你线上的代码没有变,线上commit,index都没有变,当你把本地代码修改完提交的时候你会发现权是冲突…..<br>所以,这种情况你要使用下面的方式</commit...\\></p>\n<p>2.已经push<br>对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令</p>\n<p>revert<br>git revert用于反转提交,执行evert命令时要求工作树必须是干净的.<br>git revert用一个新提交来消除一个历史提交所做的任何修改.<br>revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)</p>\n<p>revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.<br>git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61<br>通常,前几位即可<br>git revert c011eb3</p>\n<p>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit<br>看似达到的效果是一样的,其实完全不同.<br>第一:<br>上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.<br>第二:<br>如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.<br>第三:<br>reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.</p>\n"},{"title":"git教程","date":"2017-11-20T08:16:01.000Z","_content":"\n# EAST项目部署常见问题\n## 项目启动报错\n1. 保证服务器jdk版本为1.8以上\n2. 首次部署仅将fitech.war,platform.war和libs.war放入服务器中间件中，防止日志太多，异常不容易排查\n2. 查看服务器日志，发现connection异常，检查fitech中的数据库配置是否正确\n\n## 用户登录异常\n1. 检查数据脚本都正常执行了，可查看select \\* from sysuser是否有数据\n2. 访问浏览器控制台，F12，登录一下看看是否有异常，如果是404，检查platform中的fitech.js是否修改成功\n\n## 登录之后系统常见问题\n1. 不要随意直接在数据库中修改数据，会导致页面显示有问题，如果实在想操作，请先询问产品开发\n2. 系统配置中的制度配置导入时间比较久，耐心等待一会，重复导入可能会导致数据问题，查看是否成功，可在报文配置中查看数据表\n\\3. \n\n## ETL数据调度常见问题\n> 新平台EAST需要配置3个作业才可以正常运行  \n> - 数据补录作业\n1. 数据补录系统待上报报文流程存储过程（east.create\\_bl\\_task|系统内置）\n2. 数据补录系统流程开启任务（JAVA任务）\n3. EAST收据调度作业\n1. EAST待上报报文流程存储过程（east.proc\\_ledgerReport|系统内置）  \n2. 数据拉取存储过程（客户现场人员编写）  \n3. EAST流程开启任务（JAVA任务）\n7. EAST报文生成作业\n1. EAST上报报文生成任务（JAVA任务）\n\n1. 安装部署手册中的案例都是范例，请根据实际情况进行配置\n2. 调度任务有没有成功执行，可以查看控制台日志是否执行成功\n3. 数据库连接异常，可查看fitech-etl-1.0.war是否配置成功\n4. 出现数组越界，可能是作业中的任务配置有问题，可截图发给开发排查问题\n5. ETL会根据配置频度来控制执行状态，例如日频度，则当天只能执行一次，如果想多次执行，则到数据调度监控中重新执行作业，或者执行SQL手动删除ETL调度任务 例如：\n\n```ruby\nselect * from etl_job_monitor;\nselect * from ETL_TASK_MONITOR;\n\ndelete from ETL_JOB_MONITOR where yxrq = '20171020';\ndelete from ETL_TASK_MONITOR where yxrq = '20171020';\ncommit;\n```\n# EAST项目部署手册\n## 服务器环境\n- 数据库（如果是oracle需要安装oracle客户端，用作sqluldr2报文生成）\n- jdk1.8以上\n- 服务器中间件（需要支持jdk1.8）\n\n## 项目说明\n> 项目分成4个子服务，由于模块之间有相互调用，需要分先后启动，分别配置\n\n- fitech.war\n_平台主服务,处理平台业务逻辑_\n- fitech-etl-1.0.war\n_ETL调度系统服务，处理数据抽取等调度任务_\n- platform.war\n_前端主服务_\n- libs.war\n_前端框架lib包_\n\n\n\n## 项目部署\n#### 主服务部署配置\n- 将fitech.war放入服务中间件\n- 修改服务配置文件application-env.properties\n![配置文件所在位置][image-1]\n- 需要修改的配置\n![输入图片说明][image-2] \n \n1. 数据库配置，修改对应IP,端口和监听，以及用户名和密码\n2. initPassword是系统创建用户初始化密码的默认密码，根据需求修改\n3. template\\_path是系统模板存放路径，用于机构，用户等功能的模板下载\n4. ledgerRptFIle\\_tempPath和ledgerRptFIle\\_path是EAST生成报文存放的路径和临时文件生成的存放路径\n5. DBurl是sqluldr2报文生成数据链接配置\n\n#### 客户端部署配置\n- 将platform.war和libs.war放入服务中间件\n- 修改配置文件fitech.js\n![放置路径][image-3]\n![输入图片说明][image-4]\n1. pathcs是配置ETL调度系统地址\n2. path是配置主服务地址(包括服务项目名)\n\n#### 创建数据库表\n- _启动服务，主服务会自动创建系统表_ \n- [下载脚本][1]\n- 执行初始化数据  \n- EAST3.0初始化脚本.sql（初始化条线，角色等基础信息）\n- EAST脱敏函数.sql（初始化脱敏函数，复制该脚本中的函数依次执行）  \n- EAST脱敏公式.sql（初始化脱敏公式）\n- 拉链表存储过程.sql（初始化拉链表存储过程，复制该脚本中的存储过程依次执行）\n- ETL初始化脚本.sql（初始化ETL基础数据）\n- ETL存储过程.sql（ETL存储过程）\n- ETD指标建表语句.sql（根据需求执行，免费的10个指标）\n- ETD初始化数据.sql（根据需求执行，免费的10个指标）\n- 数据补录系统存储过程.sql（数据补录系统存储过程）\n- 数据补录初始化脚本.sql（数据补录系统初始化脚本）\n- 初始化EAST3.0校验公式（validata\\_rule05.sql脚本中有N个变量，根据提示进行输入。输入&&+变量,如：&&CHANGE）\n- 将template文件夹下的excel放到application-env.properties配置文件下的template\\_path路径下，用于模板下载\n\n#### 启动项目\n- 启动服务器中间件\n- 打开浏览器访问http://IP:port/platform\n- 访问成功，点击登录使用superadmin登录，密码123456进行登录\n\n#### 配置业务制度\n- 进入系统配置》制度管理\n![输入图片说明][image-5]\n- 进入银监标准化业务条线》手工配置\n![输入图片说明][image-6]\n- 新增一个制度\n![输入图片说明][image-7]\n- 点击批量载入，选择系统导入文件夹下的EASTtemplate0530.xlsx和fields.xlsx，点击确定，待导入完成后，可生成EAST的58张数据表\n![输入图片说明][image-8]\n- 进入报文配置功能，查看报文是否生成成功，如果成功可进入操作手册进行机构，用户，角色等业务配置\n\n#### 数据配置\n- 系统需要现场实施人员根据客户现场情况创建机构，角色和用户信息\n- 机构信息配置\n- 角色信息配置\n- 用户信息配置\n- 流程信息配置（重要，ETL数据调度流程需要此步骤）  \n\t [详见用户操作手册][2]\n\n#### 配置ETL调度任务\n- 进入业务条线 》 数据调度\n![数据调度][image-9]\n- 进入‘作业分类’菜单，新建一个‘作业分类’，用于管理系统调度作业\n- 进入‘作业管理’菜单，在新建的作业分类下创建调度作业，用于数据调度；例如：\n![输入图片说明][image-10]\n1. 新增作业；例如：\n![输入图片说明][image-11]\n> 选择当前调度作业 _目前仅支持shell脚本和存储过程_  \n> 配置作业频度之后，只有满足当前配置的启动条件，调度作业才会启动 _shell和存储过程必须要有回调true/false_  \n\n- 进入‘任务管理’菜单，用于配置调度作业所需要的任务；例如：\n![输入图片说明][image-12]  \n- 选择任务类型新建任务  \n1.新建procedure存储过程任务；例如：\n![输入图片说明][image-13]  \n_所有的存储过程必须要有回调函数true/false;例如：_\n\n```ruby\ncreate or replace procedure testproc(term in VARCHAR2, result OUT varchar)\nas\n  CURSOR c1 IS\nselect l.id, t.tablename, i.institutionid\n      from ledgerreport l\n      left join ledgerrpttemplate t\n        on l.ledgerreporttemplate_id = t.id\n      left join institution i\n        on l.institution_id = i.id\n     where l.submitstatetype = '2'\n       and l.term = term\n       and  i.institutionid='3011';\nbegin\nFOR acct IN c1 LOOP\n   update test.t_gx_ygb set reportid = acct.id\n\n where nbjgh = '3011';\n  insert into yjbzh.t_gx_ygb\n    select SEQ_FITECH.nextval id,REPORTID,CJRQ,GWBH,YGZT,YXJGMC,ZW,YXJGDM,SFZH,XM,JRXKZH,SSBM,WDH,LXDH,GH,NBJGH,SYNCABLE from test.t_gx_ygb;\n    END LOOP;\n  commit;\n  result := 'true';\nexception\n  when storage_error then\n    result := 'false';\n  when others then\n    result := 'false';\nend testproc;\n\n```\n\n\n2.新加java调度任务；例如：\n![输入图片说明][image-14]\n> 新平台EAST需要配置3个作业才可以正常运行  \n> - 数据补录作业\n1. 数据补录系统待上报报文流程存储过程（east.create\\_bl\\_task|系统内置）\n2. 数据补录系统流程开启任务（JAVA任务）\n3. EAST收据调度作业\n1. EAST待上报报文流程存储过程（east.proc\\_ledgerReport|系统内置）  \n2. 数据拉取存储过程（客户现场人员编写）  \n3. EAST流程开启任务（JAVA任务）\n7. EAST报文生成作业\n1. EAST上报报文生成任务（JAVA任务）\n\n_作业任务为Java任务的实例如下_\n- EAST流程开启任务（POST请求）  \n\t\\`\\`\\`ruby\n类名：com.fitechsoft.util.HttpRequest\n方法名：sendPost\nURL：http://IP:端口/项目名/task/startProcess/\n```\n- EAST上报报文生成任务（GET请求）  \n```ruby\n类名：com.fitechsoft.util.HttpRequest\n方法名：sendGet\nURL：http://IP:端口/项目名/ledgerReportFile/reportFileGenerated/create\n```\n- 数据补录系统流程开启任务（POST请求）\n```ruby\n类名：com.fitechsoft.util.HttpRequest\n方法名：sendPost\nURL:http://IP:端口/项目名/accountTask/startProcess/\n```\n\n- 进入‘作业管理’ 将任务管理中创建的任务配置到作业中\n- 选择你要维护的作业，点击作业维护\n![输入图片说明][image-15]\n2. 添加新步骤，将任务配置到作业管理中\n![输入图片说明][image-16]\n\n#### 部署ETL调度任务\n- 将fitech-etl-1.0.war放入应用服务器中间件中\n- 修改ETL系统配置\n![输入图片说明][image-17]\n- config.properties 修改ETL调度任务配置数据库\n![输入图片说明][image-18]\n- config1.properties 修改ETL调度任务存储过程数据表配置\n![输入图片说明][image-19]\n- 启动服务，控制台正常启动即可，操作员登录系统，查看代办任务是否有数据，有数据即可\n# Home\n1. [新平台activiti参数说明][3]\n2. [git安装教程][4]\n3. [新平台开发手册][5]\n# git安装教程\n### 安装介质\n- Git-1.9.5-preview20150319.exe\n- TortoiseGit-1.8.14.0-64bit.msi\n- Tor4toiseGit-LanguagePack-1.8.14.0-64bit-zh\\_CN.msi  \n\t[下载][6]\n\n### 基本配置\n1. 配置SSH密钥\n![配置SSH密钥][image-20]\n2. 找到生成的git授权KEY,路径默认生成在 _C:\\Users\\rui\\.ssh_\n![git授权KEY][image-21]\n3. 配置TortoiseGit\n![输入图片说明][image-22]\n![输入图片说明][image-23]\n![输入图片说明][image-24]\n\n### 常用语法\n- 查看当前git仓库获取和提交服务地址\n``` ruby\ngit remote -v\n```\n- 查看所有分支\n``` ruby\ngit branch\n```\n- 创建分支\n``` ruby\ngit branch dev\n```\n- 删除分支\n``` ruby\ngit branch -d dev\n```\n- 切换分支\n``` ruby\ngit checkout dev\n```\n- 创建并切换\n``` ruby\ngit checkout -b dev\n```\n- 查看工作区修改文件\n``` ruby\ngit status\n```\n- 查看修改内容\n``` ruby\ngit diff\n```\n- 添加修改到缓存区\n``` ruby\ngit add ***\ngit add -A\n```\n- 版本提交\n``` ruby\ngit commit -m \"branch test\"\n```\n- 合并分支dev到当前分支\n``` ruby\ngit merge dev\n```\n- 指定定远程版本更新到本地指定版本\n``` ruby\ngit pull <远程主机名> <远程分支名>:<本地分支名>\ngit pull origin dev:master\n```\n- 将当前分支提交到远程分支\n``` ruby\ngit push <远程主机名> <远程分支名>\ngit push origin dev\n```\n- 切换git地址\n``` ruby\n1. git remote rm origin\n2. git remote add origin git@github.com:yuquan0821/demo.git\n3. git push origin\n```\n **GIT教程** \n- [网络教程][7]\n\n# oracle数据导出工具sqluldr2配置\n### 安装步骤\n1. 由于sqluldr2是基于oracle客户端的一个插件，则需要在平台服务端安装oracle\\_client\n2. 下载sqluldr2.bin（根据操作系统自行判定版本）到$ORACLE\\_HOME的bin目录，重命名为sqluldr2.bin\n3. 修改oracle安装$HOME目录下.bash\\_profile 增加如下环境变量\n```ruby\nexport LD_LIBRARY_PATH=$ORACLE_HOME/bin:$ORACLE_HOME/lib:/lib:/usr/lib \n```\n4. 执行 sqluldr2.bin 执行成功即可\n# 新平台activiti参数说明\n### activiti配置\n1. 新建bpmn流程\n2. 绘制流程图，具体画法网上有\n3. 设置流程参数\n\t- 配置流程图ID ; name ; namespaces属性（自定义）;\n![输入图片说明][image-25]\n\t- 配置启动监听（该监听为自定义，平台已经初始化一个，无特殊需求可直接使用）\n![输入图片说明][image-26]\n\t- 配置任务节点属性\n\t  1. 配置ID和name(此ID有特殊用处)\n![输入图片说明][image-27]\n\t  2. 配置指派角色和督办角色，\n\t    - 变量规则：${任务节点ID_assignee};${任务节点ID_supervise}\n![输入图片说明][image-28]\n\t  3. 设置任务节点参数\n\t    - argname: 路由KEY，固定为input\n\t    - argvalues: 页面按钮参数，几个路由跳转几个参数，可自定义\n\t    - handleEntry 当前任务节点页面路由地址\n\t    - completeEntry 暂时为空，预留\n\t    - isAssign:是否支持任务转派， ${任务节点ID_isAssign}\n![输入图片说明][image-29]\n\t  4. 路由扭转控制参数\n\t    - 设定页面跳转路由参数${input=='refuse'}\n\t    - 说明 input:为步骤三中argname 的参数，无明显需求暂统一定义为input\n\t    - 说明'refuse' 为步骤三中argvalues参数中定义的value，指定下一节点跳转\n![输入图片说明][image-30]\n# 新平台开发手册\n### 开发环境\n- 开发工具IDE：IntelliJ IDEA/Eclipse\n- 数据库：mysql/oracle\n- JDK:1.8\n- 版本管理工具：GIT\n- 项目管理工具：MAVEN\n\n### 开发规范\n- 项目包名:com.fitech.功能名.项目名\n- 项目类名:\n\t- 领域模型：根据领域模型实际意义创建（能用英文标识的必须使用英文，无法使用英文标识的用拼音首字母创建类名，首字母必须大写)\n\t- 持久化层：领域模型名+Repository\n\t- 业务层：\n\t\t1. 接口：领域模型名+Service\n\t\t2. 实现：领域模型名+ServiceImpl\n\n- 注释:\n- 类名注释：当前类的中文描述+作者  \n\t![类名注释][image-31]\n- 接口名注释：当前接口作用+入参说明+出参说明  \n\t![接口注释][image-32]\n- 业务代码注释：每10行必须有至少有一个注释，业务复杂的3行内要有注释，判断条件（if）必须有注释\n- 预留接口，预留逻辑必须使用//TODO进行标记，并且加上备\n- 如果修改业务逻辑代码，在修改处添加备注，标识修改原因，修改时间和修改人  \n\t![修改说明][image-33]\n\n- 测试用例\n- 每个模块有独立的测试用例配置文件，放置位置在  \n\t![测试用例配置文件][image-34]\n- 每个业务逻辑添加单元测试，测试通过再提交代码  \n\t![测试用例][image-35]\n\n- GIT代码管理\n- 仓库中默认版本master，是我们开发版本\n- 本地更新后，创建本地开发版本dev   (git checkout -b dev)\n- 本地开发完成并测试通过后提交本地仓库\n- 切换版本到master （git checkout master）\n- 更新最新的开发版本\n- 合并DEV版本到master （git merge dev）\n- 确定无冲突之后提交远程仓库\n\n### 技术说明\n- domain说明  \n\t![domain][image-36]\n- 添加注释@entity\n- 主体继承FBSubject,客体继承FBObject\n- 每个字段属性添加@Description(\"角色名称\")注解，方便后期功能扩充\n- service说明  \n\t![service][image-37]\n- 添加@Service注解，加入spring容器管理\n- 添加@ServiceTrace注解，系统会自动管理service接口日志，记录到logback  \n\t![输入图片说明][image-38]\n- 接口的增删改操作需要捕获reporsitory发生的异常，然后throw出appException异常，这个是自定义异常，统一处理系统异常，记录logback,可自定义入参，第一个是异常码，可自定义，第二个是系统异常，可自定义;\n- 对于一个服务接口有2个及以上“增”“删”“改”操作的，需要添加事务@Transactional\n- controller说明  \n\t![controller][image-39]\n- 添加控制层上添加@RequestMapping ，定位当前接口位置，便于后期权限控制  \n\t![输入图片说明][image-40]\n- controller回调GenericResult\\<?\\>封装回调函数，里面有当前请求是否成功，成功状态，异常状态，异常码，数据集对象等，系统回封装成json返回前端;\n- controller中需要记录用户的操作日志，可以只对增删改操作记录，查询根据具体情况记录，addOperateLog第一个为日志信息，自定义，第二个是请求上下文对象，系统需要根据请求上下文获取登录用户信息和IP等;\n- 操作日志需要在finally中记录，防止系统异常没有记录;\n- war 说明\n![war ][image-41]\n1. Activiti.cfg.xml：activiti流程引擎配置\n2. applicationContext-jpa.xml：配置持久化层springdata配置\n3. applicationContext.xml：spring相关配置\n4. Security.cfg.xml：权限框架springsecutity相关配置\n5. secutityAcl.cfg.xml：数据权限acl相关配置\n6. Spring-mvc.xml\n7. Springbatch-content\n8. Application-evn.properties:数据源配置及其他的一些参数配置\n9. Logback.xml：配置系统日志，\n> 注：可根据具体需求进行配置修改\n### 开发注意事项\n1. clean install -Dmaven.test.skip=true 模块编译\n2. jetty:run 项目执行\n### 数据库版本切换\n- 目前系统支持mysql和Oracle数据库，由于制度报文生成接口是由不同数据库语法编写所以在切换数据库的同时要修改对应的数据库方言配置\n- 修改pom.xml  \n\t![输入图片说明][image-42]\n**目前0.0.1-SNAPSHOT版本对应mysql;0.0.2-SNAPSHOT版本对应oracle**\n2. 修改配置文件applicationContext-jpa.xml，改为数据库所对应的接口实现类  \n\t![输入图片说明][image-43]\n3. 如果需要新加SQL实现函数，则在对应的系统模块中添加，例如  \n\t![输入图片说明][image-44]  \n\t实现自己的业务逻辑即可，然后在applicationContext-jpa.xml添加相应配置加入spring管理容器\n\n[1]:\thttps://gitee.com/mpmpal_cr/document/attach_files/download?i=96428&u=http://files.git.oschina.net/group1/M00/01/F4/PaAvDFnExYiAZBwYAAbJgGShKGQ898.rar?token=2fc273a040d2eabf77c760f50eff721b&ts=1506067947&attname=%E6%96%B0%E5%B9%B3%E5%8F%B0%E8%84%9A%E6%9C%AC.rar\n[2]:\thttps://gitee.com/mpmpal_cr/document/attach_files/download?i=98255&u=http://files.git.oschina.net/group1/M00/02/09/PaAvDFnbQGuALm5OAGF7R5HNSdg735.doc?token=a118c827b961e80c623f752ed78eb4d8&ts=1507541099&attname=PD-%E7%A7%91%E8%9E%8D%E7%BB%BC%E5%90%88%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0%E4%BA%A7%E5%93%81-%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C_V1.0_20170928.doc\n[3]:\thttps://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0activiti%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&parent=\n[4]:\thttps://gitee.com/mpmpal_cr/document/wikis/pages?title=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&parent=\n[5]:\thttps://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C&parent=\n[6]:\thttp://gitee.com/mpmpal_cr/document/attach_files/download?i=102945&u=http://files.git.oschina.net/group1/M00/02/3F/PaAvDFn_1fiAEkFDAocAFD5NBjw242.rar?token=3d3e93341027b8450a17c0d4f33afc20&ts=1509938681&attname=Git%2CTortoiseGit%E5%AE%89%E8%A3%85.rar\n[7]:\thttp://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n\n[image-1]:\thttps://git.oschina.net/uploads/images/2017/0922/142804_a619079d_1102706.png \"图片1.png\"\n[image-2]:\thttps://git.oschina.net/uploads/images/2017/0922/142905_7ad5bb2f_1102706.png \"图片2.png\"\n[image-3]:\thttps://git.oschina.net/uploads/images/2017/0922/145015_b3e45198_1102706.png \"图片3.png\"\n[image-4]:\thttps://git.oschina.net/uploads/images/2017/0922/145035_e6b445d0_1102706.png \"图片4.png\"\n[image-5]:\thttps://git.oschina.net/uploads/images/2017/0922/173322_c8830ec5_1102706.png \"5.png\"\n[image-6]:\thttps://git.oschina.net/uploads/images/2017/0922/173652_6afc04b1_1102706.png \"6.png\"\n[image-7]:\thttps://git.oschina.net/uploads/images/2017/0922/173722_7a2ae350_1102706.png \"7.png\"\n[image-8]:\thttps://git.oschina.net/uploads/images/2017/0922/173755_dfcbb075_1102706.png \"8.png\"\n[image-9]:\thttps://git.oschina.net/uploads/images/2017/0925/095221_0b8c5fd0_1102706.png \"9.png\"\n[image-10]:\thttps://git.oschina.net/uploads/images/2017/0925/100741_ab5c641f_1102706.png \"10.png\"\n[image-11]:\thttps://git.oschina.net/uploads/images/2017/0925/101135_d4af3a5b_1102706.png \"11.png\"\n[image-12]:\thttps://git.oschina.net/uploads/images/2017/0925/113253_f27a4429_1102706.png \"12.png\"\n[image-13]:\thttps://git.oschina.net/uploads/images/2017/0925/142839_6cf3572f_1102706.png \"13.png\"\n[image-14]:\thttps://git.oschina.net/uploads/images/2017/0925/144829_27d05efd_1102706.png \"14.png\"\n[image-15]:\thttps://git.oschina.net/uploads/images/2017/0925/151904_7d519dcc_1102706.png \"15.png\"\n[image-16]:\thttps://git.oschina.net/uploads/images/2017/0925/151948_2459f713_1102706.png \"16.png\"\n[image-17]:\thttps://git.oschina.net/uploads/images/2017/0925/153251_aa9e251f_1102706.png \"17.png\"\n[image-18]:\thttps://git.oschina.net/uploads/images/2017/0925/155627_3d96691e_1102706.png \"18.png\"\n[image-19]:\thttps://git.oschina.net/uploads/images/2017/0925/155636_08b12be3_1102706.png \"19.png\"\n[image-20]:\thttps://git.oschina.net/uploads/images/2017/0830/143511_7e9c1265_1102706.png \"clipboard.png\"\n[image-21]:\thttps://git.oschina.net/uploads/images/2017/0830/143750_9390d834_1102706.png \"clipboard.png\"\n[image-22]:\thttps://git.oschina.net/uploads/images/2017/0830/143856_de604f92_1102706.png \"clipboard.png\"\n[image-23]:\thttps://git.oschina.net/uploads/images/2017/0830/144125_814b18db_1102706.png \"clipboard.png\"\n[image-24]:\thttps://git.oschina.net/uploads/images/2017/0830/144156_8ca52887_1102706.png \"clipboard.png\"\n[image-25]:\thttps://git.oschina.net/uploads/images/2017/0809/141007_8649cc82_1102706.png \"1.png\"\n[image-26]:\thttps://git.oschina.net/uploads/images/2017/0809/141102_62ed4ba4_1102706.png \"2.png\"\n[image-27]:\thttps://git.oschina.net/uploads/images/2017/0809/141225_c541dcca_1102706.png \"3.png\"\n[image-28]:\thttps://git.oschina.net/uploads/images/2017/0809/141253_9b67ac6b_1102706.png \"4.png\"\n[image-29]:\thttps://git.oschina.net/uploads/images/2017/0809/141342_3d544a50_1102706.png \"5.png\"\n[image-30]:\thttps://git.oschina.net/uploads/images/2017/0809/141411_478f2512_1102706.png \"6.png\"\n[image-31]:\thttps://git.oschina.net/uploads/images/2017/0830/152051_747dcf5e_1102706.png \"图片1.png\"\n[image-32]:\thttps://git.oschina.net/uploads/images/2017/0830/152154_1cf6e0b1_1102706.png \"图片2.png\"\n[image-33]:\thttps://git.oschina.net/uploads/images/2017/0830/152322_a4b7aeb4_1102706.png \"图片3.png\"\n[image-34]:\thttps://git.oschina.net/uploads/images/2017/0830/152917_14e372ff_1102706.png \"QQ截图20170830152553.png\"\n[image-35]:\thttps://git.oschina.net/uploads/images/2017/0830/152948_01102b7d_1102706.png \"图片4.png\"\n[image-36]:\thttps://git.oschina.net/uploads/images/2017/0830/154423_a15e4a4c_1102706.png \"图片5.png\"\n[image-37]:\thttps://git.oschina.net/uploads/images/2017/0830/160045_4a882daf_1102706.png \"图片6.png\"\n[image-38]:\thttps://git.oschina.net/uploads/images/2017/0830/160703_aa9ffc2f_1102706.png \"图片7.png\"\n[image-39]:\thttps://git.oschina.net/uploads/images/2017/0830/162413_b14e447d_1102706.png \"图片8.png\"\n[image-40]:\thttps://git.oschina.net/uploads/images/2017/0830/163109_0c571fe1_1102706.png \"图片9.png\"\n[image-41]:\thttps://git.oschina.net/uploads/images/2017/0830/163455_5036a5e5_1102706.png \"图片10.png\"\n[image-42]:\thttps://git.oschina.net/uploads/images/2017/0830/164510_7b159611_1102706.png \"图片11.png\"\n[image-43]:\thttps://git.oschina.net/uploads/images/2017/0830/164601_eb23eff4_1102706.png \"图片12.png\"\n[image-44]:\thttps://git.oschina.net/uploads/images/2017/0830/164642_efb5c1a0_1102706.png \"图片13.png\"","source":"_posts/git教程.md","raw":"---\ntitle: git教程\ndate: 2017-11-20 16:16:01\ntags: git\ncategories: 干货\n---\n\n# EAST项目部署常见问题\n## 项目启动报错\n1. 保证服务器jdk版本为1.8以上\n2. 首次部署仅将fitech.war,platform.war和libs.war放入服务器中间件中，防止日志太多，异常不容易排查\n2. 查看服务器日志，发现connection异常，检查fitech中的数据库配置是否正确\n\n## 用户登录异常\n1. 检查数据脚本都正常执行了，可查看select \\* from sysuser是否有数据\n2. 访问浏览器控制台，F12，登录一下看看是否有异常，如果是404，检查platform中的fitech.js是否修改成功\n\n## 登录之后系统常见问题\n1. 不要随意直接在数据库中修改数据，会导致页面显示有问题，如果实在想操作，请先询问产品开发\n2. 系统配置中的制度配置导入时间比较久，耐心等待一会，重复导入可能会导致数据问题，查看是否成功，可在报文配置中查看数据表\n\\3. \n\n## ETL数据调度常见问题\n> 新平台EAST需要配置3个作业才可以正常运行  \n> - 数据补录作业\n1. 数据补录系统待上报报文流程存储过程（east.create\\_bl\\_task|系统内置）\n2. 数据补录系统流程开启任务（JAVA任务）\n3. EAST收据调度作业\n1. EAST待上报报文流程存储过程（east.proc\\_ledgerReport|系统内置）  \n2. 数据拉取存储过程（客户现场人员编写）  \n3. EAST流程开启任务（JAVA任务）\n7. EAST报文生成作业\n1. EAST上报报文生成任务（JAVA任务）\n\n1. 安装部署手册中的案例都是范例，请根据实际情况进行配置\n2. 调度任务有没有成功执行，可以查看控制台日志是否执行成功\n3. 数据库连接异常，可查看fitech-etl-1.0.war是否配置成功\n4. 出现数组越界，可能是作业中的任务配置有问题，可截图发给开发排查问题\n5. ETL会根据配置频度来控制执行状态，例如日频度，则当天只能执行一次，如果想多次执行，则到数据调度监控中重新执行作业，或者执行SQL手动删除ETL调度任务 例如：\n\n```ruby\nselect * from etl_job_monitor;\nselect * from ETL_TASK_MONITOR;\n\ndelete from ETL_JOB_MONITOR where yxrq = '20171020';\ndelete from ETL_TASK_MONITOR where yxrq = '20171020';\ncommit;\n```\n# EAST项目部署手册\n## 服务器环境\n- 数据库（如果是oracle需要安装oracle客户端，用作sqluldr2报文生成）\n- jdk1.8以上\n- 服务器中间件（需要支持jdk1.8）\n\n## 项目说明\n> 项目分成4个子服务，由于模块之间有相互调用，需要分先后启动，分别配置\n\n- fitech.war\n_平台主服务,处理平台业务逻辑_\n- fitech-etl-1.0.war\n_ETL调度系统服务，处理数据抽取等调度任务_\n- platform.war\n_前端主服务_\n- libs.war\n_前端框架lib包_\n\n\n\n## 项目部署\n#### 主服务部署配置\n- 将fitech.war放入服务中间件\n- 修改服务配置文件application-env.properties\n![配置文件所在位置][image-1]\n- 需要修改的配置\n![输入图片说明][image-2] \n \n1. 数据库配置，修改对应IP,端口和监听，以及用户名和密码\n2. initPassword是系统创建用户初始化密码的默认密码，根据需求修改\n3. template\\_path是系统模板存放路径，用于机构，用户等功能的模板下载\n4. ledgerRptFIle\\_tempPath和ledgerRptFIle\\_path是EAST生成报文存放的路径和临时文件生成的存放路径\n5. DBurl是sqluldr2报文生成数据链接配置\n\n#### 客户端部署配置\n- 将platform.war和libs.war放入服务中间件\n- 修改配置文件fitech.js\n![放置路径][image-3]\n![输入图片说明][image-4]\n1. pathcs是配置ETL调度系统地址\n2. path是配置主服务地址(包括服务项目名)\n\n#### 创建数据库表\n- _启动服务，主服务会自动创建系统表_ \n- [下载脚本][1]\n- 执行初始化数据  \n- EAST3.0初始化脚本.sql（初始化条线，角色等基础信息）\n- EAST脱敏函数.sql（初始化脱敏函数，复制该脚本中的函数依次执行）  \n- EAST脱敏公式.sql（初始化脱敏公式）\n- 拉链表存储过程.sql（初始化拉链表存储过程，复制该脚本中的存储过程依次执行）\n- ETL初始化脚本.sql（初始化ETL基础数据）\n- ETL存储过程.sql（ETL存储过程）\n- ETD指标建表语句.sql（根据需求执行，免费的10个指标）\n- ETD初始化数据.sql（根据需求执行，免费的10个指标）\n- 数据补录系统存储过程.sql（数据补录系统存储过程）\n- 数据补录初始化脚本.sql（数据补录系统初始化脚本）\n- 初始化EAST3.0校验公式（validata\\_rule05.sql脚本中有N个变量，根据提示进行输入。输入&&+变量,如：&&CHANGE）\n- 将template文件夹下的excel放到application-env.properties配置文件下的template\\_path路径下，用于模板下载\n\n#### 启动项目\n- 启动服务器中间件\n- 打开浏览器访问http://IP:port/platform\n- 访问成功，点击登录使用superadmin登录，密码123456进行登录\n\n#### 配置业务制度\n- 进入系统配置》制度管理\n![输入图片说明][image-5]\n- 进入银监标准化业务条线》手工配置\n![输入图片说明][image-6]\n- 新增一个制度\n![输入图片说明][image-7]\n- 点击批量载入，选择系统导入文件夹下的EASTtemplate0530.xlsx和fields.xlsx，点击确定，待导入完成后，可生成EAST的58张数据表\n![输入图片说明][image-8]\n- 进入报文配置功能，查看报文是否生成成功，如果成功可进入操作手册进行机构，用户，角色等业务配置\n\n#### 数据配置\n- 系统需要现场实施人员根据客户现场情况创建机构，角色和用户信息\n- 机构信息配置\n- 角色信息配置\n- 用户信息配置\n- 流程信息配置（重要，ETL数据调度流程需要此步骤）  \n\t [详见用户操作手册][2]\n\n#### 配置ETL调度任务\n- 进入业务条线 》 数据调度\n![数据调度][image-9]\n- 进入‘作业分类’菜单，新建一个‘作业分类’，用于管理系统调度作业\n- 进入‘作业管理’菜单，在新建的作业分类下创建调度作业，用于数据调度；例如：\n![输入图片说明][image-10]\n1. 新增作业；例如：\n![输入图片说明][image-11]\n> 选择当前调度作业 _目前仅支持shell脚本和存储过程_  \n> 配置作业频度之后，只有满足当前配置的启动条件，调度作业才会启动 _shell和存储过程必须要有回调true/false_  \n\n- 进入‘任务管理’菜单，用于配置调度作业所需要的任务；例如：\n![输入图片说明][image-12]  \n- 选择任务类型新建任务  \n1.新建procedure存储过程任务；例如：\n![输入图片说明][image-13]  \n_所有的存储过程必须要有回调函数true/false;例如：_\n\n```ruby\ncreate or replace procedure testproc(term in VARCHAR2, result OUT varchar)\nas\n  CURSOR c1 IS\nselect l.id, t.tablename, i.institutionid\n      from ledgerreport l\n      left join ledgerrpttemplate t\n        on l.ledgerreporttemplate_id = t.id\n      left join institution i\n        on l.institution_id = i.id\n     where l.submitstatetype = '2'\n       and l.term = term\n       and  i.institutionid='3011';\nbegin\nFOR acct IN c1 LOOP\n   update test.t_gx_ygb set reportid = acct.id\n\n where nbjgh = '3011';\n  insert into yjbzh.t_gx_ygb\n    select SEQ_FITECH.nextval id,REPORTID,CJRQ,GWBH,YGZT,YXJGMC,ZW,YXJGDM,SFZH,XM,JRXKZH,SSBM,WDH,LXDH,GH,NBJGH,SYNCABLE from test.t_gx_ygb;\n    END LOOP;\n  commit;\n  result := 'true';\nexception\n  when storage_error then\n    result := 'false';\n  when others then\n    result := 'false';\nend testproc;\n\n```\n\n\n2.新加java调度任务；例如：\n![输入图片说明][image-14]\n> 新平台EAST需要配置3个作业才可以正常运行  \n> - 数据补录作业\n1. 数据补录系统待上报报文流程存储过程（east.create\\_bl\\_task|系统内置）\n2. 数据补录系统流程开启任务（JAVA任务）\n3. EAST收据调度作业\n1. EAST待上报报文流程存储过程（east.proc\\_ledgerReport|系统内置）  \n2. 数据拉取存储过程（客户现场人员编写）  \n3. EAST流程开启任务（JAVA任务）\n7. EAST报文生成作业\n1. EAST上报报文生成任务（JAVA任务）\n\n_作业任务为Java任务的实例如下_\n- EAST流程开启任务（POST请求）  \n\t\\`\\`\\`ruby\n类名：com.fitechsoft.util.HttpRequest\n方法名：sendPost\nURL：http://IP:端口/项目名/task/startProcess/\n```\n- EAST上报报文生成任务（GET请求）  \n```ruby\n类名：com.fitechsoft.util.HttpRequest\n方法名：sendGet\nURL：http://IP:端口/项目名/ledgerReportFile/reportFileGenerated/create\n```\n- 数据补录系统流程开启任务（POST请求）\n```ruby\n类名：com.fitechsoft.util.HttpRequest\n方法名：sendPost\nURL:http://IP:端口/项目名/accountTask/startProcess/\n```\n\n- 进入‘作业管理’ 将任务管理中创建的任务配置到作业中\n- 选择你要维护的作业，点击作业维护\n![输入图片说明][image-15]\n2. 添加新步骤，将任务配置到作业管理中\n![输入图片说明][image-16]\n\n#### 部署ETL调度任务\n- 将fitech-etl-1.0.war放入应用服务器中间件中\n- 修改ETL系统配置\n![输入图片说明][image-17]\n- config.properties 修改ETL调度任务配置数据库\n![输入图片说明][image-18]\n- config1.properties 修改ETL调度任务存储过程数据表配置\n![输入图片说明][image-19]\n- 启动服务，控制台正常启动即可，操作员登录系统，查看代办任务是否有数据，有数据即可\n# Home\n1. [新平台activiti参数说明][3]\n2. [git安装教程][4]\n3. [新平台开发手册][5]\n# git安装教程\n### 安装介质\n- Git-1.9.5-preview20150319.exe\n- TortoiseGit-1.8.14.0-64bit.msi\n- Tor4toiseGit-LanguagePack-1.8.14.0-64bit-zh\\_CN.msi  \n\t[下载][6]\n\n### 基本配置\n1. 配置SSH密钥\n![配置SSH密钥][image-20]\n2. 找到生成的git授权KEY,路径默认生成在 _C:\\Users\\rui\\.ssh_\n![git授权KEY][image-21]\n3. 配置TortoiseGit\n![输入图片说明][image-22]\n![输入图片说明][image-23]\n![输入图片说明][image-24]\n\n### 常用语法\n- 查看当前git仓库获取和提交服务地址\n``` ruby\ngit remote -v\n```\n- 查看所有分支\n``` ruby\ngit branch\n```\n- 创建分支\n``` ruby\ngit branch dev\n```\n- 删除分支\n``` ruby\ngit branch -d dev\n```\n- 切换分支\n``` ruby\ngit checkout dev\n```\n- 创建并切换\n``` ruby\ngit checkout -b dev\n```\n- 查看工作区修改文件\n``` ruby\ngit status\n```\n- 查看修改内容\n``` ruby\ngit diff\n```\n- 添加修改到缓存区\n``` ruby\ngit add ***\ngit add -A\n```\n- 版本提交\n``` ruby\ngit commit -m \"branch test\"\n```\n- 合并分支dev到当前分支\n``` ruby\ngit merge dev\n```\n- 指定定远程版本更新到本地指定版本\n``` ruby\ngit pull <远程主机名> <远程分支名>:<本地分支名>\ngit pull origin dev:master\n```\n- 将当前分支提交到远程分支\n``` ruby\ngit push <远程主机名> <远程分支名>\ngit push origin dev\n```\n- 切换git地址\n``` ruby\n1. git remote rm origin\n2. git remote add origin git@github.com:yuquan0821/demo.git\n3. git push origin\n```\n **GIT教程** \n- [网络教程][7]\n\n# oracle数据导出工具sqluldr2配置\n### 安装步骤\n1. 由于sqluldr2是基于oracle客户端的一个插件，则需要在平台服务端安装oracle\\_client\n2. 下载sqluldr2.bin（根据操作系统自行判定版本）到$ORACLE\\_HOME的bin目录，重命名为sqluldr2.bin\n3. 修改oracle安装$HOME目录下.bash\\_profile 增加如下环境变量\n```ruby\nexport LD_LIBRARY_PATH=$ORACLE_HOME/bin:$ORACLE_HOME/lib:/lib:/usr/lib \n```\n4. 执行 sqluldr2.bin 执行成功即可\n# 新平台activiti参数说明\n### activiti配置\n1. 新建bpmn流程\n2. 绘制流程图，具体画法网上有\n3. 设置流程参数\n\t- 配置流程图ID ; name ; namespaces属性（自定义）;\n![输入图片说明][image-25]\n\t- 配置启动监听（该监听为自定义，平台已经初始化一个，无特殊需求可直接使用）\n![输入图片说明][image-26]\n\t- 配置任务节点属性\n\t  1. 配置ID和name(此ID有特殊用处)\n![输入图片说明][image-27]\n\t  2. 配置指派角色和督办角色，\n\t    - 变量规则：${任务节点ID_assignee};${任务节点ID_supervise}\n![输入图片说明][image-28]\n\t  3. 设置任务节点参数\n\t    - argname: 路由KEY，固定为input\n\t    - argvalues: 页面按钮参数，几个路由跳转几个参数，可自定义\n\t    - handleEntry 当前任务节点页面路由地址\n\t    - completeEntry 暂时为空，预留\n\t    - isAssign:是否支持任务转派， ${任务节点ID_isAssign}\n![输入图片说明][image-29]\n\t  4. 路由扭转控制参数\n\t    - 设定页面跳转路由参数${input=='refuse'}\n\t    - 说明 input:为步骤三中argname 的参数，无明显需求暂统一定义为input\n\t    - 说明'refuse' 为步骤三中argvalues参数中定义的value，指定下一节点跳转\n![输入图片说明][image-30]\n# 新平台开发手册\n### 开发环境\n- 开发工具IDE：IntelliJ IDEA/Eclipse\n- 数据库：mysql/oracle\n- JDK:1.8\n- 版本管理工具：GIT\n- 项目管理工具：MAVEN\n\n### 开发规范\n- 项目包名:com.fitech.功能名.项目名\n- 项目类名:\n\t- 领域模型：根据领域模型实际意义创建（能用英文标识的必须使用英文，无法使用英文标识的用拼音首字母创建类名，首字母必须大写)\n\t- 持久化层：领域模型名+Repository\n\t- 业务层：\n\t\t1. 接口：领域模型名+Service\n\t\t2. 实现：领域模型名+ServiceImpl\n\n- 注释:\n- 类名注释：当前类的中文描述+作者  \n\t![类名注释][image-31]\n- 接口名注释：当前接口作用+入参说明+出参说明  \n\t![接口注释][image-32]\n- 业务代码注释：每10行必须有至少有一个注释，业务复杂的3行内要有注释，判断条件（if）必须有注释\n- 预留接口，预留逻辑必须使用//TODO进行标记，并且加上备\n- 如果修改业务逻辑代码，在修改处添加备注，标识修改原因，修改时间和修改人  \n\t![修改说明][image-33]\n\n- 测试用例\n- 每个模块有独立的测试用例配置文件，放置位置在  \n\t![测试用例配置文件][image-34]\n- 每个业务逻辑添加单元测试，测试通过再提交代码  \n\t![测试用例][image-35]\n\n- GIT代码管理\n- 仓库中默认版本master，是我们开发版本\n- 本地更新后，创建本地开发版本dev   (git checkout -b dev)\n- 本地开发完成并测试通过后提交本地仓库\n- 切换版本到master （git checkout master）\n- 更新最新的开发版本\n- 合并DEV版本到master （git merge dev）\n- 确定无冲突之后提交远程仓库\n\n### 技术说明\n- domain说明  \n\t![domain][image-36]\n- 添加注释@entity\n- 主体继承FBSubject,客体继承FBObject\n- 每个字段属性添加@Description(\"角色名称\")注解，方便后期功能扩充\n- service说明  \n\t![service][image-37]\n- 添加@Service注解，加入spring容器管理\n- 添加@ServiceTrace注解，系统会自动管理service接口日志，记录到logback  \n\t![输入图片说明][image-38]\n- 接口的增删改操作需要捕获reporsitory发生的异常，然后throw出appException异常，这个是自定义异常，统一处理系统异常，记录logback,可自定义入参，第一个是异常码，可自定义，第二个是系统异常，可自定义;\n- 对于一个服务接口有2个及以上“增”“删”“改”操作的，需要添加事务@Transactional\n- controller说明  \n\t![controller][image-39]\n- 添加控制层上添加@RequestMapping ，定位当前接口位置，便于后期权限控制  \n\t![输入图片说明][image-40]\n- controller回调GenericResult\\<?\\>封装回调函数，里面有当前请求是否成功，成功状态，异常状态，异常码，数据集对象等，系统回封装成json返回前端;\n- controller中需要记录用户的操作日志，可以只对增删改操作记录，查询根据具体情况记录，addOperateLog第一个为日志信息，自定义，第二个是请求上下文对象，系统需要根据请求上下文获取登录用户信息和IP等;\n- 操作日志需要在finally中记录，防止系统异常没有记录;\n- war 说明\n![war ][image-41]\n1. Activiti.cfg.xml：activiti流程引擎配置\n2. applicationContext-jpa.xml：配置持久化层springdata配置\n3. applicationContext.xml：spring相关配置\n4. Security.cfg.xml：权限框架springsecutity相关配置\n5. secutityAcl.cfg.xml：数据权限acl相关配置\n6. Spring-mvc.xml\n7. Springbatch-content\n8. Application-evn.properties:数据源配置及其他的一些参数配置\n9. Logback.xml：配置系统日志，\n> 注：可根据具体需求进行配置修改\n### 开发注意事项\n1. clean install -Dmaven.test.skip=true 模块编译\n2. jetty:run 项目执行\n### 数据库版本切换\n- 目前系统支持mysql和Oracle数据库，由于制度报文生成接口是由不同数据库语法编写所以在切换数据库的同时要修改对应的数据库方言配置\n- 修改pom.xml  \n\t![输入图片说明][image-42]\n**目前0.0.1-SNAPSHOT版本对应mysql;0.0.2-SNAPSHOT版本对应oracle**\n2. 修改配置文件applicationContext-jpa.xml，改为数据库所对应的接口实现类  \n\t![输入图片说明][image-43]\n3. 如果需要新加SQL实现函数，则在对应的系统模块中添加，例如  \n\t![输入图片说明][image-44]  \n\t实现自己的业务逻辑即可，然后在applicationContext-jpa.xml添加相应配置加入spring管理容器\n\n[1]:\thttps://gitee.com/mpmpal_cr/document/attach_files/download?i=96428&u=http://files.git.oschina.net/group1/M00/01/F4/PaAvDFnExYiAZBwYAAbJgGShKGQ898.rar?token=2fc273a040d2eabf77c760f50eff721b&ts=1506067947&attname=%E6%96%B0%E5%B9%B3%E5%8F%B0%E8%84%9A%E6%9C%AC.rar\n[2]:\thttps://gitee.com/mpmpal_cr/document/attach_files/download?i=98255&u=http://files.git.oschina.net/group1/M00/02/09/PaAvDFnbQGuALm5OAGF7R5HNSdg735.doc?token=a118c827b961e80c623f752ed78eb4d8&ts=1507541099&attname=PD-%E7%A7%91%E8%9E%8D%E7%BB%BC%E5%90%88%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0%E4%BA%A7%E5%93%81-%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C_V1.0_20170928.doc\n[3]:\thttps://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0activiti%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&parent=\n[4]:\thttps://gitee.com/mpmpal_cr/document/wikis/pages?title=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&parent=\n[5]:\thttps://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C&parent=\n[6]:\thttp://gitee.com/mpmpal_cr/document/attach_files/download?i=102945&u=http://files.git.oschina.net/group1/M00/02/3F/PaAvDFn_1fiAEkFDAocAFD5NBjw242.rar?token=3d3e93341027b8450a17c0d4f33afc20&ts=1509938681&attname=Git%2CTortoiseGit%E5%AE%89%E8%A3%85.rar\n[7]:\thttp://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n\n[image-1]:\thttps://git.oschina.net/uploads/images/2017/0922/142804_a619079d_1102706.png \"图片1.png\"\n[image-2]:\thttps://git.oschina.net/uploads/images/2017/0922/142905_7ad5bb2f_1102706.png \"图片2.png\"\n[image-3]:\thttps://git.oschina.net/uploads/images/2017/0922/145015_b3e45198_1102706.png \"图片3.png\"\n[image-4]:\thttps://git.oschina.net/uploads/images/2017/0922/145035_e6b445d0_1102706.png \"图片4.png\"\n[image-5]:\thttps://git.oschina.net/uploads/images/2017/0922/173322_c8830ec5_1102706.png \"5.png\"\n[image-6]:\thttps://git.oschina.net/uploads/images/2017/0922/173652_6afc04b1_1102706.png \"6.png\"\n[image-7]:\thttps://git.oschina.net/uploads/images/2017/0922/173722_7a2ae350_1102706.png \"7.png\"\n[image-8]:\thttps://git.oschina.net/uploads/images/2017/0922/173755_dfcbb075_1102706.png \"8.png\"\n[image-9]:\thttps://git.oschina.net/uploads/images/2017/0925/095221_0b8c5fd0_1102706.png \"9.png\"\n[image-10]:\thttps://git.oschina.net/uploads/images/2017/0925/100741_ab5c641f_1102706.png \"10.png\"\n[image-11]:\thttps://git.oschina.net/uploads/images/2017/0925/101135_d4af3a5b_1102706.png \"11.png\"\n[image-12]:\thttps://git.oschina.net/uploads/images/2017/0925/113253_f27a4429_1102706.png \"12.png\"\n[image-13]:\thttps://git.oschina.net/uploads/images/2017/0925/142839_6cf3572f_1102706.png \"13.png\"\n[image-14]:\thttps://git.oschina.net/uploads/images/2017/0925/144829_27d05efd_1102706.png \"14.png\"\n[image-15]:\thttps://git.oschina.net/uploads/images/2017/0925/151904_7d519dcc_1102706.png \"15.png\"\n[image-16]:\thttps://git.oschina.net/uploads/images/2017/0925/151948_2459f713_1102706.png \"16.png\"\n[image-17]:\thttps://git.oschina.net/uploads/images/2017/0925/153251_aa9e251f_1102706.png \"17.png\"\n[image-18]:\thttps://git.oschina.net/uploads/images/2017/0925/155627_3d96691e_1102706.png \"18.png\"\n[image-19]:\thttps://git.oschina.net/uploads/images/2017/0925/155636_08b12be3_1102706.png \"19.png\"\n[image-20]:\thttps://git.oschina.net/uploads/images/2017/0830/143511_7e9c1265_1102706.png \"clipboard.png\"\n[image-21]:\thttps://git.oschina.net/uploads/images/2017/0830/143750_9390d834_1102706.png \"clipboard.png\"\n[image-22]:\thttps://git.oschina.net/uploads/images/2017/0830/143856_de604f92_1102706.png \"clipboard.png\"\n[image-23]:\thttps://git.oschina.net/uploads/images/2017/0830/144125_814b18db_1102706.png \"clipboard.png\"\n[image-24]:\thttps://git.oschina.net/uploads/images/2017/0830/144156_8ca52887_1102706.png \"clipboard.png\"\n[image-25]:\thttps://git.oschina.net/uploads/images/2017/0809/141007_8649cc82_1102706.png \"1.png\"\n[image-26]:\thttps://git.oschina.net/uploads/images/2017/0809/141102_62ed4ba4_1102706.png \"2.png\"\n[image-27]:\thttps://git.oschina.net/uploads/images/2017/0809/141225_c541dcca_1102706.png \"3.png\"\n[image-28]:\thttps://git.oschina.net/uploads/images/2017/0809/141253_9b67ac6b_1102706.png \"4.png\"\n[image-29]:\thttps://git.oschina.net/uploads/images/2017/0809/141342_3d544a50_1102706.png \"5.png\"\n[image-30]:\thttps://git.oschina.net/uploads/images/2017/0809/141411_478f2512_1102706.png \"6.png\"\n[image-31]:\thttps://git.oschina.net/uploads/images/2017/0830/152051_747dcf5e_1102706.png \"图片1.png\"\n[image-32]:\thttps://git.oschina.net/uploads/images/2017/0830/152154_1cf6e0b1_1102706.png \"图片2.png\"\n[image-33]:\thttps://git.oschina.net/uploads/images/2017/0830/152322_a4b7aeb4_1102706.png \"图片3.png\"\n[image-34]:\thttps://git.oschina.net/uploads/images/2017/0830/152917_14e372ff_1102706.png \"QQ截图20170830152553.png\"\n[image-35]:\thttps://git.oschina.net/uploads/images/2017/0830/152948_01102b7d_1102706.png \"图片4.png\"\n[image-36]:\thttps://git.oschina.net/uploads/images/2017/0830/154423_a15e4a4c_1102706.png \"图片5.png\"\n[image-37]:\thttps://git.oschina.net/uploads/images/2017/0830/160045_4a882daf_1102706.png \"图片6.png\"\n[image-38]:\thttps://git.oschina.net/uploads/images/2017/0830/160703_aa9ffc2f_1102706.png \"图片7.png\"\n[image-39]:\thttps://git.oschina.net/uploads/images/2017/0830/162413_b14e447d_1102706.png \"图片8.png\"\n[image-40]:\thttps://git.oschina.net/uploads/images/2017/0830/163109_0c571fe1_1102706.png \"图片9.png\"\n[image-41]:\thttps://git.oschina.net/uploads/images/2017/0830/163455_5036a5e5_1102706.png \"图片10.png\"\n[image-42]:\thttps://git.oschina.net/uploads/images/2017/0830/164510_7b159611_1102706.png \"图片11.png\"\n[image-43]:\thttps://git.oschina.net/uploads/images/2017/0830/164601_eb23eff4_1102706.png \"图片12.png\"\n[image-44]:\thttps://git.oschina.net/uploads/images/2017/0830/164642_efb5c1a0_1102706.png \"图片13.png\"","slug":"git教程","published":1,"updated":"2017-11-22T10:24:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjy5000mxqs6im9brr8f","content":"<h1 id=\"EAST项目部署常见问题\"><a href=\"#EAST项目部署常见问题\" class=\"headerlink\" title=\"EAST项目部署常见问题\"></a>EAST项目部署常见问题</h1><h2 id=\"项目启动报错\"><a href=\"#项目启动报错\" class=\"headerlink\" title=\"项目启动报错\"></a>项目启动报错</h2><ol>\n<li>保证服务器jdk版本为1.8以上</li>\n<li>首次部署仅将fitech.war,platform.war和libs.war放入服务器中间件中，防止日志太多，异常不容易排查</li>\n<li>查看服务器日志，发现connection异常，检查fitech中的数据库配置是否正确</li>\n</ol>\n<h2 id=\"用户登录异常\"><a href=\"#用户登录异常\" class=\"headerlink\" title=\"用户登录异常\"></a>用户登录异常</h2><ol>\n<li>检查数据脚本都正常执行了，可查看select * from sysuser是否有数据</li>\n<li>访问浏览器控制台，F12，登录一下看看是否有异常，如果是404，检查platform中的fitech.js是否修改成功</li>\n</ol>\n<h2 id=\"登录之后系统常见问题\"><a href=\"#登录之后系统常见问题\" class=\"headerlink\" title=\"登录之后系统常见问题\"></a>登录之后系统常见问题</h2><ol>\n<li>不要随意直接在数据库中修改数据，会导致页面显示有问题，如果实在想操作，请先询问产品开发</li>\n<li>系统配置中的制度配置导入时间比较久，耐心等待一会，重复导入可能会导致数据问题，查看是否成功，可在报文配置中查看数据表<br>\\3. </li>\n</ol>\n<h2 id=\"ETL数据调度常见问题\"><a href=\"#ETL数据调度常见问题\" class=\"headerlink\" title=\"ETL数据调度常见问题\"></a>ETL数据调度常见问题</h2><blockquote>\n<p>新平台EAST需要配置3个作业才可以正常运行  </p>\n<ul>\n<li>数据补录作业</li>\n</ul>\n<ol>\n<li>数据补录系统待上报报文流程存储过程（east.create_bl_task|系统内置）</li>\n<li>数据补录系统流程开启任务（JAVA任务）</li>\n<li>EAST收据调度作业</li>\n<li>EAST待上报报文流程存储过程（east.proc_ledgerReport|系统内置）  </li>\n<li>数据拉取存储过程（客户现场人员编写）  </li>\n<li>EAST流程开启任务（JAVA任务）</li>\n<li>EAST报文生成作业</li>\n<li>EAST上报报文生成任务（JAVA任务）</li>\n</ol>\n</blockquote>\n<ol>\n<li>安装部署手册中的案例都是范例，请根据实际情况进行配置</li>\n<li>调度任务有没有成功执行，可以查看控制台日志是否执行成功</li>\n<li>数据库连接异常，可查看fitech-etl-1.0.war是否配置成功</li>\n<li>出现数组越界，可能是作业中的任务配置有问题，可截图发给开发排查问题</li>\n<li>ETL会根据配置频度来控制执行状态，例如日频度，则当天只能执行一次，如果想多次执行，则到数据调度监控中重新执行作业，或者执行SQL手动删除ETL调度任务 例如：</li>\n</ol>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from etl_job_monitor;</span><br><span class=\"line\">select * from ETL_TASK_MONITOR;</span><br><span class=\"line\"></span><br><span class=\"line\">delete from ETL_JOB_MONITOR where yxrq = <span class=\"string\">'20171020'</span>;</span><br><span class=\"line\">delete from ETL_TASK_MONITOR where yxrq = <span class=\"string\">'20171020'</span>;</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n<h1 id=\"EAST项目部署手册\"><a href=\"#EAST项目部署手册\" class=\"headerlink\" title=\"EAST项目部署手册\"></a>EAST项目部署手册</h1><h2 id=\"服务器环境\"><a href=\"#服务器环境\" class=\"headerlink\" title=\"服务器环境\"></a>服务器环境</h2><ul>\n<li>数据库（如果是oracle需要安装oracle客户端，用作sqluldr2报文生成）</li>\n<li>jdk1.8以上</li>\n<li>服务器中间件（需要支持jdk1.8）</li>\n</ul>\n<h2 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h2><blockquote>\n<p>项目分成4个子服务，由于模块之间有相互调用，需要分先后启动，分别配置</p>\n</blockquote>\n<ul>\n<li>fitech.war<br><em>平台主服务,处理平台业务逻辑</em></li>\n<li>fitech-etl-1.0.war<br><em>ETL调度系统服务，处理数据抽取等调度任务</em></li>\n<li>platform.war<br><em>前端主服务</em></li>\n<li>libs.war<br><em>前端框架lib包</em></li>\n</ul>\n<h2 id=\"项目部署\"><a href=\"#项目部署\" class=\"headerlink\" title=\"项目部署\"></a>项目部署</h2><h4 id=\"主服务部署配置\"><a href=\"#主服务部署配置\" class=\"headerlink\" title=\"主服务部署配置\"></a>主服务部署配置</h4><ul>\n<li>将fitech.war放入服务中间件</li>\n<li>修改服务配置文件application-env.properties<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/142804_a619079d_1102706.png\" alt=\"配置文件所在位置\" title=\"图片1.png\"></li>\n<li>需要修改的配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/142905_7ad5bb2f_1102706.png\" alt=\"输入图片说明\" title=\"图片2.png\"> </li>\n</ul>\n<ol>\n<li>数据库配置，修改对应IP,端口和监听，以及用户名和密码</li>\n<li>initPassword是系统创建用户初始化密码的默认密码，根据需求修改</li>\n<li>template_path是系统模板存放路径，用于机构，用户等功能的模板下载</li>\n<li>ledgerRptFIle_tempPath和ledgerRptFIle_path是EAST生成报文存放的路径和临时文件生成的存放路径</li>\n<li>DBurl是sqluldr2报文生成数据链接配置</li>\n</ol>\n<h4 id=\"客户端部署配置\"><a href=\"#客户端部署配置\" class=\"headerlink\" title=\"客户端部署配置\"></a>客户端部署配置</h4><ul>\n<li>将platform.war和libs.war放入服务中间件</li>\n<li>修改配置文件fitech.js<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/145015_b3e45198_1102706.png\" alt=\"放置路径\" title=\"图片3.png\"><br><img src=\"https://git.oschina.net/uploads/images/2017/0922/145035_e6b445d0_1102706.png\" alt=\"输入图片说明\" title=\"图片4.png\"></li>\n</ul>\n<ol>\n<li>pathcs是配置ETL调度系统地址</li>\n<li>path是配置主服务地址(包括服务项目名)</li>\n</ol>\n<h4 id=\"创建数据库表\"><a href=\"#创建数据库表\" class=\"headerlink\" title=\"创建数据库表\"></a>创建数据库表</h4><ul>\n<li><em>启动服务，主服务会自动创建系统表</em> </li>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/attach_files/download?i=96428&amp;u=http://files.git.oschina.net/group1/M00/01/F4/PaAvDFnExYiAZBwYAAbJgGShKGQ898.rar?token=2fc273a040d2eabf77c760f50eff721b&amp;ts=1506067947&amp;attname=%E6%96%B0%E5%B9%B3%E5%8F%B0%E8%84%9A%E6%9C%AC.rar\" target=\"_blank\" rel=\"noopener\">下载脚本</a></li>\n<li>执行初始化数据  </li>\n<li>EAST3.0初始化脚本.sql（初始化条线，角色等基础信息）</li>\n<li>EAST脱敏函数.sql（初始化脱敏函数，复制该脚本中的函数依次执行）  </li>\n<li>EAST脱敏公式.sql（初始化脱敏公式）</li>\n<li>拉链表存储过程.sql（初始化拉链表存储过程，复制该脚本中的存储过程依次执行）</li>\n<li>ETL初始化脚本.sql（初始化ETL基础数据）</li>\n<li>ETL存储过程.sql（ETL存储过程）</li>\n<li>ETD指标建表语句.sql（根据需求执行，免费的10个指标）</li>\n<li>ETD初始化数据.sql（根据需求执行，免费的10个指标）</li>\n<li>数据补录系统存储过程.sql（数据补录系统存储过程）</li>\n<li>数据补录初始化脚本.sql（数据补录系统初始化脚本）</li>\n<li>初始化EAST3.0校验公式（validata_rule05.sql脚本中有N个变量，根据提示进行输入。输入&amp;&amp;+变量,如：&amp;&amp;CHANGE）</li>\n<li>将template文件夹下的excel放到application-env.properties配置文件下的template_path路径下，用于模板下载</li>\n</ul>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><ul>\n<li>启动服务器中间件</li>\n<li>打开浏览器访问<a href=\"http://IP:port/platform\" target=\"_blank\" rel=\"noopener\">http://IP:port/platform</a></li>\n<li>访问成功，点击登录使用superadmin登录，密码123456进行登录</li>\n</ul>\n<h4 id=\"配置业务制度\"><a href=\"#配置业务制度\" class=\"headerlink\" title=\"配置业务制度\"></a>配置业务制度</h4><ul>\n<li>进入系统配置》制度管理<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173322_c8830ec5_1102706.png\" alt=\"输入图片说明\" title=\"5.png\"></li>\n<li>进入银监标准化业务条线》手工配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173652_6afc04b1_1102706.png\" alt=\"输入图片说明\" title=\"6.png\"></li>\n<li>新增一个制度<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173722_7a2ae350_1102706.png\" alt=\"输入图片说明\" title=\"7.png\"></li>\n<li>点击批量载入，选择系统导入文件夹下的EASTtemplate0530.xlsx和fields.xlsx，点击确定，待导入完成后，可生成EAST的58张数据表<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173755_dfcbb075_1102706.png\" alt=\"输入图片说明\" title=\"8.png\"></li>\n<li>进入报文配置功能，查看报文是否生成成功，如果成功可进入操作手册进行机构，用户，角色等业务配置</li>\n</ul>\n<h4 id=\"数据配置\"><a href=\"#数据配置\" class=\"headerlink\" title=\"数据配置\"></a>数据配置</h4><ul>\n<li>系统需要现场实施人员根据客户现场情况创建机构，角色和用户信息</li>\n<li>机构信息配置</li>\n<li>角色信息配置</li>\n<li>用户信息配置</li>\n<li>流程信息配置（重要，ETL数据调度流程需要此步骤）<br>   <a href=\"https://gitee.com/mpmpal_cr/document/attach_files/download?i=98255&amp;u=http://files.git.oschina.net/group1/M00/02/09/PaAvDFnbQGuALm5OAGF7R5HNSdg735.doc?token=a118c827b961e80c623f752ed78eb4d8&amp;ts=1507541099&amp;attname=PD-%E7%A7%91%E8%9E%8D%E7%BB%BC%E5%90%88%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0%E4%BA%A7%E5%93%81-%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C_V1.0_20170928.doc\" target=\"_blank\" rel=\"noopener\">详见用户操作手册</a></li>\n</ul>\n<h4 id=\"配置ETL调度任务\"><a href=\"#配置ETL调度任务\" class=\"headerlink\" title=\"配置ETL调度任务\"></a>配置ETL调度任务</h4><ul>\n<li>进入业务条线 》 数据调度<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/095221_0b8c5fd0_1102706.png\" alt=\"数据调度\" title=\"9.png\"></li>\n<li>进入‘作业分类’菜单，新建一个‘作业分类’，用于管理系统调度作业</li>\n<li>进入‘作业管理’菜单，在新建的作业分类下创建调度作业，用于数据调度；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/100741_ab5c641f_1102706.png\" alt=\"输入图片说明\" title=\"10.png\"></li>\n</ul>\n<ol>\n<li>新增作业；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/101135_d4af3a5b_1102706.png\" alt=\"输入图片说明\" title=\"11.png\"><blockquote>\n<p>选择当前调度作业 <em>目前仅支持shell脚本和存储过程</em><br>配置作业频度之后，只有满足当前配置的启动条件，调度作业才会启动 <em>shell和存储过程必须要有回调true/false</em>  </p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>进入‘任务管理’菜单，用于配置调度作业所需要的任务；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/113253_f27a4429_1102706.png\" alt=\"输入图片说明\" title=\"12.png\">  </li>\n<li>选择任务类型新建任务<br>1.新建procedure存储过程任务；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/142839_6cf3572f_1102706.png\" alt=\"输入图片说明\" title=\"13.png\"><br><em>所有的存储过程必须要有回调函数true/false;例如：</em></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create <span class=\"keyword\">or</span> replace procedure testproc(term <span class=\"keyword\">in</span> VARCHAR2, result OUT varchar)</span><br><span class=\"line\">as</span><br><span class=\"line\">  CURSOR c1 IS</span><br><span class=\"line\">select l.id, t.tablename, i.institutionid</span><br><span class=\"line\">      from ledgerreport l</span><br><span class=\"line\">      left join ledgerrpttemplate t</span><br><span class=\"line\">        on l.ledgerreporttemplate_id = t.id</span><br><span class=\"line\">      left join institution i</span><br><span class=\"line\">        on l.institution_id = i.id</span><br><span class=\"line\">     where l.submitstatetype = <span class=\"string\">'2'</span></span><br><span class=\"line\">       <span class=\"keyword\">and</span> l.term = term</span><br><span class=\"line\">       <span class=\"keyword\">and</span>  i.institutionid=<span class=\"string\">'3011'</span>;</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">FOR acct IN c1 LOOP</span><br><span class=\"line\">   update test.t_gx_ygb set reportid = acct.id</span><br><span class=\"line\"></span><br><span class=\"line\"> where nbjgh = <span class=\"string\">'3011'</span>;</span><br><span class=\"line\">  insert into yjbzh.t_gx_ygb</span><br><span class=\"line\">    select SEQ_FITECH.nextval id,REPORTID,CJRQ,GWBH,YGZT,YXJGMC,ZW,YXJGDM,SFZH,XM,JRXKZH,SSBM,WDH,LXDH,GH,NBJGH,SYNCABLE from test.t_gx_ygb;</span><br><span class=\"line\">    <span class=\"keyword\">END</span> LOOP;</span><br><span class=\"line\">  commit;</span><br><span class=\"line\">  result <span class=\"symbol\">:</span>= <span class=\"string\">'true'</span>;</span><br><span class=\"line\">exception</span><br><span class=\"line\">  <span class=\"keyword\">when</span> storage_error <span class=\"keyword\">then</span></span><br><span class=\"line\">    result <span class=\"symbol\">:</span>= <span class=\"string\">'false'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">when</span> others <span class=\"keyword\">then</span></span><br><span class=\"line\">    result <span class=\"symbol\">:</span>= <span class=\"string\">'false'</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span> testproc;</span><br></pre></td></tr></table></figure>\n<p>2.新加java调度任务；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/144829_27d05efd_1102706.png\" alt=\"输入图片说明\" title=\"14.png\"></p>\n<blockquote>\n<p>新平台EAST需要配置3个作业才可以正常运行  </p>\n<ul>\n<li>数据补录作业</li>\n</ul>\n<ol>\n<li>数据补录系统待上报报文流程存储过程（east.create_bl_task|系统内置）</li>\n<li>数据补录系统流程开启任务（JAVA任务）</li>\n<li>EAST收据调度作业</li>\n<li>EAST待上报报文流程存储过程（east.proc_ledgerReport|系统内置）  </li>\n<li>数据拉取存储过程（客户现场人员编写）  </li>\n<li>EAST流程开启任务（JAVA任务）</li>\n<li>EAST报文生成作业</li>\n<li>EAST上报报文生成任务（JAVA任务）</li>\n</ol>\n</blockquote>\n<p><em>作业任务为Java任务的实例如下</em></p>\n<ul>\n<li><p>EAST流程开启任务（POST请求）<br>  ```ruby<br>类名：com.fitechsoft.util.HttpRequest<br>方法名：sendPost<br>URL：<a href=\"http://IP:端口/项目名/task/startProcess/\" target=\"_blank\" rel=\"noopener\">http://IP:端口/项目名/task/startProcess/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- EAST上报报文生成任务（GET请求）  </span><br><span class=\"line\">```ruby</span><br><span class=\"line\">类名：com.fitechsoft.util.HttpRequest</span><br><span class=\"line\">方法名：sendGet</span><br><span class=\"line\">URL：http://IP:端口/项目名/ledgerReportFile/reportFileGenerated/create</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数据补录系统流程开启任务（POST请求）</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名：com.fitechsoft.util.HttpRequest</span><br><span class=\"line\">方法名：sendPost</span><br><span class=\"line\"><span class=\"symbol\">URL:</span><span class=\"symbol\">http:</span>/<span class=\"regexp\">/IP:端口/</span>项目名/accountTask/startProcess/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入‘作业管理’ 将任务管理中创建的任务配置到作业中</p>\n</li>\n<li>选择你要维护的作业，点击作业维护<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/151904_7d519dcc_1102706.png\" alt=\"输入图片说明\" title=\"15.png\"></li>\n</ul>\n<ol>\n<li>添加新步骤，将任务配置到作业管理中<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/151948_2459f713_1102706.png\" alt=\"输入图片说明\" title=\"16.png\"></li>\n</ol>\n<h4 id=\"部署ETL调度任务\"><a href=\"#部署ETL调度任务\" class=\"headerlink\" title=\"部署ETL调度任务\"></a>部署ETL调度任务</h4><ul>\n<li>将fitech-etl-1.0.war放入应用服务器中间件中</li>\n<li>修改ETL系统配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/153251_aa9e251f_1102706.png\" alt=\"输入图片说明\" title=\"17.png\"></li>\n<li>config.properties 修改ETL调度任务配置数据库<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/155627_3d96691e_1102706.png\" alt=\"输入图片说明\" title=\"18.png\"></li>\n<li>config1.properties 修改ETL调度任务存储过程数据表配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/155636_08b12be3_1102706.png\" alt=\"输入图片说明\" title=\"19.png\"></li>\n<li>启动服务，控制台正常启动即可，操作员登录系统，查看代办任务是否有数据，有数据即可<h1 id=\"Home\"><a href=\"#Home\" class=\"headerlink\" title=\"Home\"></a>Home</h1></li>\n</ul>\n<ol>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0activiti%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&amp;parent=\" target=\"_blank\" rel=\"noopener\">新平台activiti参数说明</a></li>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/wikis/pages?title=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;parent=\" target=\"_blank\" rel=\"noopener\">git安装教程</a></li>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C&amp;parent=\" target=\"_blank\" rel=\"noopener\">新平台开发手册</a><h1 id=\"git安装教程\"><a href=\"#git安装教程\" class=\"headerlink\" title=\"git安装教程\"></a>git安装教程</h1><h3 id=\"安装介质\"><a href=\"#安装介质\" class=\"headerlink\" title=\"安装介质\"></a>安装介质</h3></li>\n</ol>\n<ul>\n<li>Git-1.9.5-preview20150319.exe</li>\n<li>TortoiseGit-1.8.14.0-64bit.msi</li>\n<li>Tor4toiseGit-LanguagePack-1.8.14.0-64bit-zh_CN.msi<br>  <a href=\"http://gitee.com/mpmpal_cr/document/attach_files/download?i=102945&amp;u=http://files.git.oschina.net/group1/M00/02/3F/PaAvDFn_1fiAEkFDAocAFD5NBjw242.rar?token=3d3e93341027b8450a17c0d4f33afc20&amp;ts=1509938681&amp;attname=Git%2CTortoiseGit%E5%AE%89%E8%A3%85.rar\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n</ul>\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><ol>\n<li>配置SSH密钥<br><img src=\"https://git.oschina.net/uploads/images/2017/0830/143511_7e9c1265_1102706.png\" alt=\"配置SSH密钥\" title=\"clipboard.png\"></li>\n<li>找到生成的git授权KEY,路径默认生成在 <em>C:\\Users\\rui.ssh</em><br><img src=\"https://git.oschina.net/uploads/images/2017/0830/143750_9390d834_1102706.png\" alt=\"git授权KEY\" title=\"clipboard.png\"></li>\n<li>配置TortoiseGit<br><img src=\"https://git.oschina.net/uploads/images/2017/0830/143856_de604f92_1102706.png\" alt=\"输入图片说明\" title=\"clipboard.png\"><br><img src=\"https://git.oschina.net/uploads/images/2017/0830/144125_814b18db_1102706.png\" alt=\"输入图片说明\" title=\"clipboard.png\"><br><img src=\"https://git.oschina.net/uploads/images/2017/0830/144156_8ca52887_1102706.png\" alt=\"输入图片说明\" title=\"clipboard.png\"></li>\n</ol>\n<h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><ul>\n<li><p>查看当前git仓库获取和提交服务地址</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看所有分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建并切换</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看工作区修改文件</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看修改内容</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加修改到缓存区</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add ***</span><br><span class=\"line\">git add -A</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>版本提交</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">\"branch test\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>合并分支dev到当前分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定定远程版本更新到本地指定版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;<span class=\"symbol\">:&lt;</span>本地分支名&gt;</span><br><span class=\"line\">git pull origin <span class=\"symbol\">dev:</span>master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前分支提交到远程分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push &lt;远程主机名&gt; &lt;远程分支名&gt;</span><br><span class=\"line\">git push origin dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换git地址</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. git remote rm origin</span><br><span class=\"line\"><span class=\"number\">2</span>. git remote add origin git@github.<span class=\"symbol\">com:</span>yuquan0821/demo.git</span><br><span class=\"line\"><span class=\"number\">3</span>. git push origin</span><br></pre></td></tr></table></figure>\n<p><strong>GIT教程</strong> </p>\n</li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">网络教程</a></li>\n</ul>\n<h1 id=\"oracle数据导出工具sqluldr2配置\"><a href=\"#oracle数据导出工具sqluldr2配置\" class=\"headerlink\" title=\"oracle数据导出工具sqluldr2配置\"></a>oracle数据导出工具sqluldr2配置</h1><h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ol>\n<li>由于sqluldr2是基于oracle客户端的一个插件，则需要在平台服务端安装oracle_client</li>\n<li>下载sqluldr2.bin（根据操作系统自行判定版本）到$ORACLE_HOME的bin目录，重命名为sqluldr2.bin</li>\n<li><p>修改oracle安装$HOME目录下.bash_profile 增加如下环境变量</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LD_LIBRARY_PATH=$ORACLE_HOME/<span class=\"symbol\">bin:</span>$ORACLE_HOME/<span class=\"symbol\">lib:</span>/<span class=\"symbol\">lib:</span>/usr/lib</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行 sqluldr2.bin 执行成功即可</p>\n<h1 id=\"新平台activiti参数说明\"><a href=\"#新平台activiti参数说明\" class=\"headerlink\" title=\"新平台activiti参数说明\"></a>新平台activiti参数说明</h1><h3 id=\"activiti配置\"><a href=\"#activiti配置\" class=\"headerlink\" title=\"activiti配置\"></a>activiti配置</h3></li>\n<li>新建bpmn流程</li>\n<li>绘制流程图，具体画法网上有</li>\n<li>设置流程参数<ul>\n<li>配置流程图ID ; name ; namespaces属性（自定义）;<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141007_8649cc82_1102706.png\" alt=\"输入图片说明\" title=\"1.png\"></li>\n<li>配置启动监听（该监听为自定义，平台已经初始化一个，无特殊需求可直接使用）<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141102_62ed4ba4_1102706.png\" alt=\"输入图片说明\" title=\"2.png\"></li>\n<li>配置任务节点属性<ol>\n<li>配置ID和name(此ID有特殊用处)<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141225_c541dcca_1102706.png\" alt=\"输入图片说明\" title=\"3.png\"></li>\n<li>配置指派角色和督办角色，<ul>\n<li>变量规则：${任务节点ID_assignee};${任务节点ID_supervise}<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141253_9b67ac6b_1102706.png\" alt=\"输入图片说明\" title=\"4.png\"></li>\n</ul>\n</li>\n<li>设置任务节点参数<ul>\n<li>argname: 路由KEY，固定为input</li>\n<li>argvalues: 页面按钮参数，几个路由跳转几个参数，可自定义</li>\n<li>handleEntry 当前任务节点页面路由地址</li>\n<li>completeEntry 暂时为空，预留</li>\n<li>isAssign:是否支持任务转派， ${任务节点ID_isAssign}<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141342_3d544a50_1102706.png\" alt=\"输入图片说明\" title=\"5.png\"></li>\n</ul>\n</li>\n<li>路由扭转控制参数<ul>\n<li>设定页面跳转路由参数${input==’refuse’}</li>\n<li>说明 input:为步骤三中argname 的参数，无明显需求暂统一定义为input</li>\n<li>说明’refuse’ 为步骤三中argvalues参数中定义的value，指定下一节点跳转<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141411_478f2512_1102706.png\" alt=\"输入图片说明\" title=\"6.png\"><h1 id=\"新平台开发手册\"><a href=\"#新平台开发手册\" class=\"headerlink\" title=\"新平台开发手册\"></a>新平台开发手册</h1><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3></li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>开发工具IDE：IntelliJ IDEA/Eclipse</li>\n<li>数据库：mysql/oracle</li>\n<li>JDK:1.8</li>\n<li>版本管理工具：GIT</li>\n<li>项目管理工具：MAVEN</li>\n</ul>\n<h3 id=\"开发规范\"><a href=\"#开发规范\" class=\"headerlink\" title=\"开发规范\"></a>开发规范</h3><ul>\n<li>项目包名:com.fitech.功能名.项目名</li>\n<li><p>项目类名:</p>\n<ul>\n<li>领域模型：根据领域模型实际意义创建（能用英文标识的必须使用英文，无法使用英文标识的用拼音首字母创建类名，首字母必须大写)</li>\n<li>持久化层：领域模型名+Repository</li>\n<li>业务层：<ol>\n<li>接口：领域模型名+Service</li>\n<li>实现：领域模型名+ServiceImpl</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>注释:</p>\n</li>\n<li>类名注释：当前类的中文描述+作者<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152051_747dcf5e_1102706.png\" alt=\"类名注释\" title=\"图片1.png\"></li>\n<li>接口名注释：当前接口作用+入参说明+出参说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152154_1cf6e0b1_1102706.png\" alt=\"接口注释\" title=\"图片2.png\"></li>\n<li>业务代码注释：每10行必须有至少有一个注释，业务复杂的3行内要有注释，判断条件（if）必须有注释</li>\n<li>预留接口，预留逻辑必须使用//TODO进行标记，并且加上备</li>\n<li><p>如果修改业务逻辑代码，在修改处添加备注，标识修改原因，修改时间和修改人<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152322_a4b7aeb4_1102706.png\" alt=\"修改说明\" title=\"图片3.png\"></p>\n</li>\n<li><p>测试用例</p>\n</li>\n<li>每个模块有独立的测试用例配置文件，放置位置在<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152917_14e372ff_1102706.png\" alt=\"测试用例配置文件\" title=\"QQ截图20170830152553.png\"></li>\n<li><p>每个业务逻辑添加单元测试，测试通过再提交代码<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152948_01102b7d_1102706.png\" alt=\"测试用例\" title=\"图片4.png\"></p>\n</li>\n<li><p>GIT代码管理</p>\n</li>\n<li>仓库中默认版本master，是我们开发版本</li>\n<li>本地更新后，创建本地开发版本dev   (git checkout -b dev)</li>\n<li>本地开发完成并测试通过后提交本地仓库</li>\n<li>切换版本到master （git checkout master）</li>\n<li>更新最新的开发版本</li>\n<li>合并DEV版本到master （git merge dev）</li>\n<li>确定无冲突之后提交远程仓库</li>\n</ul>\n<h3 id=\"技术说明\"><a href=\"#技术说明\" class=\"headerlink\" title=\"技术说明\"></a>技术说明</h3><ul>\n<li>domain说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/154423_a15e4a4c_1102706.png\" alt=\"domain\" title=\"图片5.png\"></li>\n<li>添加注释@entity</li>\n<li>主体继承FBSubject,客体继承FBObject</li>\n<li>每个字段属性添加@Description(“角色名称”)注解，方便后期功能扩充</li>\n<li>service说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/160045_4a882daf_1102706.png\" alt=\"service\" title=\"图片6.png\"></li>\n<li>添加@Service注解，加入spring容器管理</li>\n<li>添加@ServiceTrace注解，系统会自动管理service接口日志，记录到logback<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/160703_aa9ffc2f_1102706.png\" alt=\"输入图片说明\" title=\"图片7.png\"></li>\n<li>接口的增删改操作需要捕获reporsitory发生的异常，然后throw出appException异常，这个是自定义异常，统一处理系统异常，记录logback,可自定义入参，第一个是异常码，可自定义，第二个是系统异常，可自定义;</li>\n<li>对于一个服务接口有2个及以上“增”“删”“改”操作的，需要添加事务@Transactional</li>\n<li>controller说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/162413_b14e447d_1102706.png\" alt=\"controller\" title=\"图片8.png\"></li>\n<li>添加控制层上添加@RequestMapping ，定位当前接口位置，便于后期权限控制<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/163109_0c571fe1_1102706.png\" alt=\"输入图片说明\" title=\"图片9.png\"></li>\n<li>controller回调GenericResult\\&lt;?>封装回调函数，里面有当前请求是否成功，成功状态，异常状态，异常码，数据集对象等，系统回封装成json返回前端;</li>\n<li>controller中需要记录用户的操作日志，可以只对增删改操作记录，查询根据具体情况记录，addOperateLog第一个为日志信息，自定义，第二个是请求上下文对象，系统需要根据请求上下文获取登录用户信息和IP等;</li>\n<li>操作日志需要在finally中记录，防止系统异常没有记录;</li>\n<li>war 说明<br><img src=\"https://git.oschina.net/uploads/images/2017/0830/163455_5036a5e5_1102706.png\" alt=\"war \" title=\"图片10.png\"></li>\n</ul>\n<ol>\n<li>Activiti.cfg.xml：activiti流程引擎配置</li>\n<li>applicationContext-jpa.xml：配置持久化层springdata配置</li>\n<li>applicationContext.xml：spring相关配置</li>\n<li>Security.cfg.xml：权限框架springsecutity相关配置</li>\n<li>secutityAcl.cfg.xml：数据权限acl相关配置</li>\n<li>Spring-mvc.xml</li>\n<li>Springbatch-content</li>\n<li>Application-evn.properties:数据源配置及其他的一些参数配置</li>\n<li>Logback.xml：配置系统日志，<blockquote>\n<p>注：可根据具体需求进行配置修改</p>\n<h3 id=\"开发注意事项\"><a href=\"#开发注意事项\" class=\"headerlink\" title=\"开发注意事项\"></a>开发注意事项</h3></blockquote>\n</li>\n<li>clean install -Dmaven.test.skip=true 模块编译</li>\n<li>jetty:run 项目执行<h3 id=\"数据库版本切换\"><a href=\"#数据库版本切换\" class=\"headerlink\" title=\"数据库版本切换\"></a>数据库版本切换</h3></li>\n</ol>\n<ul>\n<li>目前系统支持mysql和Oracle数据库，由于制度报文生成接口是由不同数据库语法编写所以在切换数据库的同时要修改对应的数据库方言配置</li>\n<li>修改pom.xml<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/164510_7b159611_1102706.png\" alt=\"输入图片说明\" title=\"图片11.png\"><br><strong>目前0.0.1-SNAPSHOT版本对应mysql;0.0.2-SNAPSHOT版本对应oracle</strong></li>\n</ul>\n<ol>\n<li>修改配置文件applicationContext-jpa.xml，改为数据库所对应的接口实现类<br> <img src=\"https://git.oschina.net/uploads/images/2017/0830/164601_eb23eff4_1102706.png\" alt=\"输入图片说明\" title=\"图片12.png\"></li>\n<li>如果需要新加SQL实现函数，则在对应的系统模块中添加，例如<br> <img src=\"https://git.oschina.net/uploads/images/2017/0830/164642_efb5c1a0_1102706.png\" alt=\"输入图片说明\" title=\"图片13.png\"><br> 实现自己的业务逻辑即可，然后在applicationContext-jpa.xml添加相应配置加入spring管理容器</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EAST项目部署常见问题\"><a href=\"#EAST项目部署常见问题\" class=\"headerlink\" title=\"EAST项目部署常见问题\"></a>EAST项目部署常见问题</h1><h2 id=\"项目启动报错\"><a href=\"#项目启动报错\" class=\"headerlink\" title=\"项目启动报错\"></a>项目启动报错</h2><ol>\n<li>保证服务器jdk版本为1.8以上</li>\n<li>首次部署仅将fitech.war,platform.war和libs.war放入服务器中间件中，防止日志太多，异常不容易排查</li>\n<li>查看服务器日志，发现connection异常，检查fitech中的数据库配置是否正确</li>\n</ol>\n<h2 id=\"用户登录异常\"><a href=\"#用户登录异常\" class=\"headerlink\" title=\"用户登录异常\"></a>用户登录异常</h2><ol>\n<li>检查数据脚本都正常执行了，可查看select * from sysuser是否有数据</li>\n<li>访问浏览器控制台，F12，登录一下看看是否有异常，如果是404，检查platform中的fitech.js是否修改成功</li>\n</ol>\n<h2 id=\"登录之后系统常见问题\"><a href=\"#登录之后系统常见问题\" class=\"headerlink\" title=\"登录之后系统常见问题\"></a>登录之后系统常见问题</h2><ol>\n<li>不要随意直接在数据库中修改数据，会导致页面显示有问题，如果实在想操作，请先询问产品开发</li>\n<li>系统配置中的制度配置导入时间比较久，耐心等待一会，重复导入可能会导致数据问题，查看是否成功，可在报文配置中查看数据表<br>\\3. </li>\n</ol>\n<h2 id=\"ETL数据调度常见问题\"><a href=\"#ETL数据调度常见问题\" class=\"headerlink\" title=\"ETL数据调度常见问题\"></a>ETL数据调度常见问题</h2><blockquote>\n<p>新平台EAST需要配置3个作业才可以正常运行  </p>\n<ul>\n<li>数据补录作业</li>\n</ul>\n<ol>\n<li>数据补录系统待上报报文流程存储过程（east.create_bl_task|系统内置）</li>\n<li>数据补录系统流程开启任务（JAVA任务）</li>\n<li>EAST收据调度作业</li>\n<li>EAST待上报报文流程存储过程（east.proc_ledgerReport|系统内置）  </li>\n<li>数据拉取存储过程（客户现场人员编写）  </li>\n<li>EAST流程开启任务（JAVA任务）</li>\n<li>EAST报文生成作业</li>\n<li>EAST上报报文生成任务（JAVA任务）</li>\n</ol>\n</blockquote>\n<ol>\n<li>安装部署手册中的案例都是范例，请根据实际情况进行配置</li>\n<li>调度任务有没有成功执行，可以查看控制台日志是否执行成功</li>\n<li>数据库连接异常，可查看fitech-etl-1.0.war是否配置成功</li>\n<li>出现数组越界，可能是作业中的任务配置有问题，可截图发给开发排查问题</li>\n<li>ETL会根据配置频度来控制执行状态，例如日频度，则当天只能执行一次，如果想多次执行，则到数据调度监控中重新执行作业，或者执行SQL手动删除ETL调度任务 例如：</li>\n</ol>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from etl_job_monitor;</span><br><span class=\"line\">select * from ETL_TASK_MONITOR;</span><br><span class=\"line\"></span><br><span class=\"line\">delete from ETL_JOB_MONITOR where yxrq = <span class=\"string\">'20171020'</span>;</span><br><span class=\"line\">delete from ETL_TASK_MONITOR where yxrq = <span class=\"string\">'20171020'</span>;</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n<h1 id=\"EAST项目部署手册\"><a href=\"#EAST项目部署手册\" class=\"headerlink\" title=\"EAST项目部署手册\"></a>EAST项目部署手册</h1><h2 id=\"服务器环境\"><a href=\"#服务器环境\" class=\"headerlink\" title=\"服务器环境\"></a>服务器环境</h2><ul>\n<li>数据库（如果是oracle需要安装oracle客户端，用作sqluldr2报文生成）</li>\n<li>jdk1.8以上</li>\n<li>服务器中间件（需要支持jdk1.8）</li>\n</ul>\n<h2 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h2><blockquote>\n<p>项目分成4个子服务，由于模块之间有相互调用，需要分先后启动，分别配置</p>\n</blockquote>\n<ul>\n<li>fitech.war<br><em>平台主服务,处理平台业务逻辑</em></li>\n<li>fitech-etl-1.0.war<br><em>ETL调度系统服务，处理数据抽取等调度任务</em></li>\n<li>platform.war<br><em>前端主服务</em></li>\n<li>libs.war<br><em>前端框架lib包</em></li>\n</ul>\n<h2 id=\"项目部署\"><a href=\"#项目部署\" class=\"headerlink\" title=\"项目部署\"></a>项目部署</h2><h4 id=\"主服务部署配置\"><a href=\"#主服务部署配置\" class=\"headerlink\" title=\"主服务部署配置\"></a>主服务部署配置</h4><ul>\n<li>将fitech.war放入服务中间件</li>\n<li>修改服务配置文件application-env.properties<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/142804_a619079d_1102706.png\" alt=\"配置文件所在位置\" title=\"图片1.png\"></li>\n<li>需要修改的配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/142905_7ad5bb2f_1102706.png\" alt=\"输入图片说明\" title=\"图片2.png\"> </li>\n</ul>\n<ol>\n<li>数据库配置，修改对应IP,端口和监听，以及用户名和密码</li>\n<li>initPassword是系统创建用户初始化密码的默认密码，根据需求修改</li>\n<li>template_path是系统模板存放路径，用于机构，用户等功能的模板下载</li>\n<li>ledgerRptFIle_tempPath和ledgerRptFIle_path是EAST生成报文存放的路径和临时文件生成的存放路径</li>\n<li>DBurl是sqluldr2报文生成数据链接配置</li>\n</ol>\n<h4 id=\"客户端部署配置\"><a href=\"#客户端部署配置\" class=\"headerlink\" title=\"客户端部署配置\"></a>客户端部署配置</h4><ul>\n<li>将platform.war和libs.war放入服务中间件</li>\n<li>修改配置文件fitech.js<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/145015_b3e45198_1102706.png\" alt=\"放置路径\" title=\"图片3.png\"><br><img src=\"https://git.oschina.net/uploads/images/2017/0922/145035_e6b445d0_1102706.png\" alt=\"输入图片说明\" title=\"图片4.png\"></li>\n</ul>\n<ol>\n<li>pathcs是配置ETL调度系统地址</li>\n<li>path是配置主服务地址(包括服务项目名)</li>\n</ol>\n<h4 id=\"创建数据库表\"><a href=\"#创建数据库表\" class=\"headerlink\" title=\"创建数据库表\"></a>创建数据库表</h4><ul>\n<li><em>启动服务，主服务会自动创建系统表</em> </li>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/attach_files/download?i=96428&amp;u=http://files.git.oschina.net/group1/M00/01/F4/PaAvDFnExYiAZBwYAAbJgGShKGQ898.rar?token=2fc273a040d2eabf77c760f50eff721b&amp;ts=1506067947&amp;attname=%E6%96%B0%E5%B9%B3%E5%8F%B0%E8%84%9A%E6%9C%AC.rar\" target=\"_blank\" rel=\"noopener\">下载脚本</a></li>\n<li>执行初始化数据  </li>\n<li>EAST3.0初始化脚本.sql（初始化条线，角色等基础信息）</li>\n<li>EAST脱敏函数.sql（初始化脱敏函数，复制该脚本中的函数依次执行）  </li>\n<li>EAST脱敏公式.sql（初始化脱敏公式）</li>\n<li>拉链表存储过程.sql（初始化拉链表存储过程，复制该脚本中的存储过程依次执行）</li>\n<li>ETL初始化脚本.sql（初始化ETL基础数据）</li>\n<li>ETL存储过程.sql（ETL存储过程）</li>\n<li>ETD指标建表语句.sql（根据需求执行，免费的10个指标）</li>\n<li>ETD初始化数据.sql（根据需求执行，免费的10个指标）</li>\n<li>数据补录系统存储过程.sql（数据补录系统存储过程）</li>\n<li>数据补录初始化脚本.sql（数据补录系统初始化脚本）</li>\n<li>初始化EAST3.0校验公式（validata_rule05.sql脚本中有N个变量，根据提示进行输入。输入&amp;&amp;+变量,如：&amp;&amp;CHANGE）</li>\n<li>将template文件夹下的excel放到application-env.properties配置文件下的template_path路径下，用于模板下载</li>\n</ul>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><ul>\n<li>启动服务器中间件</li>\n<li>打开浏览器访问<a href=\"http://IP:port/platform\" target=\"_blank\" rel=\"noopener\">http://IP:port/platform</a></li>\n<li>访问成功，点击登录使用superadmin登录，密码123456进行登录</li>\n</ul>\n<h4 id=\"配置业务制度\"><a href=\"#配置业务制度\" class=\"headerlink\" title=\"配置业务制度\"></a>配置业务制度</h4><ul>\n<li>进入系统配置》制度管理<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173322_c8830ec5_1102706.png\" alt=\"输入图片说明\" title=\"5.png\"></li>\n<li>进入银监标准化业务条线》手工配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173652_6afc04b1_1102706.png\" alt=\"输入图片说明\" title=\"6.png\"></li>\n<li>新增一个制度<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173722_7a2ae350_1102706.png\" alt=\"输入图片说明\" title=\"7.png\"></li>\n<li>点击批量载入，选择系统导入文件夹下的EASTtemplate0530.xlsx和fields.xlsx，点击确定，待导入完成后，可生成EAST的58张数据表<br><img src=\"https://git.oschina.net/uploads/images/2017/0922/173755_dfcbb075_1102706.png\" alt=\"输入图片说明\" title=\"8.png\"></li>\n<li>进入报文配置功能，查看报文是否生成成功，如果成功可进入操作手册进行机构，用户，角色等业务配置</li>\n</ul>\n<h4 id=\"数据配置\"><a href=\"#数据配置\" class=\"headerlink\" title=\"数据配置\"></a>数据配置</h4><ul>\n<li>系统需要现场实施人员根据客户现场情况创建机构，角色和用户信息</li>\n<li>机构信息配置</li>\n<li>角色信息配置</li>\n<li>用户信息配置</li>\n<li>流程信息配置（重要，ETL数据调度流程需要此步骤）<br>   <a href=\"https://gitee.com/mpmpal_cr/document/attach_files/download?i=98255&amp;u=http://files.git.oschina.net/group1/M00/02/09/PaAvDFnbQGuALm5OAGF7R5HNSdg735.doc?token=a118c827b961e80c623f752ed78eb4d8&amp;ts=1507541099&amp;attname=PD-%E7%A7%91%E8%9E%8D%E7%BB%BC%E5%90%88%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0%E4%BA%A7%E5%93%81-%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C_V1.0_20170928.doc\" target=\"_blank\" rel=\"noopener\">详见用户操作手册</a></li>\n</ul>\n<h4 id=\"配置ETL调度任务\"><a href=\"#配置ETL调度任务\" class=\"headerlink\" title=\"配置ETL调度任务\"></a>配置ETL调度任务</h4><ul>\n<li>进入业务条线 》 数据调度<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/095221_0b8c5fd0_1102706.png\" alt=\"数据调度\" title=\"9.png\"></li>\n<li>进入‘作业分类’菜单，新建一个‘作业分类’，用于管理系统调度作业</li>\n<li>进入‘作业管理’菜单，在新建的作业分类下创建调度作业，用于数据调度；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/100741_ab5c641f_1102706.png\" alt=\"输入图片说明\" title=\"10.png\"></li>\n</ul>\n<ol>\n<li>新增作业；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/101135_d4af3a5b_1102706.png\" alt=\"输入图片说明\" title=\"11.png\"><blockquote>\n<p>选择当前调度作业 <em>目前仅支持shell脚本和存储过程</em><br>配置作业频度之后，只有满足当前配置的启动条件，调度作业才会启动 <em>shell和存储过程必须要有回调true/false</em>  </p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>进入‘任务管理’菜单，用于配置调度作业所需要的任务；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/113253_f27a4429_1102706.png\" alt=\"输入图片说明\" title=\"12.png\">  </li>\n<li>选择任务类型新建任务<br>1.新建procedure存储过程任务；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/142839_6cf3572f_1102706.png\" alt=\"输入图片说明\" title=\"13.png\"><br><em>所有的存储过程必须要有回调函数true/false;例如：</em></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create <span class=\"keyword\">or</span> replace procedure testproc(term <span class=\"keyword\">in</span> VARCHAR2, result OUT varchar)</span><br><span class=\"line\">as</span><br><span class=\"line\">  CURSOR c1 IS</span><br><span class=\"line\">select l.id, t.tablename, i.institutionid</span><br><span class=\"line\">      from ledgerreport l</span><br><span class=\"line\">      left join ledgerrpttemplate t</span><br><span class=\"line\">        on l.ledgerreporttemplate_id = t.id</span><br><span class=\"line\">      left join institution i</span><br><span class=\"line\">        on l.institution_id = i.id</span><br><span class=\"line\">     where l.submitstatetype = <span class=\"string\">'2'</span></span><br><span class=\"line\">       <span class=\"keyword\">and</span> l.term = term</span><br><span class=\"line\">       <span class=\"keyword\">and</span>  i.institutionid=<span class=\"string\">'3011'</span>;</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">FOR acct IN c1 LOOP</span><br><span class=\"line\">   update test.t_gx_ygb set reportid = acct.id</span><br><span class=\"line\"></span><br><span class=\"line\"> where nbjgh = <span class=\"string\">'3011'</span>;</span><br><span class=\"line\">  insert into yjbzh.t_gx_ygb</span><br><span class=\"line\">    select SEQ_FITECH.nextval id,REPORTID,CJRQ,GWBH,YGZT,YXJGMC,ZW,YXJGDM,SFZH,XM,JRXKZH,SSBM,WDH,LXDH,GH,NBJGH,SYNCABLE from test.t_gx_ygb;</span><br><span class=\"line\">    <span class=\"keyword\">END</span> LOOP;</span><br><span class=\"line\">  commit;</span><br><span class=\"line\">  result <span class=\"symbol\">:</span>= <span class=\"string\">'true'</span>;</span><br><span class=\"line\">exception</span><br><span class=\"line\">  <span class=\"keyword\">when</span> storage_error <span class=\"keyword\">then</span></span><br><span class=\"line\">    result <span class=\"symbol\">:</span>= <span class=\"string\">'false'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">when</span> others <span class=\"keyword\">then</span></span><br><span class=\"line\">    result <span class=\"symbol\">:</span>= <span class=\"string\">'false'</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span> testproc;</span><br></pre></td></tr></table></figure>\n<p>2.新加java调度任务；例如：<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/144829_27d05efd_1102706.png\" alt=\"输入图片说明\" title=\"14.png\"></p>\n<blockquote>\n<p>新平台EAST需要配置3个作业才可以正常运行  </p>\n<ul>\n<li>数据补录作业</li>\n</ul>\n<ol>\n<li>数据补录系统待上报报文流程存储过程（east.create_bl_task|系统内置）</li>\n<li>数据补录系统流程开启任务（JAVA任务）</li>\n<li>EAST收据调度作业</li>\n<li>EAST待上报报文流程存储过程（east.proc_ledgerReport|系统内置）  </li>\n<li>数据拉取存储过程（客户现场人员编写）  </li>\n<li>EAST流程开启任务（JAVA任务）</li>\n<li>EAST报文生成作业</li>\n<li>EAST上报报文生成任务（JAVA任务）</li>\n</ol>\n</blockquote>\n<p><em>作业任务为Java任务的实例如下</em></p>\n<ul>\n<li><p>EAST流程开启任务（POST请求）<br>  ```ruby<br>类名：com.fitechsoft.util.HttpRequest<br>方法名：sendPost<br>URL：<a href=\"http://IP:端口/项目名/task/startProcess/\" target=\"_blank\" rel=\"noopener\">http://IP:端口/项目名/task/startProcess/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- EAST上报报文生成任务（GET请求）  </span><br><span class=\"line\">```ruby</span><br><span class=\"line\">类名：com.fitechsoft.util.HttpRequest</span><br><span class=\"line\">方法名：sendGet</span><br><span class=\"line\">URL：http://IP:端口/项目名/ledgerReportFile/reportFileGenerated/create</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数据补录系统流程开启任务（POST请求）</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名：com.fitechsoft.util.HttpRequest</span><br><span class=\"line\">方法名：sendPost</span><br><span class=\"line\"><span class=\"symbol\">URL:</span><span class=\"symbol\">http:</span>/<span class=\"regexp\">/IP:端口/</span>项目名/accountTask/startProcess/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进入‘作业管理’ 将任务管理中创建的任务配置到作业中</p>\n</li>\n<li>选择你要维护的作业，点击作业维护<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/151904_7d519dcc_1102706.png\" alt=\"输入图片说明\" title=\"15.png\"></li>\n</ul>\n<ol>\n<li>添加新步骤，将任务配置到作业管理中<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/151948_2459f713_1102706.png\" alt=\"输入图片说明\" title=\"16.png\"></li>\n</ol>\n<h4 id=\"部署ETL调度任务\"><a href=\"#部署ETL调度任务\" class=\"headerlink\" title=\"部署ETL调度任务\"></a>部署ETL调度任务</h4><ul>\n<li>将fitech-etl-1.0.war放入应用服务器中间件中</li>\n<li>修改ETL系统配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/153251_aa9e251f_1102706.png\" alt=\"输入图片说明\" title=\"17.png\"></li>\n<li>config.properties 修改ETL调度任务配置数据库<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/155627_3d96691e_1102706.png\" alt=\"输入图片说明\" title=\"18.png\"></li>\n<li>config1.properties 修改ETL调度任务存储过程数据表配置<br><img src=\"https://git.oschina.net/uploads/images/2017/0925/155636_08b12be3_1102706.png\" alt=\"输入图片说明\" title=\"19.png\"></li>\n<li>启动服务，控制台正常启动即可，操作员登录系统，查看代办任务是否有数据，有数据即可<h1 id=\"Home\"><a href=\"#Home\" class=\"headerlink\" title=\"Home\"></a>Home</h1></li>\n</ul>\n<ol>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0activiti%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E&amp;parent=\" target=\"_blank\" rel=\"noopener\">新平台activiti参数说明</a></li>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/wikis/pages?title=git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;parent=\" target=\"_blank\" rel=\"noopener\">git安装教程</a></li>\n<li><a href=\"https://gitee.com/mpmpal_cr/document/wikis/pages?title=%E6%96%B0%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C&amp;parent=\" target=\"_blank\" rel=\"noopener\">新平台开发手册</a><h1 id=\"git安装教程\"><a href=\"#git安装教程\" class=\"headerlink\" title=\"git安装教程\"></a>git安装教程</h1><h3 id=\"安装介质\"><a href=\"#安装介质\" class=\"headerlink\" title=\"安装介质\"></a>安装介质</h3></li>\n</ol>\n<ul>\n<li>Git-1.9.5-preview20150319.exe</li>\n<li>TortoiseGit-1.8.14.0-64bit.msi</li>\n<li>Tor4toiseGit-LanguagePack-1.8.14.0-64bit-zh_CN.msi<br>  <a href=\"http://gitee.com/mpmpal_cr/document/attach_files/download?i=102945&amp;u=http://files.git.oschina.net/group1/M00/02/3F/PaAvDFn_1fiAEkFDAocAFD5NBjw242.rar?token=3d3e93341027b8450a17c0d4f33afc20&amp;ts=1509938681&amp;attname=Git%2CTortoiseGit%E5%AE%89%E8%A3%85.rar\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n</ul>\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><ol>\n<li>配置SSH密钥<br><img src=\"https://git.oschina.net/uploads/images/2017/0830/143511_7e9c1265_1102706.png\" alt=\"配置SSH密钥\" title=\"clipboard.png\"></li>\n<li>找到生成的git授权KEY,路径默认生成在 <em>C:\\Users\\rui.ssh</em><br><img src=\"https://git.oschina.net/uploads/images/2017/0830/143750_9390d834_1102706.png\" alt=\"git授权KEY\" title=\"clipboard.png\"></li>\n<li>配置TortoiseGit<br><img src=\"https://git.oschina.net/uploads/images/2017/0830/143856_de604f92_1102706.png\" alt=\"输入图片说明\" title=\"clipboard.png\"><br><img src=\"https://git.oschina.net/uploads/images/2017/0830/144125_814b18db_1102706.png\" alt=\"输入图片说明\" title=\"clipboard.png\"><br><img src=\"https://git.oschina.net/uploads/images/2017/0830/144156_8ca52887_1102706.png\" alt=\"输入图片说明\" title=\"clipboard.png\"></li>\n</ol>\n<h3 id=\"常用语法\"><a href=\"#常用语法\" class=\"headerlink\" title=\"常用语法\"></a>常用语法</h3><ul>\n<li><p>查看当前git仓库获取和提交服务地址</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看所有分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建并切换</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看工作区修改文件</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看修改内容</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加修改到缓存区</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add ***</span><br><span class=\"line\">git add -A</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>版本提交</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">\"branch test\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>合并分支dev到当前分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>指定定远程版本更新到本地指定版本</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;<span class=\"symbol\">:&lt;</span>本地分支名&gt;</span><br><span class=\"line\">git pull origin <span class=\"symbol\">dev:</span>master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前分支提交到远程分支</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push &lt;远程主机名&gt; &lt;远程分支名&gt;</span><br><span class=\"line\">git push origin dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换git地址</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>. git remote rm origin</span><br><span class=\"line\"><span class=\"number\">2</span>. git remote add origin git@github.<span class=\"symbol\">com:</span>yuquan0821/demo.git</span><br><span class=\"line\"><span class=\"number\">3</span>. git push origin</span><br></pre></td></tr></table></figure>\n<p><strong>GIT教程</strong> </p>\n</li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">网络教程</a></li>\n</ul>\n<h1 id=\"oracle数据导出工具sqluldr2配置\"><a href=\"#oracle数据导出工具sqluldr2配置\" class=\"headerlink\" title=\"oracle数据导出工具sqluldr2配置\"></a>oracle数据导出工具sqluldr2配置</h1><h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ol>\n<li>由于sqluldr2是基于oracle客户端的一个插件，则需要在平台服务端安装oracle_client</li>\n<li>下载sqluldr2.bin（根据操作系统自行判定版本）到$ORACLE_HOME的bin目录，重命名为sqluldr2.bin</li>\n<li><p>修改oracle安装$HOME目录下.bash_profile 增加如下环境变量</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export LD_LIBRARY_PATH=$ORACLE_HOME/<span class=\"symbol\">bin:</span>$ORACLE_HOME/<span class=\"symbol\">lib:</span>/<span class=\"symbol\">lib:</span>/usr/lib</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行 sqluldr2.bin 执行成功即可</p>\n<h1 id=\"新平台activiti参数说明\"><a href=\"#新平台activiti参数说明\" class=\"headerlink\" title=\"新平台activiti参数说明\"></a>新平台activiti参数说明</h1><h3 id=\"activiti配置\"><a href=\"#activiti配置\" class=\"headerlink\" title=\"activiti配置\"></a>activiti配置</h3></li>\n<li>新建bpmn流程</li>\n<li>绘制流程图，具体画法网上有</li>\n<li>设置流程参数<ul>\n<li>配置流程图ID ; name ; namespaces属性（自定义）;<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141007_8649cc82_1102706.png\" alt=\"输入图片说明\" title=\"1.png\"></li>\n<li>配置启动监听（该监听为自定义，平台已经初始化一个，无特殊需求可直接使用）<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141102_62ed4ba4_1102706.png\" alt=\"输入图片说明\" title=\"2.png\"></li>\n<li>配置任务节点属性<ol>\n<li>配置ID和name(此ID有特殊用处)<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141225_c541dcca_1102706.png\" alt=\"输入图片说明\" title=\"3.png\"></li>\n<li>配置指派角色和督办角色，<ul>\n<li>变量规则：${任务节点ID_assignee};${任务节点ID_supervise}<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141253_9b67ac6b_1102706.png\" alt=\"输入图片说明\" title=\"4.png\"></li>\n</ul>\n</li>\n<li>设置任务节点参数<ul>\n<li>argname: 路由KEY，固定为input</li>\n<li>argvalues: 页面按钮参数，几个路由跳转几个参数，可自定义</li>\n<li>handleEntry 当前任务节点页面路由地址</li>\n<li>completeEntry 暂时为空，预留</li>\n<li>isAssign:是否支持任务转派， ${任务节点ID_isAssign}<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141342_3d544a50_1102706.png\" alt=\"输入图片说明\" title=\"5.png\"></li>\n</ul>\n</li>\n<li>路由扭转控制参数<ul>\n<li>设定页面跳转路由参数${input==’refuse’}</li>\n<li>说明 input:为步骤三中argname 的参数，无明显需求暂统一定义为input</li>\n<li>说明’refuse’ 为步骤三中argvalues参数中定义的value，指定下一节点跳转<br><img src=\"https://git.oschina.net/uploads/images/2017/0809/141411_478f2512_1102706.png\" alt=\"输入图片说明\" title=\"6.png\"><h1 id=\"新平台开发手册\"><a href=\"#新平台开发手册\" class=\"headerlink\" title=\"新平台开发手册\"></a>新平台开发手册</h1><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3></li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>开发工具IDE：IntelliJ IDEA/Eclipse</li>\n<li>数据库：mysql/oracle</li>\n<li>JDK:1.8</li>\n<li>版本管理工具：GIT</li>\n<li>项目管理工具：MAVEN</li>\n</ul>\n<h3 id=\"开发规范\"><a href=\"#开发规范\" class=\"headerlink\" title=\"开发规范\"></a>开发规范</h3><ul>\n<li>项目包名:com.fitech.功能名.项目名</li>\n<li><p>项目类名:</p>\n<ul>\n<li>领域模型：根据领域模型实际意义创建（能用英文标识的必须使用英文，无法使用英文标识的用拼音首字母创建类名，首字母必须大写)</li>\n<li>持久化层：领域模型名+Repository</li>\n<li>业务层：<ol>\n<li>接口：领域模型名+Service</li>\n<li>实现：领域模型名+ServiceImpl</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>注释:</p>\n</li>\n<li>类名注释：当前类的中文描述+作者<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152051_747dcf5e_1102706.png\" alt=\"类名注释\" title=\"图片1.png\"></li>\n<li>接口名注释：当前接口作用+入参说明+出参说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152154_1cf6e0b1_1102706.png\" alt=\"接口注释\" title=\"图片2.png\"></li>\n<li>业务代码注释：每10行必须有至少有一个注释，业务复杂的3行内要有注释，判断条件（if）必须有注释</li>\n<li>预留接口，预留逻辑必须使用//TODO进行标记，并且加上备</li>\n<li><p>如果修改业务逻辑代码，在修改处添加备注，标识修改原因，修改时间和修改人<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152322_a4b7aeb4_1102706.png\" alt=\"修改说明\" title=\"图片3.png\"></p>\n</li>\n<li><p>测试用例</p>\n</li>\n<li>每个模块有独立的测试用例配置文件，放置位置在<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152917_14e372ff_1102706.png\" alt=\"测试用例配置文件\" title=\"QQ截图20170830152553.png\"></li>\n<li><p>每个业务逻辑添加单元测试，测试通过再提交代码<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/152948_01102b7d_1102706.png\" alt=\"测试用例\" title=\"图片4.png\"></p>\n</li>\n<li><p>GIT代码管理</p>\n</li>\n<li>仓库中默认版本master，是我们开发版本</li>\n<li>本地更新后，创建本地开发版本dev   (git checkout -b dev)</li>\n<li>本地开发完成并测试通过后提交本地仓库</li>\n<li>切换版本到master （git checkout master）</li>\n<li>更新最新的开发版本</li>\n<li>合并DEV版本到master （git merge dev）</li>\n<li>确定无冲突之后提交远程仓库</li>\n</ul>\n<h3 id=\"技术说明\"><a href=\"#技术说明\" class=\"headerlink\" title=\"技术说明\"></a>技术说明</h3><ul>\n<li>domain说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/154423_a15e4a4c_1102706.png\" alt=\"domain\" title=\"图片5.png\"></li>\n<li>添加注释@entity</li>\n<li>主体继承FBSubject,客体继承FBObject</li>\n<li>每个字段属性添加@Description(“角色名称”)注解，方便后期功能扩充</li>\n<li>service说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/160045_4a882daf_1102706.png\" alt=\"service\" title=\"图片6.png\"></li>\n<li>添加@Service注解，加入spring容器管理</li>\n<li>添加@ServiceTrace注解，系统会自动管理service接口日志，记录到logback<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/160703_aa9ffc2f_1102706.png\" alt=\"输入图片说明\" title=\"图片7.png\"></li>\n<li>接口的增删改操作需要捕获reporsitory发生的异常，然后throw出appException异常，这个是自定义异常，统一处理系统异常，记录logback,可自定义入参，第一个是异常码，可自定义，第二个是系统异常，可自定义;</li>\n<li>对于一个服务接口有2个及以上“增”“删”“改”操作的，需要添加事务@Transactional</li>\n<li>controller说明<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/162413_b14e447d_1102706.png\" alt=\"controller\" title=\"图片8.png\"></li>\n<li>添加控制层上添加@RequestMapping ，定位当前接口位置，便于后期权限控制<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/163109_0c571fe1_1102706.png\" alt=\"输入图片说明\" title=\"图片9.png\"></li>\n<li>controller回调GenericResult\\&lt;?>封装回调函数，里面有当前请求是否成功，成功状态，异常状态，异常码，数据集对象等，系统回封装成json返回前端;</li>\n<li>controller中需要记录用户的操作日志，可以只对增删改操作记录，查询根据具体情况记录，addOperateLog第一个为日志信息，自定义，第二个是请求上下文对象，系统需要根据请求上下文获取登录用户信息和IP等;</li>\n<li>操作日志需要在finally中记录，防止系统异常没有记录;</li>\n<li>war 说明<br><img src=\"https://git.oschina.net/uploads/images/2017/0830/163455_5036a5e5_1102706.png\" alt=\"war \" title=\"图片10.png\"></li>\n</ul>\n<ol>\n<li>Activiti.cfg.xml：activiti流程引擎配置</li>\n<li>applicationContext-jpa.xml：配置持久化层springdata配置</li>\n<li>applicationContext.xml：spring相关配置</li>\n<li>Security.cfg.xml：权限框架springsecutity相关配置</li>\n<li>secutityAcl.cfg.xml：数据权限acl相关配置</li>\n<li>Spring-mvc.xml</li>\n<li>Springbatch-content</li>\n<li>Application-evn.properties:数据源配置及其他的一些参数配置</li>\n<li>Logback.xml：配置系统日志，<blockquote>\n<p>注：可根据具体需求进行配置修改</p>\n<h3 id=\"开发注意事项\"><a href=\"#开发注意事项\" class=\"headerlink\" title=\"开发注意事项\"></a>开发注意事项</h3></blockquote>\n</li>\n<li>clean install -Dmaven.test.skip=true 模块编译</li>\n<li>jetty:run 项目执行<h3 id=\"数据库版本切换\"><a href=\"#数据库版本切换\" class=\"headerlink\" title=\"数据库版本切换\"></a>数据库版本切换</h3></li>\n</ol>\n<ul>\n<li>目前系统支持mysql和Oracle数据库，由于制度报文生成接口是由不同数据库语法编写所以在切换数据库的同时要修改对应的数据库方言配置</li>\n<li>修改pom.xml<br>  <img src=\"https://git.oschina.net/uploads/images/2017/0830/164510_7b159611_1102706.png\" alt=\"输入图片说明\" title=\"图片11.png\"><br><strong>目前0.0.1-SNAPSHOT版本对应mysql;0.0.2-SNAPSHOT版本对应oracle</strong></li>\n</ul>\n<ol>\n<li>修改配置文件applicationContext-jpa.xml，改为数据库所对应的接口实现类<br> <img src=\"https://git.oschina.net/uploads/images/2017/0830/164601_eb23eff4_1102706.png\" alt=\"输入图片说明\" title=\"图片12.png\"></li>\n<li>如果需要新加SQL实现函数，则在对应的系统模块中添加，例如<br> <img src=\"https://git.oschina.net/uploads/images/2017/0830/164642_efb5c1a0_1102706.png\" alt=\"输入图片说明\" title=\"图片13.png\"><br> 实现自己的业务逻辑即可，然后在applicationContext-jpa.xml添加相应配置加入spring管理容器</li>\n</ol>\n"},{"title":"nrm -- NPM registry 管理工具","data":"2017-12-13T08:07:01.000Z","_content":"\n开发的npm registry 管理工具 nrm,  能够查看和切换当前使用的registry, 最近NPM经常 down 掉, 这个还是很有用的哈哈\n\n## Install\n\n```bash\n$ npm install -g nrm\n```\n\n## Example\n\n```bash\n$ nrm ls\n* npm ---- https://registry.npmjs.org/\n  cnpm --- http://r.cnpmjs.org/\n  eu ----- http://registry.npmjs.eu/\n  au ----- http://registry.npmjs.org.au/\n  sl ----- http://npm.strongloop.com/\n  nj ----- https://registry.nodejitsu.com/\n```\n\n```bash\n$ nrm use cnpm //switch registry to cnpm\n\tRegistry has been set to: http://r.cnpmjs.org/\n```\n\n```bash\ncmd\nnrm help // show help\nnrm list // show all registries\nnrm use cnpm // switch to cnpm\nnrm home // go to a registry home page\n```\n\n","source":"_posts/nrm -- NPM registry 管理工具.md","raw":"---\ntitle: nrm -- NPM registry 管理工具\ndata:  2017-12-13 16:07:01\ntag:\n-  NPM\n- nrm\ncategories: 前端\n---\n\n开发的npm registry 管理工具 nrm,  能够查看和切换当前使用的registry, 最近NPM经常 down 掉, 这个还是很有用的哈哈\n\n## Install\n\n```bash\n$ npm install -g nrm\n```\n\n## Example\n\n```bash\n$ nrm ls\n* npm ---- https://registry.npmjs.org/\n  cnpm --- http://r.cnpmjs.org/\n  eu ----- http://registry.npmjs.eu/\n  au ----- http://registry.npmjs.org.au/\n  sl ----- http://npm.strongloop.com/\n  nj ----- https://registry.nodejitsu.com/\n```\n\n```bash\n$ nrm use cnpm //switch registry to cnpm\n\tRegistry has been set to: http://r.cnpmjs.org/\n```\n\n```bash\ncmd\nnrm help // show help\nnrm list // show all registries\nnrm use cnpm // switch to cnpm\nnrm home // go to a registry home page\n```\n\n","slug":"nrm -- NPM registry 管理工具","published":1,"date":"2017-12-13T08:11:18.000Z","updated":"2017-12-13T08:14:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjy8000nxqs6h65gsbyz","content":"<p>开发的npm registry 管理工具 nrm,  能够查看和切换当前使用的registry, 最近NPM经常 down 掉, 这个还是很有用的哈哈</p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g nrm</span><br></pre></td></tr></table></figure>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nrm ls</span><br><span class=\"line\">* npm ---- https://registry.npmjs.org/</span><br><span class=\"line\">  cnpm --- http://r.cnpmjs.org/</span><br><span class=\"line\">  eu ----- http://registry.npmjs.eu/</span><br><span class=\"line\">  au ----- http://registry.npmjs.org.au/</span><br><span class=\"line\">  sl ----- http://npm.strongloop.com/</span><br><span class=\"line\">  nj ----- https://registry.nodejitsu.com/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nrm use cnpm //switch registry to cnpm</span><br><span class=\"line\">\tRegistry has been <span class=\"built_in\">set</span> to: http://r.cnpmjs.org/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd</span><br><span class=\"line\">nrm <span class=\"built_in\">help</span> // show <span class=\"built_in\">help</span></span><br><span class=\"line\">nrm list // show all registries</span><br><span class=\"line\">nrm use cnpm // switch to cnpm</span><br><span class=\"line\">nrm home // go to a registry home page</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>开发的npm registry 管理工具 nrm,  能够查看和切换当前使用的registry, 最近NPM经常 down 掉, 这个还是很有用的哈哈</p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g nrm</span><br></pre></td></tr></table></figure>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nrm ls</span><br><span class=\"line\">* npm ---- https://registry.npmjs.org/</span><br><span class=\"line\">  cnpm --- http://r.cnpmjs.org/</span><br><span class=\"line\">  eu ----- http://registry.npmjs.eu/</span><br><span class=\"line\">  au ----- http://registry.npmjs.org.au/</span><br><span class=\"line\">  sl ----- http://npm.strongloop.com/</span><br><span class=\"line\">  nj ----- https://registry.nodejitsu.com/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ nrm use cnpm //switch registry to cnpm</span><br><span class=\"line\">\tRegistry has been <span class=\"built_in\">set</span> to: http://r.cnpmjs.org/</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmd</span><br><span class=\"line\">nrm <span class=\"built_in\">help</span> // show <span class=\"built_in\">help</span></span><br><span class=\"line\">nrm list // show all registries</span><br><span class=\"line\">nrm use cnpm // switch to cnpm</span><br><span class=\"line\">nrm home // go to a registry home page</span><br></pre></td></tr></table></figure>\n"},{"title":"安装 node-sass 的正确姿势","date":"2017-12-01T05:27:58.000Z","_content":"\n安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。\n首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit）\n## 方法一：使用淘宝镜像\nmacOS 系统直接运行下面的命令即可：\nSASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass\n我们一般更希望能跨平台、并且直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件：\n\n```bash\nsass_binary_site=https://npm.taobao.org/mirrors/node-sass/\nphantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/\nelectron_mirror=https://npm.taobao.org/mirrors/electron/\nregistry=https://registry.npm.taobao.org\n```\n\n这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。\n## 方法二：使用梯子\n假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com加入 PAC 列表）：\n\n```bash\nnpm config set proxy http://127.0.0.1:1080\nnpm i node-sass\n\n下载完成后删除 http 代理\nnpm config delete proxy\n```\n\n嗯，这样下来就能正常安装了。\n\n\n","source":"_posts/安装 node-sass 的正确姿势 - 2.md","raw":"---\ntitle: 安装 node-sass 的正确姿势\ndate: 2017-12-1 13:27:58\ntags: \n- node-sass\ncategories: 前端\n---\n\n安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。\n首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit）\n## 方法一：使用淘宝镜像\nmacOS 系统直接运行下面的命令即可：\nSASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass\n我们一般更希望能跨平台、并且直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件：\n\n```bash\nsass_binary_site=https://npm.taobao.org/mirrors/node-sass/\nphantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/\nelectron_mirror=https://npm.taobao.org/mirrors/electron/\nregistry=https://registry.npm.taobao.org\n```\n\n这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。\n## 方法二：使用梯子\n假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com加入 PAC 列表）：\n\n```bash\nnpm config set proxy http://127.0.0.1:1080\nnpm i node-sass\n\n下载完成后删除 http 代理\nnpm config delete proxy\n```\n\n嗯，这样下来就能正常安装了。\n\n\n","slug":"安装 node-sass 的正确姿势 - 2","published":1,"updated":"2017-12-01T05:29:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjyf000rxqs6wse3k1lc","content":"<p>安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。<br>首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit）</p>\n<h2 id=\"方法一：使用淘宝镜像\"><a href=\"#方法一：使用淘宝镜像\" class=\"headerlink\" title=\"方法一：使用淘宝镜像\"></a>方法一：使用淘宝镜像</h2><p>macOS 系统直接运行下面的命令即可：<br>SASS_BINARY_SITE=<a href=\"https://npm.taobao.org/mirrors/node-sass/\" target=\"_blank\" rel=\"noopener\">https://npm.taobao.org/mirrors/node-sass/</a> npm install node-sass<br>我们一般更希望能跨平台、并且直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class=\"line\">phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/</span><br><span class=\"line\">electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class=\"line\">registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。</p>\n<h2 id=\"方法二：使用梯子\"><a href=\"#方法二：使用梯子\" class=\"headerlink\" title=\"方法二：使用梯子\"></a>方法二：使用梯子</h2><p>假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com加入 PAC 列表）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> proxy http://127.0.0.1:1080</span><br><span class=\"line\">npm i node-sass</span><br><span class=\"line\"></span><br><span class=\"line\">下载完成后删除 http 代理</span><br><span class=\"line\">npm config delete proxy</span><br></pre></td></tr></table></figure>\n<p>嗯，这样下来就能正常安装了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。<br>首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit）</p>\n<h2 id=\"方法一：使用淘宝镜像\"><a href=\"#方法一：使用淘宝镜像\" class=\"headerlink\" title=\"方法一：使用淘宝镜像\"></a>方法一：使用淘宝镜像</h2><p>macOS 系统直接运行下面的命令即可：<br>SASS_BINARY_SITE=<a href=\"https://npm.taobao.org/mirrors/node-sass/\" target=\"_blank\" rel=\"noopener\">https://npm.taobao.org/mirrors/node-sass/</a> npm install node-sass<br>我们一般更希望能跨平台、并且直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class=\"line\">phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/</span><br><span class=\"line\">electron_mirror=https://npm.taobao.org/mirrors/electron/</span><br><span class=\"line\">registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<p>这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。</p>\n<h2 id=\"方法二：使用梯子\"><a href=\"#方法二：使用梯子\" class=\"headerlink\" title=\"方法二：使用梯子\"></a>方法二：使用梯子</h2><p>假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com加入 PAC 列表）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> proxy http://127.0.0.1:1080</span><br><span class=\"line\">npm i node-sass</span><br><span class=\"line\"></span><br><span class=\"line\">下载完成后删除 http 代理</span><br><span class=\"line\">npm config delete proxy</span><br></pre></td></tr></table></figure>\n<p>嗯，这样下来就能正常安装了。</p>\n"},{"title":"travis测试","data":"2017-12-20T00:07:01.000Z","_content":"\nqqqqqqqqqqq1111.  \n我的测试  111","source":"_posts/travis测试.md","raw":"---\ntitle: travis测试\ndata:  2017-12-20 08:07:01\ntag:\n-  travis\ncategories: 干货\n---\n\nqqqqqqqqqqq1111.  \n我的测试  111","slug":"travis测试","published":1,"date":"2017-12-20T09:55:03.000Z","updated":"2017-12-21T02:02:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjyj000uxqs6pc20dkbb","content":"<p>qqqqqqqqqqq1111.<br>我的测试  111</p>\n","site":{"data":{}},"excerpt":"","more":"<p>qqqqqqqqqqq1111.<br>我的测试  111</p>\n"},{"title":"把项目同时托管到github和oschina","data":"2017-12-20T00:07:01.000Z","_content":"\n## 1、添加远程地址，给地址命名来区分\n\n```bash\ngit remote add oschina https://git.oschina.net/xxx/xxx.git\n或者\ngit remote add github https://github.com/xxx/xxx.git\n```\n\n## 2、查看远程地址\n\n```bash\ngit remote -v\n```\n\n## 3、然后push\n\n```bash\ngit push -u oschina\n或者\ngit push -u github\n```\n\n","source":"_posts/把项目同时托管到github和oschina.md","raw":"---\ntitle: 把项目同时托管到github和oschina\ndata:  2017-12-20 08:07:01\ntag:\n-  Git\ncategories: Git\n---\n\n## 1、添加远程地址，给地址命名来区分\n\n```bash\ngit remote add oschina https://git.oschina.net/xxx/xxx.git\n或者\ngit remote add github https://github.com/xxx/xxx.git\n```\n\n## 2、查看远程地址\n\n```bash\ngit remote -v\n```\n\n## 3、然后push\n\n```bash\ngit push -u oschina\n或者\ngit push -u github\n```\n\n","slug":"把项目同时托管到github和oschina","published":1,"date":"2017-12-20T00:45:36.000Z","updated":"2017-12-20T00:57:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjyn000xxqs60jkl3q90","content":"<h2 id=\"1、添加远程地址，给地址命名来区分\"><a href=\"#1、添加远程地址，给地址命名来区分\" class=\"headerlink\" title=\"1、添加远程地址，给地址命名来区分\"></a>1、添加远程地址，给地址命名来区分</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add oschina https://git.oschina.net/xxx/xxx.git</span><br><span class=\"line\">或者</span><br><span class=\"line\">git remote add github https://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、查看远程地址\"><a href=\"#2、查看远程地址\" class=\"headerlink\" title=\"2、查看远程地址\"></a>2、查看远程地址</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、然后push\"><a href=\"#3、然后push\" class=\"headerlink\" title=\"3、然后push\"></a>3、然后push</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u oschina</span><br><span class=\"line\">或者</span><br><span class=\"line\">git push -u github</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、添加远程地址，给地址命名来区分\"><a href=\"#1、添加远程地址，给地址命名来区分\" class=\"headerlink\" title=\"1、添加远程地址，给地址命名来区分\"></a>1、添加远程地址，给地址命名来区分</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add oschina https://git.oschina.net/xxx/xxx.git</span><br><span class=\"line\">或者</span><br><span class=\"line\">git remote add github https://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、查看远程地址\"><a href=\"#2、查看远程地址\" class=\"headerlink\" title=\"2、查看远程地址\"></a>2、查看远程地址</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、然后push\"><a href=\"#3、然后push\" class=\"headerlink\" title=\"3、然后push\"></a>3、然后push</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u oschina</span><br><span class=\"line\">或者</span><br><span class=\"line\">git push -u github</span><br></pre></td></tr></table></figure>\n"},{"title":"快速掌握Dockerfile","data":"2017-12-12T00:58:01.000Z","_content":"\n转载自[快速掌握Dockerfile][1]\n## docker镜像的简单剖析\ndocker的images,我们可以理解为积木, 一层一层往上搭, 最后完成一个工程化的大项目.   \n在最初,docker实际上,只有一个静态的image(Ps: read-only). 相当于只能读, 所以, 你所有的改动并不会影响到原来的image上, 只会一层一层的叠加, 比如, 你在Ubuntu的image上面, 再接一层nodeJS的image. 实际上的结果是, 两个image叠加起来.\n这里放一张 **the Docker book**的说明图:\n![][image-1]\ndocker 在下载image的时候,会在/var/lib/docker目录下创建相关的image 目录. 而运行的container则会放在/var/lib/docker/containers中.\n另外,docker中的image,是存储在docker仓库. 现在,我们通过快速创建自已的仓库来仔细了解一下docker是怎样拥有这样一个完善的生态的.\n\n## docker 仓库\n首先, 要想拥有自己的docker 仓库, 你得有一个自己的docker账号.so, 那就想apply 一个呗. 在docker hub上面注册一下自己的账号就行.\n\n## 登录指令\n在docker中,不仅支持web查看docker中的内容, 而且还支持使用命令行登录.\n\n```bash\n// 登录到docker\ndocker login // 然后输入账户密码就ok了\n// 使用完毕,想要登出\ndocker logout\n```\n\n实际上,docker会将你的认证信息存放在. /.docker/config.json当中。\n\n## images 常用命令\n如果浏览了上面的docker仓库, 会发现在一个repository里面会存在很多images, 比如ubuntu的repository.不同的images发布,代表的都是特定的版本系统. 所以,在拉取的时候,需要额外注意一下你需要的指定docker images.\n\n## images的拉取\n在container中,我们讲过,使用docker run的时候, 你会发现如果你的images里面没有存在指定的image时, docker会主动去docker hub里面找,然后下载,并且自动运行.\n\n```bash\n// 运行最新版的ubuntu image\ndocker run -t -i ubuntu:latest\n```\n\n如果,你想自己手动下载images的话,可以直接pull\n\n```bash\n// 手动拉取images\ndocker pull ubuntu:latest\n// 拉取12.04版本的ubuntu images\ndocker pull ubuntu:12.04\n```\n\n如果在拉取的时候,想知道这个image是否是真正存在的话,就可以使用.docker 提供的搜索指令.\n\n## 搜索指定docker\n在docker中,可以使用自带的search命令,搜索所有含有指定term的image. 相当于js中的search 方法.\n\n```bash\n// 搜索name中含有demo的image\ndocker search demo\n// 结果为: 名字. 通常为: author/image_name . 通常搜索的就是这个\n// 描述: 就是一段文字描述\nNAME  DESCRIPTION  STARS OFFICIAL   AUTOMATED\n```\n\n查到之后,我们就可以使用pull将指定的库,拉下来了.\n\n## 创建自己的image\n上面说过, contianer是copy image运行的进程容器,image是不会变的read-only 块. 但是,如果我们在container里面, 改动了一些设置,比如,下载了node, 而且,我想要保存我这次改动, 以至于,下次我想重新,启动该image时, 他已经具备了node.\n\n```bash\n// 现在我再ubuntu:latest上面安装了node\n// 伪代码\nnpm install node -g\n```\n\ndocker提供了一个非常快捷的方式就是创建自己的docker image. 使用docker commit.\n\n```bash\n// 查看刚才改动的container ID\ndocker ps -a -q -l\n// 得到 docker_id, 提交到自己的库中\ndocker commit docker_id villainHR/node\n// 之后会返回新的image id\n```\n\n需要注意,docker commit提交的并不是一个整体的100+MB的ubuntu+node. 他只会将两个仓库的差异提交,比如原来image和新的image比起来,就是多了一个npm install node -g命令.\n\n## 使用Dockerfile\nDockerfile是为了迅速的构建image而出现的. 他与docker commit 的区别在于. 能够迅速的更替历史image 命令. 比如,我们以前下载的npm是version 2, 现在想要更换为npm@3的话,则难度就不是一般的了. 但是,如果我们能够像写命令一样将下载的配置命令下载Dockerfile里面, 那么以后我们想要更换版本,就是很方便的啦.  \nok, 现在我们来了解一下Dockerfile是怎样的运行的.\ndockerfile demo讲解\n这里,我们利用dockerfile 来搭建一个简单的webServer. 首先创建一个你自己的dockerfile目录\n\n```bash\nmkdir first_docker\ncd first_docker\ntouch Dockerfile\n```\n\n然后, 确保你有ubuntu:latest image.因为, 接下来我们就是基于它,来搭建我们的server.\n\n```bash\nfirst dockerfile demo\nFROM ubuntu:latest\n设置该dockerfile的作者和联系邮箱\nMAINTAINER Jimmy \"villainhr@gmail.com\"\n开始配置环境, 下载apt-get,生成index.html的文件\nRUN apt-get update && apt-get install -y nginx\nRUN echo 'first demo' > /usr/share/nginx/html/index.html\n暴露server的port\nEXPOSE 80\n```\n\n说一下上面的命令内涵.\n•\tFROM: 用来指定第一层image, 这是必须有的. 并且指定的image是存在在你的computer中. 相当于是 docker run.  \n\n•\tRUN: 这是用来在container中,做出相应的修改. 相当于 修改+docker commit xxx. 给原来的image加上一层layer. 然后, docker会在你commit新一层之后,重新docker run你最新改动过的image  \n\n•\tMAINTAINER: 设置作者和联系邮箱.其实就是docker commit 后面的Name参数. 而且加上了联系邮箱. 这是在dockerfile 运行完后,会自动添加到image上的.  \n\n•\tEXPOSE: 用来给最新的container 设置与外部交流的port  \n\n上面简单的介绍了基本的dockerfile的命令. 不过, 这尼玛太简单了,不符合我们一贯追求到底的风格.  \n这里, 我们在来细说一下RUN这个命令. 实际上, 这应该是dockerfile的关键. RUN的原理很简单, 就是commit + run. 先创建一个新的image 然后 在这个基础上将原有的container替换为新的,如果某一步的RUN发生错误,则container会停在那个阶段, 这样,你可以直接进入该container去查看,你那一步的RUN发生了什么BUG。 另外, 使用RUN的时候, 需要注意, 由于,dockerfile是由上到下解析的, 比如你一开始FROM ubuntu的image, 那么此时的环境是停留在ubuntu的shell中的.  \n比如:\n\n```bash\nRUN touch demo.js\n// 等同于\n/bin/sh -c touch demo.js\n```\n\n所以, 如果你调用的image 并没有shell的话, 那么久需要使用exec调用系统shell 来执行命令.\n\n```bash\n// 调用系统的shell来运行, 实际上就是 exec xxx xxx xxx.\nRUN [\"npm\",\"install\",\"node\"]\n```\n\n## 运行dockerfile\n上面的dockerfile文件配置好了之后,就轮到我们运行dockerfile.直接运行docker build即可.\n\n```bash\n// 注意后面的\".\", 用来指定搜索dockerfile文件的路径. \ndocker build -t=\"jimmy/first_dockerfile\" .\n```\n\n说一下docker build的指令吧.\n\n```bash\n// 基本格式为:\ndocker build -t=\"repository/name:tag\"  directory\n// -t用来指定生成的image的name,比如仓库,image的名字以及他的tag,如果你不指定tag, 那么docker会自动添加latest代替。\n// directory 用来相对于当前运行build的目录, 搜索指定的dockerfile.当然,你也可以使用绝对路径了\n```\n\n顺利的话,应该就会有, 下列的信息出来.\n\n```bash\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM ubuntu:latest\n ---> c5f1cf30c96b\nStep 2 : MAINTAINER jimmy \"villainhr@gmai.com\"\n ---> Running in 078148a5086a\n ---> 11b061f665d1\nRemoving intermediate container 078148a5086a\nStep 3 : RUN cd /var\n ---> Running in ffd3141e64c8\n ---> a4d7c5303b60\nRemoving intermediate container ffd3141e64c8\nStep 4 : RUN touch demo.js\n ---> Running in c8393a6fcc98\n ---> 109b402b9adc\nRemoving intermediate container c8393a6fcc98\nStep 5 : EXPOSE 80\n ---> Running in 2c064f4bac57\n ---> ff7ad58a5d8a\nRemoving intermediate container 2c064f4bac57\nSuccessfully built ff7ad58a5d8a\n```\n\n然后, 你可以使用docker images查看.就会发现多出来一个image.\n\n## dockerfile cache\n上面已经提到过,使用docker build的时候,如果你的dockerfile中的某一步出现问题的话,你生成的image会停留在那一步.当你fix errors时, 重新运行docker build, 此时,docker是不会真的重头来建一遍的,他会使用你改动line的前一个image,然后以此为基点继续向下构建.  \n不过,如果你使用缓存的话,他前面的版本id是不会发生改变的.如果你想完整的得到一个新的ID的话,就可以在build的时候,禁用掉cache.\n\n```bash\ndocker build --no-cache -t=\"jimmy/first_dockerfile\" .\n```\n\n不过,该方法是不推荐的. 因为一个非常棒的cache机制,就被你硬生生的cancel. 而且,这也极力不推荐使用该方法进行cache的取消.以为,有些地方,我们完全可以利用cache来加快速度.这就需要使用到ENV关键字.来帮助我们,另外利用cache.  \n在讲解ENV之前,先给大家讲解一下docker cache的运行机理.  \n（是不是感觉很激动）  \n实际上,机理就一句话:ID命中. 因为docker在你每次运行一行命令的时候,会自动生成一个id值.\n\n```bash\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM ubuntu:latest\n ---> c5f1cf30c96b  // 这就是ID值\n```\n\ndocker借由这个ID值,来判断是否有cache镜像.所以,这里就需要借一下ENV这个比较费的指令,来灵活的帮助我们使用cache.\n\n## 配置化cache\nENV的就是给docker来设置变量的. 基本格式为:\n\n```bash\n一个一个的赋值\nENV key value\n// demo:\nENV name jimmy\nENV age 18\n另外,还可以一起赋值\nENV key=value[...]\n// demo:\nENV name=jimmy age=18\n```\n\n而通过ENV我们就可以完美的告诉docker 从这里开始,你就不能使用cache,自己的重新来.(因为,每条指令都会生成layer并且有独立的id,一旦你更改的ENV,那么从该指令开始id都会发生改变,也就匹配不到缓存了)\n看个demo:\n\n```bash\n第一个dockerfile\nFROM ubuntu:latest\nMAINTAINER jimmy \"villainhr@gmai.com\"\nENV REFRESH first # 这里设置的是refresh=first\nRUN cd /var\nRUN touch demo.js\nEXPOSE 80\n\n// 使用docker build ... 后面就会生成一系列新的id和images\n// 现在修改dockerfile\n第二个dockerfile\nFROM ubuntu:latest\nMAINTAINER jimmy \"villainhr@gmai.com\"\nENV REFRESH second # 这里设置的是refresh=second\nRUN cd /var\nRUN touch demo.js\nEXPOSE 80\n\n// 开始运行docker build... 你会发现,从下面语句开始.\nENV REFRESH second\n// 其docker id就已经发生了改变,并且docker 没有了use cache的提示.说明,下面就没有命中缓存了. 所以,如果你想在某一段不使用缓存,只需要将ENV后面的value改变即可.\n```\n\n创建完后, 我们可以使用docker history,查看一下刚才创建的image的整个流程.\n\n```bash\n// 查看image创建的过程\ndocker history jimmy/first_dockerfile \n// 输出的结果为:\n2322ddc85cc3        10 hours ago        /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B                 \nb39397abc7aa        10 hours ago        /bin/sh -c touch demo.js                        0 B                 \n3c9a4daf4c42        10 hours ago        /bin/sh -c cd /var                              0 B                 \nb1c2f890a262        10 hours ago        /bin/sh -c #(nop) ENV REFRESH=second            0 B                 \n2cf0ee3c373c        10 hours ago        /bin/sh -c #(nop) MAINTAINER jimmy \"villainhr   0 B              \n```\n\n俺的目的,其实是想让你们看看,docker在每一层是怎么执行的--/bin/sh. 了解了之后,我们就继续了.\n\n## docker container的接口暴露\n上面通过dockerfile 已经暴露了一个80接口,用来和外部通信。 不过,如果我们没有使用EXPOSE暴露接口的话, 那应该怎么做呢？  \n我们可以直接在外部运行docker image, 手动指定暴露的端口.\n\n```bash\n同样,暴露80端口给外部交互\ndocker run -d -p 80 --name demo jimmy/node \\\nnode -jimmy app.js\n\n-d是daemon的意思\n-p 80 表示暴露80的port给外部\nnode -jimmy app.js 表示在jimmy/node image里面运行的指令\n```\n\n这里, 我们需要额外了解一下80端口的开启. docker 其实是在底层上面,虚拟化了存储. 并且,docker在运行的时候,会自动向主机要一个ip(假的), 相当于,有了自己的host. (这不就一个主机吗？)  \n这里我们开启的80端口,是docker在内部虚拟开启的, 他会从32768 到 61000端口之间,随机抽一个映射到docker开启的80端口上, 依此来和外部进行真正的交互(膜拜///).\n\n```bash\n使用docker ps -l 来查看开启情况\ndocker ps -l\n得到: 只截取了一部分.\n0.0.0.0:49154->80 tcp\n或者指定查看docker端口开启情况\ndocker port c96f2c18bb64 80 // ID也可以使用name代替\n返回:\n 0.0.0.0:49154\n```\n\n## 手动指定端口\n如果你不想让docker决定的绑定的接口是哪一个,ok, 你可以自己指定.\n\n```bash\n手动指定端口\n指定docker的8080连接到container暴露的80端口\ndocker run -d -p 8080:80 --name demo jimmy/node \\\nnode -jimmy app.js\n甚至你也可以指定ip+port\n指定docker的127.0.0.1:8080连接container的80\ndocker run -d -p 127.0.0.1:8080:80 --name demo jimmy/node \\\nnode -jimmy app.js\n```\n\n## 利用EXPOSE\n在写dockerfile的时候,我们已经了解了,使用EXPOSE可以完美的实现端口的暴露. 但如果,我们在dockerfile里面暴露多个port的话,那么-p的参数,感觉有点鸡肋啊喂  \n不过,现在我们可以使用-P(注意是大写). 来手动开启所有在dockerfile中,通过EXPOSE暴露的端口.\n\n```bash\ndocker run -d -P --name demo jimmy/node \\\nnode -jimmy app.js\n```\n\n## 外部访问\n通过端口开启之后,我们就可以间接的访问docker的路由, 来访问在docker里面开启的端口了.\n\n```bash\n假如上面我们通过dockre暴露的端口是34251的话,就可以在docker环境外访问了.\nping localhost:34251\n```\n\n## dockerfile常用指令\n自动化运行CMD\n你是不是已经厌烦了使用docker run 来运行命令了呢？ 你是不是已经讨厌重复的copy命令运行了呢？  \n那么请使用CMD吧.   \nCMD的作用是,用来指定当你调其对应的container时, 运行的命令.  \n比如在dockerfile中,指定/bin/bash.\n\n```bash\n当调起container时,运行/bin/bash\ndocker run  -t -i jimmy/ubuntu:latest /bin/bash\n等同于在dockerfile中指定CMD\nCMD [\"/bin/bash\"]\n// 运行docker run\ndocker run -t -i jimmy/ubuntu:latest\n```\n\n不过,如果你在run后面手动指定指令运行的话,会默认覆盖掉CMD提供的命令.  \n熟悉了CMD,感觉有种RUN的感觉. 但,这两者的区别还是很大的\n•\tRUN: 一般是用来给image增加layer来完善image, 他一旦执行完,就和后面的运行没有关系了  \n\n•\tCMD: 这个在docker build过程中,是没有半毛钱关系的. 他只和在调用image时,关系比较大  \n\n## 强制运行ENTRYPOINT\n这里的ENTRYPOINT和CMD很相似. 可以说,在一定程度上两者可以互相替代,但,两者的实际意义相差还是挺大的.  \nENTRYPOINT的主要功能是强制执行的环境.\n\n```bash\n指定ENTRYPOINT为/bin/sh\nENTRYPOINT [\"/bin/sh\"]\n// 然后在build之后,调起container\n我们尝试在run后面加上参数:\ndocker run -t -i jimmy/demo /bin/bash/\n// 不出意外的话,会得到一个bug提示:\n>>/bin/sh: 0: Can't open /bin/bash/\n```\n\n所以, ENTRYPOINT的主要功能实际上是,指定了内部运行命令的解析器. 而使用docker run添加的命令,会被当做参数添加给ENTRYPOINT.\n\n```bash\n已经指定了ENTRYPOINT [\"/bin/sh\"]\n运行docker run\ndocker run -t -i jimmy/demo /bin/bash/\n实际上相当于(不出错才怪嘞...)\n/bin/sh /bin/bash/\n```\n\n另外,我们还可以使用CMD配合ENTRYPOINT写成默认参数的效果.\n\n```bash\n默认执行 /bin/bash default.sh\nENTRYPOINT [\"/bin/bash\"]\nCMD [\"default.sh\"]\n如果你在docker run中指定了参数的话,则CMD会默认被代替 \ndocker run jimmy/demo sam.sh\n```\n\n不过,CMD和ENTRYPOINT都只能在dockerfile里面出现一次.\n\n## 指定运行目录WORKDIR\n既然,我们能够在dockerfile里面运行指定的命令。 但,有时,我们仅仅是想在不同的目录中执行不同的命令. 那,在dockerfile中,如何做到灵活的目录切换呢？  \n那就得使用docker提供的WORKDIR命令了.\n\n```bash\n在/var/data里面创建data.js\nWORKDIR /var/data\nRUN touch data.js\n然后在/etc 下创建data.conf文件\nWORKDIR /etc\nRUN touch data.conf\n```\n\n并且当你在使用docker run时,他也会停留在使用WORKDIR指定的目录中.\n\n## 环境变量的设置ENV\nENV在dockerfile里面的用处,应该算是灰常大的. 什么灵活更新,什么变量设置,什么更改全局变量等. 都是so easy.   \n那ENV到底是用来干嘛的?  \n答: 就是用来设置变量的啊喂. 只是他是设置全局变量.  \n比如像PATH神马的之类的.\n\n```bash\n设置一个DATA的全局变量.\nENV DATA=jimmy\n```\n\nENV最独特之处在于,他所设置的变量,会在你运行的时候生效.即,如果你修改了PATH,他也会在container中立即生效.\n\n```bash\n修改环境变量\nENV PATH=$PATH:/user/bin\n// 现在进入到运行的container中\necho $PATH\n>> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data\n```\n\n## 挂载通用盘VOLUME\n在说里面正式的内容之前,我们先来说一下,什么叫做VOLUME. 说人话吧,VOLUME叫做数据卷, 相当于通用盘一样的东西. 他其实也是一个存储装置,我们就把他叫做硬盘吧. 这个硬盘不普通,有\\>1的外接口.(说人话) 每一个外接口,都可以接入到一个操作系统里面. 即,实现了多个系统的数据共享.  \n一句话:\n> VOLUME就是一个数据共享盘\n而,docker秉承着,虚拟储存idea, 想下面idea践行到底.\n> wirte once, run anywhere\n(感觉,在哪见过)  \n所以, dockerfile提供了一个VOLUME的指令,能够让我们指定数据卷的位置.\n\n```bash\n指定/opt/data为数据卷\nVOLUME [\"/opt/data\"]\n指定多个目录为数据卷/opt/data, /opt/project\nVOLUME [\"/opt/data\",\"/opt/project\"]\n```\n\n当然,关于数据卷的操作,肯定不止挂载这一点,还有迁移,备份等等,相关操作. 具体,可以参考: Docker VOLUME\n\n## 添加外部文件ADD\n有时,我们仅仅是想将外部文件copy到container中,docker有办法吗？  \nnonsense  \ndocker 提供了ADD命令,来帮助我们完成文件的添加. 不过,这里ADD有点限制, 即, 你添加的文件或者目录,只能在docker build运行的目录下, 因为,这是docker在调起container的时候,只将该目录放进了daemon(尴尬)\n\n```bash\n现假设,docker build运行的目录为: /data\n// 只能添加指定目录下\n// 将/data/sam.js 添加到image中的/opt/node/sam.js\n// 如果存在该文件,则不会被覆盖\nADD sam.js /opt/node/\n添加文件,还可以使用通配符\n// 将所有的js文件,添加到node目录下\nADD *.js /opt/node/\n如果destination不是绝对路径,则相对于最近的WORKDIR\n// 如果最近的WORKDIR为/var\n// 则下列添加的路径为/var/opt/node\nADD *.js opt/node/\n```\n\n当文件被添加到指定目录中时,该文件的权限是755,并且UID和GID都是0.  \nADD 还支持url添加,以及文件自动解压.\n\n```bash\n使用url添加\n// 将指定路由的文件放到根目录当中\nADD http://example.com/foobar /\n自动解压tar.gz文件\n// 将文件解压过后放在指定目录中\nADD latest.tar.gz /var/www/wordpress/\n```\n\n## 纯粹的COPY\nCOPY和ADD非常类似. 我们可以做个类比:\nADD 包含 COPY\nCOPY做的事情比不上ADD, 他比ADD少了解压缩和URL下载的功能. 不过,他耗费的性能比较少,他只做纯粹的添加和下载.他的结构和ADD一毛一样. 不过, 有一点,COPY的时候,如果遇到目录不存在的情况下,COPY会自动创建\n\n```bash\nCOPY file.js /opt/data/\n```\n\n## 添加个人信息LABEL\n顾名思义,使用LABEL就是给你的image打上独一无二的标签.让别人能够了解,这个Image是属于你的. 又或是,用来提醒你自己,这个image现在处于哪一个版本状态.\n\n```bash\n设置自己的label\nLABEL owner=\"jimmy\" version=\"0.0.1\"\n```\n\n在创建完image之后, 我们可以使用docker inspect来查看我们已经打的LABEL\n\n```bash\ndocker inspect jimmy/node\n...\nlabels:{\nowner:\"jimmy\",\nversion:\"0.0.1\"\n}\n...\n```\n\n本人觉得, 这个指令其实真的,有时, 母鸡用到什么地方去...  \n并且,书写的时候,最好多个连着写,因为这样只会增加一层image.(image的层数是有限制的)\n\n## 参数形式ARG\n这是docker提供的另外一个,让我有点懵逼的命令. 他的实际效果和ENV的区别可以趋近于无。\n\n```bash\n使用ARG定义变量\nARG buildno\n设置默认值\nARG user1=someuser\n```\n\n当然,我们可以在命令中,手动指定替换.\n\n```bash\n在dockerfile定义了默认变量\nARG user=jimy\n在运行时,进行手动替换\ndocker build --build-arg user=sam -t jimmy/demo .\n```\n\n上面说了ARG和ENV比较类似,不过,里面的区别还是有的. 即, ARG只能用在docker build的阶段, 并且不会被保存在image中,这就是和ENV的区别.\n\n## 模板image之ONBUILD\n因为dockerfile的构建的层数有限制,所以,这也带给了我们一些麻烦, 如果搭建的环境过多,则会造成写到一半,发现dockerfile已经full. 这时候, 就轮到ONBUILD出场了. ONBUILD的作用在于,他可以完美的实现模板image的搭建.   \nONBUILD的主要作用在于,他定义的命令,可以在子dockerfile中使用.(md... 好绕口)\n\n```bash\n使用ONBUILD 默认下载Apache\nONBUILD RUN apt-get update && apt-get install -y apache2\n\n// 然后运行docker file 会得到下列结果\n Step 3 : ONBUILD RUN apt-get update && apt-get install -y apache2\n   ---> Running in 0e117f6ea4ba\n   ---> a79983575b8\n\n//然后生成一个新的image,我们这里暂且叫他jimmy/demo\n```\n\n接下来,我们再来写一个dockerfile\n\n```bash\n这里继承上面的jimmy/demo\nFROM jimmy/demo:latest\nENV SEX=001\n\n// 运行上面的dockerfile,得到:\nStep 0 : FROM jimmy/demo\nExecuting 1 build triggers\n   Step onbuild-0 : ADD . /var/www/\n   ---> 1a018213a59d\n   ---> 1a018213a59d\n Step 1: ENV SEX=001\n ...\n```\n\n细心的童鞋可以发现这一条命令:\n\n```bash\n Step onbuild-0 : RUN apt-get update && apt-get install -y apache2\n   ---> 1a018213a59d\n   ---> 1a018213a59d\n```\n\n他居然在这里自动运行了. 所以,我们可以将ONBUILD命令理解为模板命令. 即,子dockerfile里面运行时同样生效(这里,我没有说grandchildren的事).  \n但ONBUILD只能往下延伸一级. 相当于你用ONBUILD定义的命令,有两次有效次数,一次在build原来Image时,已经用掉了. 所以, 另外一次(在子dockerfile中使用)用掉了之后就无效了. grandchildren dockerfile就没法使用了.\n\n\n\n\n[1]:\thttps://segmentfault.com/a/1190000006186977?utm_source=tuicool&utm_medium=referral\n\n[image-1]:\thttp://p09eeagrw.bkt.clouddn.com/59773500.jpg","source":"_posts/快速掌握dockerfile.md","raw":"---\ntitle: 快速掌握Dockerfile\ndata:  2017-12-12 08:58:01\ntag:\n- Docker\n- Dockerfile\ncategories: Docker\n---\n\n转载自[快速掌握Dockerfile][1]\n## docker镜像的简单剖析\ndocker的images,我们可以理解为积木, 一层一层往上搭, 最后完成一个工程化的大项目.   \n在最初,docker实际上,只有一个静态的image(Ps: read-only). 相当于只能读, 所以, 你所有的改动并不会影响到原来的image上, 只会一层一层的叠加, 比如, 你在Ubuntu的image上面, 再接一层nodeJS的image. 实际上的结果是, 两个image叠加起来.\n这里放一张 **the Docker book**的说明图:\n![][image-1]\ndocker 在下载image的时候,会在/var/lib/docker目录下创建相关的image 目录. 而运行的container则会放在/var/lib/docker/containers中.\n另外,docker中的image,是存储在docker仓库. 现在,我们通过快速创建自已的仓库来仔细了解一下docker是怎样拥有这样一个完善的生态的.\n\n## docker 仓库\n首先, 要想拥有自己的docker 仓库, 你得有一个自己的docker账号.so, 那就想apply 一个呗. 在docker hub上面注册一下自己的账号就行.\n\n## 登录指令\n在docker中,不仅支持web查看docker中的内容, 而且还支持使用命令行登录.\n\n```bash\n// 登录到docker\ndocker login // 然后输入账户密码就ok了\n// 使用完毕,想要登出\ndocker logout\n```\n\n实际上,docker会将你的认证信息存放在. /.docker/config.json当中。\n\n## images 常用命令\n如果浏览了上面的docker仓库, 会发现在一个repository里面会存在很多images, 比如ubuntu的repository.不同的images发布,代表的都是特定的版本系统. 所以,在拉取的时候,需要额外注意一下你需要的指定docker images.\n\n## images的拉取\n在container中,我们讲过,使用docker run的时候, 你会发现如果你的images里面没有存在指定的image时, docker会主动去docker hub里面找,然后下载,并且自动运行.\n\n```bash\n// 运行最新版的ubuntu image\ndocker run -t -i ubuntu:latest\n```\n\n如果,你想自己手动下载images的话,可以直接pull\n\n```bash\n// 手动拉取images\ndocker pull ubuntu:latest\n// 拉取12.04版本的ubuntu images\ndocker pull ubuntu:12.04\n```\n\n如果在拉取的时候,想知道这个image是否是真正存在的话,就可以使用.docker 提供的搜索指令.\n\n## 搜索指定docker\n在docker中,可以使用自带的search命令,搜索所有含有指定term的image. 相当于js中的search 方法.\n\n```bash\n// 搜索name中含有demo的image\ndocker search demo\n// 结果为: 名字. 通常为: author/image_name . 通常搜索的就是这个\n// 描述: 就是一段文字描述\nNAME  DESCRIPTION  STARS OFFICIAL   AUTOMATED\n```\n\n查到之后,我们就可以使用pull将指定的库,拉下来了.\n\n## 创建自己的image\n上面说过, contianer是copy image运行的进程容器,image是不会变的read-only 块. 但是,如果我们在container里面, 改动了一些设置,比如,下载了node, 而且,我想要保存我这次改动, 以至于,下次我想重新,启动该image时, 他已经具备了node.\n\n```bash\n// 现在我再ubuntu:latest上面安装了node\n// 伪代码\nnpm install node -g\n```\n\ndocker提供了一个非常快捷的方式就是创建自己的docker image. 使用docker commit.\n\n```bash\n// 查看刚才改动的container ID\ndocker ps -a -q -l\n// 得到 docker_id, 提交到自己的库中\ndocker commit docker_id villainHR/node\n// 之后会返回新的image id\n```\n\n需要注意,docker commit提交的并不是一个整体的100+MB的ubuntu+node. 他只会将两个仓库的差异提交,比如原来image和新的image比起来,就是多了一个npm install node -g命令.\n\n## 使用Dockerfile\nDockerfile是为了迅速的构建image而出现的. 他与docker commit 的区别在于. 能够迅速的更替历史image 命令. 比如,我们以前下载的npm是version 2, 现在想要更换为npm@3的话,则难度就不是一般的了. 但是,如果我们能够像写命令一样将下载的配置命令下载Dockerfile里面, 那么以后我们想要更换版本,就是很方便的啦.  \nok, 现在我们来了解一下Dockerfile是怎样的运行的.\ndockerfile demo讲解\n这里,我们利用dockerfile 来搭建一个简单的webServer. 首先创建一个你自己的dockerfile目录\n\n```bash\nmkdir first_docker\ncd first_docker\ntouch Dockerfile\n```\n\n然后, 确保你有ubuntu:latest image.因为, 接下来我们就是基于它,来搭建我们的server.\n\n```bash\nfirst dockerfile demo\nFROM ubuntu:latest\n设置该dockerfile的作者和联系邮箱\nMAINTAINER Jimmy \"villainhr@gmail.com\"\n开始配置环境, 下载apt-get,生成index.html的文件\nRUN apt-get update && apt-get install -y nginx\nRUN echo 'first demo' > /usr/share/nginx/html/index.html\n暴露server的port\nEXPOSE 80\n```\n\n说一下上面的命令内涵.\n•\tFROM: 用来指定第一层image, 这是必须有的. 并且指定的image是存在在你的computer中. 相当于是 docker run.  \n\n•\tRUN: 这是用来在container中,做出相应的修改. 相当于 修改+docker commit xxx. 给原来的image加上一层layer. 然后, docker会在你commit新一层之后,重新docker run你最新改动过的image  \n\n•\tMAINTAINER: 设置作者和联系邮箱.其实就是docker commit 后面的Name参数. 而且加上了联系邮箱. 这是在dockerfile 运行完后,会自动添加到image上的.  \n\n•\tEXPOSE: 用来给最新的container 设置与外部交流的port  \n\n上面简单的介绍了基本的dockerfile的命令. 不过, 这尼玛太简单了,不符合我们一贯追求到底的风格.  \n这里, 我们在来细说一下RUN这个命令. 实际上, 这应该是dockerfile的关键. RUN的原理很简单, 就是commit + run. 先创建一个新的image 然后 在这个基础上将原有的container替换为新的,如果某一步的RUN发生错误,则container会停在那个阶段, 这样,你可以直接进入该container去查看,你那一步的RUN发生了什么BUG。 另外, 使用RUN的时候, 需要注意, 由于,dockerfile是由上到下解析的, 比如你一开始FROM ubuntu的image, 那么此时的环境是停留在ubuntu的shell中的.  \n比如:\n\n```bash\nRUN touch demo.js\n// 等同于\n/bin/sh -c touch demo.js\n```\n\n所以, 如果你调用的image 并没有shell的话, 那么久需要使用exec调用系统shell 来执行命令.\n\n```bash\n// 调用系统的shell来运行, 实际上就是 exec xxx xxx xxx.\nRUN [\"npm\",\"install\",\"node\"]\n```\n\n## 运行dockerfile\n上面的dockerfile文件配置好了之后,就轮到我们运行dockerfile.直接运行docker build即可.\n\n```bash\n// 注意后面的\".\", 用来指定搜索dockerfile文件的路径. \ndocker build -t=\"jimmy/first_dockerfile\" .\n```\n\n说一下docker build的指令吧.\n\n```bash\n// 基本格式为:\ndocker build -t=\"repository/name:tag\"  directory\n// -t用来指定生成的image的name,比如仓库,image的名字以及他的tag,如果你不指定tag, 那么docker会自动添加latest代替。\n// directory 用来相对于当前运行build的目录, 搜索指定的dockerfile.当然,你也可以使用绝对路径了\n```\n\n顺利的话,应该就会有, 下列的信息出来.\n\n```bash\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM ubuntu:latest\n ---> c5f1cf30c96b\nStep 2 : MAINTAINER jimmy \"villainhr@gmai.com\"\n ---> Running in 078148a5086a\n ---> 11b061f665d1\nRemoving intermediate container 078148a5086a\nStep 3 : RUN cd /var\n ---> Running in ffd3141e64c8\n ---> a4d7c5303b60\nRemoving intermediate container ffd3141e64c8\nStep 4 : RUN touch demo.js\n ---> Running in c8393a6fcc98\n ---> 109b402b9adc\nRemoving intermediate container c8393a6fcc98\nStep 5 : EXPOSE 80\n ---> Running in 2c064f4bac57\n ---> ff7ad58a5d8a\nRemoving intermediate container 2c064f4bac57\nSuccessfully built ff7ad58a5d8a\n```\n\n然后, 你可以使用docker images查看.就会发现多出来一个image.\n\n## dockerfile cache\n上面已经提到过,使用docker build的时候,如果你的dockerfile中的某一步出现问题的话,你生成的image会停留在那一步.当你fix errors时, 重新运行docker build, 此时,docker是不会真的重头来建一遍的,他会使用你改动line的前一个image,然后以此为基点继续向下构建.  \n不过,如果你使用缓存的话,他前面的版本id是不会发生改变的.如果你想完整的得到一个新的ID的话,就可以在build的时候,禁用掉cache.\n\n```bash\ndocker build --no-cache -t=\"jimmy/first_dockerfile\" .\n```\n\n不过,该方法是不推荐的. 因为一个非常棒的cache机制,就被你硬生生的cancel. 而且,这也极力不推荐使用该方法进行cache的取消.以为,有些地方,我们完全可以利用cache来加快速度.这就需要使用到ENV关键字.来帮助我们,另外利用cache.  \n在讲解ENV之前,先给大家讲解一下docker cache的运行机理.  \n（是不是感觉很激动）  \n实际上,机理就一句话:ID命中. 因为docker在你每次运行一行命令的时候,会自动生成一个id值.\n\n```bash\nSending build context to Docker daemon 2.048 kB\nStep 1 : FROM ubuntu:latest\n ---> c5f1cf30c96b  // 这就是ID值\n```\n\ndocker借由这个ID值,来判断是否有cache镜像.所以,这里就需要借一下ENV这个比较费的指令,来灵活的帮助我们使用cache.\n\n## 配置化cache\nENV的就是给docker来设置变量的. 基本格式为:\n\n```bash\n一个一个的赋值\nENV key value\n// demo:\nENV name jimmy\nENV age 18\n另外,还可以一起赋值\nENV key=value[...]\n// demo:\nENV name=jimmy age=18\n```\n\n而通过ENV我们就可以完美的告诉docker 从这里开始,你就不能使用cache,自己的重新来.(因为,每条指令都会生成layer并且有独立的id,一旦你更改的ENV,那么从该指令开始id都会发生改变,也就匹配不到缓存了)\n看个demo:\n\n```bash\n第一个dockerfile\nFROM ubuntu:latest\nMAINTAINER jimmy \"villainhr@gmai.com\"\nENV REFRESH first # 这里设置的是refresh=first\nRUN cd /var\nRUN touch demo.js\nEXPOSE 80\n\n// 使用docker build ... 后面就会生成一系列新的id和images\n// 现在修改dockerfile\n第二个dockerfile\nFROM ubuntu:latest\nMAINTAINER jimmy \"villainhr@gmai.com\"\nENV REFRESH second # 这里设置的是refresh=second\nRUN cd /var\nRUN touch demo.js\nEXPOSE 80\n\n// 开始运行docker build... 你会发现,从下面语句开始.\nENV REFRESH second\n// 其docker id就已经发生了改变,并且docker 没有了use cache的提示.说明,下面就没有命中缓存了. 所以,如果你想在某一段不使用缓存,只需要将ENV后面的value改变即可.\n```\n\n创建完后, 我们可以使用docker history,查看一下刚才创建的image的整个流程.\n\n```bash\n// 查看image创建的过程\ndocker history jimmy/first_dockerfile \n// 输出的结果为:\n2322ddc85cc3        10 hours ago        /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B                 \nb39397abc7aa        10 hours ago        /bin/sh -c touch demo.js                        0 B                 \n3c9a4daf4c42        10 hours ago        /bin/sh -c cd /var                              0 B                 \nb1c2f890a262        10 hours ago        /bin/sh -c #(nop) ENV REFRESH=second            0 B                 \n2cf0ee3c373c        10 hours ago        /bin/sh -c #(nop) MAINTAINER jimmy \"villainhr   0 B              \n```\n\n俺的目的,其实是想让你们看看,docker在每一层是怎么执行的--/bin/sh. 了解了之后,我们就继续了.\n\n## docker container的接口暴露\n上面通过dockerfile 已经暴露了一个80接口,用来和外部通信。 不过,如果我们没有使用EXPOSE暴露接口的话, 那应该怎么做呢？  \n我们可以直接在外部运行docker image, 手动指定暴露的端口.\n\n```bash\n同样,暴露80端口给外部交互\ndocker run -d -p 80 --name demo jimmy/node \\\nnode -jimmy app.js\n\n-d是daemon的意思\n-p 80 表示暴露80的port给外部\nnode -jimmy app.js 表示在jimmy/node image里面运行的指令\n```\n\n这里, 我们需要额外了解一下80端口的开启. docker 其实是在底层上面,虚拟化了存储. 并且,docker在运行的时候,会自动向主机要一个ip(假的), 相当于,有了自己的host. (这不就一个主机吗？)  \n这里我们开启的80端口,是docker在内部虚拟开启的, 他会从32768 到 61000端口之间,随机抽一个映射到docker开启的80端口上, 依此来和外部进行真正的交互(膜拜///).\n\n```bash\n使用docker ps -l 来查看开启情况\ndocker ps -l\n得到: 只截取了一部分.\n0.0.0.0:49154->80 tcp\n或者指定查看docker端口开启情况\ndocker port c96f2c18bb64 80 // ID也可以使用name代替\n返回:\n 0.0.0.0:49154\n```\n\n## 手动指定端口\n如果你不想让docker决定的绑定的接口是哪一个,ok, 你可以自己指定.\n\n```bash\n手动指定端口\n指定docker的8080连接到container暴露的80端口\ndocker run -d -p 8080:80 --name demo jimmy/node \\\nnode -jimmy app.js\n甚至你也可以指定ip+port\n指定docker的127.0.0.1:8080连接container的80\ndocker run -d -p 127.0.0.1:8080:80 --name demo jimmy/node \\\nnode -jimmy app.js\n```\n\n## 利用EXPOSE\n在写dockerfile的时候,我们已经了解了,使用EXPOSE可以完美的实现端口的暴露. 但如果,我们在dockerfile里面暴露多个port的话,那么-p的参数,感觉有点鸡肋啊喂  \n不过,现在我们可以使用-P(注意是大写). 来手动开启所有在dockerfile中,通过EXPOSE暴露的端口.\n\n```bash\ndocker run -d -P --name demo jimmy/node \\\nnode -jimmy app.js\n```\n\n## 外部访问\n通过端口开启之后,我们就可以间接的访问docker的路由, 来访问在docker里面开启的端口了.\n\n```bash\n假如上面我们通过dockre暴露的端口是34251的话,就可以在docker环境外访问了.\nping localhost:34251\n```\n\n## dockerfile常用指令\n自动化运行CMD\n你是不是已经厌烦了使用docker run 来运行命令了呢？ 你是不是已经讨厌重复的copy命令运行了呢？  \n那么请使用CMD吧.   \nCMD的作用是,用来指定当你调其对应的container时, 运行的命令.  \n比如在dockerfile中,指定/bin/bash.\n\n```bash\n当调起container时,运行/bin/bash\ndocker run  -t -i jimmy/ubuntu:latest /bin/bash\n等同于在dockerfile中指定CMD\nCMD [\"/bin/bash\"]\n// 运行docker run\ndocker run -t -i jimmy/ubuntu:latest\n```\n\n不过,如果你在run后面手动指定指令运行的话,会默认覆盖掉CMD提供的命令.  \n熟悉了CMD,感觉有种RUN的感觉. 但,这两者的区别还是很大的\n•\tRUN: 一般是用来给image增加layer来完善image, 他一旦执行完,就和后面的运行没有关系了  \n\n•\tCMD: 这个在docker build过程中,是没有半毛钱关系的. 他只和在调用image时,关系比较大  \n\n## 强制运行ENTRYPOINT\n这里的ENTRYPOINT和CMD很相似. 可以说,在一定程度上两者可以互相替代,但,两者的实际意义相差还是挺大的.  \nENTRYPOINT的主要功能是强制执行的环境.\n\n```bash\n指定ENTRYPOINT为/bin/sh\nENTRYPOINT [\"/bin/sh\"]\n// 然后在build之后,调起container\n我们尝试在run后面加上参数:\ndocker run -t -i jimmy/demo /bin/bash/\n// 不出意外的话,会得到一个bug提示:\n>>/bin/sh: 0: Can't open /bin/bash/\n```\n\n所以, ENTRYPOINT的主要功能实际上是,指定了内部运行命令的解析器. 而使用docker run添加的命令,会被当做参数添加给ENTRYPOINT.\n\n```bash\n已经指定了ENTRYPOINT [\"/bin/sh\"]\n运行docker run\ndocker run -t -i jimmy/demo /bin/bash/\n实际上相当于(不出错才怪嘞...)\n/bin/sh /bin/bash/\n```\n\n另外,我们还可以使用CMD配合ENTRYPOINT写成默认参数的效果.\n\n```bash\n默认执行 /bin/bash default.sh\nENTRYPOINT [\"/bin/bash\"]\nCMD [\"default.sh\"]\n如果你在docker run中指定了参数的话,则CMD会默认被代替 \ndocker run jimmy/demo sam.sh\n```\n\n不过,CMD和ENTRYPOINT都只能在dockerfile里面出现一次.\n\n## 指定运行目录WORKDIR\n既然,我们能够在dockerfile里面运行指定的命令。 但,有时,我们仅仅是想在不同的目录中执行不同的命令. 那,在dockerfile中,如何做到灵活的目录切换呢？  \n那就得使用docker提供的WORKDIR命令了.\n\n```bash\n在/var/data里面创建data.js\nWORKDIR /var/data\nRUN touch data.js\n然后在/etc 下创建data.conf文件\nWORKDIR /etc\nRUN touch data.conf\n```\n\n并且当你在使用docker run时,他也会停留在使用WORKDIR指定的目录中.\n\n## 环境变量的设置ENV\nENV在dockerfile里面的用处,应该算是灰常大的. 什么灵活更新,什么变量设置,什么更改全局变量等. 都是so easy.   \n那ENV到底是用来干嘛的?  \n答: 就是用来设置变量的啊喂. 只是他是设置全局变量.  \n比如像PATH神马的之类的.\n\n```bash\n设置一个DATA的全局变量.\nENV DATA=jimmy\n```\n\nENV最独特之处在于,他所设置的变量,会在你运行的时候生效.即,如果你修改了PATH,他也会在container中立即生效.\n\n```bash\n修改环境变量\nENV PATH=$PATH:/user/bin\n// 现在进入到运行的container中\necho $PATH\n>> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data\n```\n\n## 挂载通用盘VOLUME\n在说里面正式的内容之前,我们先来说一下,什么叫做VOLUME. 说人话吧,VOLUME叫做数据卷, 相当于通用盘一样的东西. 他其实也是一个存储装置,我们就把他叫做硬盘吧. 这个硬盘不普通,有\\>1的外接口.(说人话) 每一个外接口,都可以接入到一个操作系统里面. 即,实现了多个系统的数据共享.  \n一句话:\n> VOLUME就是一个数据共享盘\n而,docker秉承着,虚拟储存idea, 想下面idea践行到底.\n> wirte once, run anywhere\n(感觉,在哪见过)  \n所以, dockerfile提供了一个VOLUME的指令,能够让我们指定数据卷的位置.\n\n```bash\n指定/opt/data为数据卷\nVOLUME [\"/opt/data\"]\n指定多个目录为数据卷/opt/data, /opt/project\nVOLUME [\"/opt/data\",\"/opt/project\"]\n```\n\n当然,关于数据卷的操作,肯定不止挂载这一点,还有迁移,备份等等,相关操作. 具体,可以参考: Docker VOLUME\n\n## 添加外部文件ADD\n有时,我们仅仅是想将外部文件copy到container中,docker有办法吗？  \nnonsense  \ndocker 提供了ADD命令,来帮助我们完成文件的添加. 不过,这里ADD有点限制, 即, 你添加的文件或者目录,只能在docker build运行的目录下, 因为,这是docker在调起container的时候,只将该目录放进了daemon(尴尬)\n\n```bash\n现假设,docker build运行的目录为: /data\n// 只能添加指定目录下\n// 将/data/sam.js 添加到image中的/opt/node/sam.js\n// 如果存在该文件,则不会被覆盖\nADD sam.js /opt/node/\n添加文件,还可以使用通配符\n// 将所有的js文件,添加到node目录下\nADD *.js /opt/node/\n如果destination不是绝对路径,则相对于最近的WORKDIR\n// 如果最近的WORKDIR为/var\n// 则下列添加的路径为/var/opt/node\nADD *.js opt/node/\n```\n\n当文件被添加到指定目录中时,该文件的权限是755,并且UID和GID都是0.  \nADD 还支持url添加,以及文件自动解压.\n\n```bash\n使用url添加\n// 将指定路由的文件放到根目录当中\nADD http://example.com/foobar /\n自动解压tar.gz文件\n// 将文件解压过后放在指定目录中\nADD latest.tar.gz /var/www/wordpress/\n```\n\n## 纯粹的COPY\nCOPY和ADD非常类似. 我们可以做个类比:\nADD 包含 COPY\nCOPY做的事情比不上ADD, 他比ADD少了解压缩和URL下载的功能. 不过,他耗费的性能比较少,他只做纯粹的添加和下载.他的结构和ADD一毛一样. 不过, 有一点,COPY的时候,如果遇到目录不存在的情况下,COPY会自动创建\n\n```bash\nCOPY file.js /opt/data/\n```\n\n## 添加个人信息LABEL\n顾名思义,使用LABEL就是给你的image打上独一无二的标签.让别人能够了解,这个Image是属于你的. 又或是,用来提醒你自己,这个image现在处于哪一个版本状态.\n\n```bash\n设置自己的label\nLABEL owner=\"jimmy\" version=\"0.0.1\"\n```\n\n在创建完image之后, 我们可以使用docker inspect来查看我们已经打的LABEL\n\n```bash\ndocker inspect jimmy/node\n...\nlabels:{\nowner:\"jimmy\",\nversion:\"0.0.1\"\n}\n...\n```\n\n本人觉得, 这个指令其实真的,有时, 母鸡用到什么地方去...  \n并且,书写的时候,最好多个连着写,因为这样只会增加一层image.(image的层数是有限制的)\n\n## 参数形式ARG\n这是docker提供的另外一个,让我有点懵逼的命令. 他的实际效果和ENV的区别可以趋近于无。\n\n```bash\n使用ARG定义变量\nARG buildno\n设置默认值\nARG user1=someuser\n```\n\n当然,我们可以在命令中,手动指定替换.\n\n```bash\n在dockerfile定义了默认变量\nARG user=jimy\n在运行时,进行手动替换\ndocker build --build-arg user=sam -t jimmy/demo .\n```\n\n上面说了ARG和ENV比较类似,不过,里面的区别还是有的. 即, ARG只能用在docker build的阶段, 并且不会被保存在image中,这就是和ENV的区别.\n\n## 模板image之ONBUILD\n因为dockerfile的构建的层数有限制,所以,这也带给了我们一些麻烦, 如果搭建的环境过多,则会造成写到一半,发现dockerfile已经full. 这时候, 就轮到ONBUILD出场了. ONBUILD的作用在于,他可以完美的实现模板image的搭建.   \nONBUILD的主要作用在于,他定义的命令,可以在子dockerfile中使用.(md... 好绕口)\n\n```bash\n使用ONBUILD 默认下载Apache\nONBUILD RUN apt-get update && apt-get install -y apache2\n\n// 然后运行docker file 会得到下列结果\n Step 3 : ONBUILD RUN apt-get update && apt-get install -y apache2\n   ---> Running in 0e117f6ea4ba\n   ---> a79983575b8\n\n//然后生成一个新的image,我们这里暂且叫他jimmy/demo\n```\n\n接下来,我们再来写一个dockerfile\n\n```bash\n这里继承上面的jimmy/demo\nFROM jimmy/demo:latest\nENV SEX=001\n\n// 运行上面的dockerfile,得到:\nStep 0 : FROM jimmy/demo\nExecuting 1 build triggers\n   Step onbuild-0 : ADD . /var/www/\n   ---> 1a018213a59d\n   ---> 1a018213a59d\n Step 1: ENV SEX=001\n ...\n```\n\n细心的童鞋可以发现这一条命令:\n\n```bash\n Step onbuild-0 : RUN apt-get update && apt-get install -y apache2\n   ---> 1a018213a59d\n   ---> 1a018213a59d\n```\n\n他居然在这里自动运行了. 所以,我们可以将ONBUILD命令理解为模板命令. 即,子dockerfile里面运行时同样生效(这里,我没有说grandchildren的事).  \n但ONBUILD只能往下延伸一级. 相当于你用ONBUILD定义的命令,有两次有效次数,一次在build原来Image时,已经用掉了. 所以, 另外一次(在子dockerfile中使用)用掉了之后就无效了. grandchildren dockerfile就没法使用了.\n\n\n\n\n[1]:\thttps://segmentfault.com/a/1190000006186977?utm_source=tuicool&utm_medium=referral\n\n[image-1]:\thttp://p09eeagrw.bkt.clouddn.com/59773500.jpg","slug":"快速掌握dockerfile","published":1,"date":"2017-12-12T00:57:43.000Z","updated":"2017-12-12T01:34:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjys0011xqs65sg2zqj7","content":"<p>转载自<a href=\"https://segmentfault.com/a/1190000006186977?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">快速掌握Dockerfile</a></p>\n<h2 id=\"docker镜像的简单剖析\"><a href=\"#docker镜像的简单剖析\" class=\"headerlink\" title=\"docker镜像的简单剖析\"></a>docker镜像的简单剖析</h2><p>docker的images,我们可以理解为积木, 一层一层往上搭, 最后完成一个工程化的大项目.<br>在最初,docker实际上,只有一个静态的image(Ps: read-only). 相当于只能读, 所以, 你所有的改动并不会影响到原来的image上, 只会一层一层的叠加, 比如, 你在Ubuntu的image上面, 再接一层nodeJS的image. 实际上的结果是, 两个image叠加起来.<br>这里放一张 <strong>the Docker book</strong>的说明图:<br><img src=\"http://p09eeagrw.bkt.clouddn.com/59773500.jpg\" alt=\"\"><br>docker 在下载image的时候,会在/var/lib/docker目录下创建相关的image 目录. 而运行的container则会放在/var/lib/docker/containers中.<br>另外,docker中的image,是存储在docker仓库. 现在,我们通过快速创建自已的仓库来仔细了解一下docker是怎样拥有这样一个完善的生态的.</p>\n<h2 id=\"docker-仓库\"><a href=\"#docker-仓库\" class=\"headerlink\" title=\"docker 仓库\"></a>docker 仓库</h2><p>首先, 要想拥有自己的docker 仓库, 你得有一个自己的docker账号.so, 那就想apply 一个呗. 在docker hub上面注册一下自己的账号就行.</p>\n<h2 id=\"登录指令\"><a href=\"#登录指令\" class=\"headerlink\" title=\"登录指令\"></a>登录指令</h2><p>在docker中,不仅支持web查看docker中的内容, 而且还支持使用命令行登录.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 登录到docker</span><br><span class=\"line\">docker login // 然后输入账户密码就ok了</span><br><span class=\"line\">// 使用完毕,想要登出</span><br><span class=\"line\">docker <span class=\"built_in\">logout</span></span><br></pre></td></tr></table></figure>\n<p>实际上,docker会将你的认证信息存放在. /.docker/config.json当中。</p>\n<h2 id=\"images-常用命令\"><a href=\"#images-常用命令\" class=\"headerlink\" title=\"images 常用命令\"></a>images 常用命令</h2><p>如果浏览了上面的docker仓库, 会发现在一个repository里面会存在很多images, 比如ubuntu的repository.不同的images发布,代表的都是特定的版本系统. 所以,在拉取的时候,需要额外注意一下你需要的指定docker images.</p>\n<h2 id=\"images的拉取\"><a href=\"#images的拉取\" class=\"headerlink\" title=\"images的拉取\"></a>images的拉取</h2><p>在container中,我们讲过,使用docker run的时候, 你会发现如果你的images里面没有存在指定的image时, docker会主动去docker hub里面找,然后下载,并且自动运行.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 运行最新版的ubuntu image</span><br><span class=\"line\">docker run -t -i ubuntu:latest</span><br></pre></td></tr></table></figure>\n<p>如果,你想自己手动下载images的话,可以直接pull</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 手动拉取images</span><br><span class=\"line\">docker pull ubuntu:latest</span><br><span class=\"line\">// 拉取12.04版本的ubuntu images</span><br><span class=\"line\">docker pull ubuntu:12.04</span><br></pre></td></tr></table></figure>\n<p>如果在拉取的时候,想知道这个image是否是真正存在的话,就可以使用.docker 提供的搜索指令.</p>\n<h2 id=\"搜索指定docker\"><a href=\"#搜索指定docker\" class=\"headerlink\" title=\"搜索指定docker\"></a>搜索指定docker</h2><p>在docker中,可以使用自带的search命令,搜索所有含有指定term的image. 相当于js中的search 方法.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 搜索name中含有demo的image</span><br><span class=\"line\">docker search demo</span><br><span class=\"line\">// 结果为: 名字. 通常为: author/image_name . 通常搜索的就是这个</span><br><span class=\"line\">// 描述: 就是一段文字描述</span><br><span class=\"line\">NAME  DESCRIPTION  STARS OFFICIAL   AUTOMATED</span><br></pre></td></tr></table></figure>\n<p>查到之后,我们就可以使用pull将指定的库,拉下来了.</p>\n<h2 id=\"创建自己的image\"><a href=\"#创建自己的image\" class=\"headerlink\" title=\"创建自己的image\"></a>创建自己的image</h2><p>上面说过, contianer是copy image运行的进程容器,image是不会变的read-only 块. 但是,如果我们在container里面, 改动了一些设置,比如,下载了node, 而且,我想要保存我这次改动, 以至于,下次我想重新,启动该image时, 他已经具备了node.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 现在我再ubuntu:latest上面安装了node</span><br><span class=\"line\">// 伪代码</span><br><span class=\"line\">npm install node -g</span><br></pre></td></tr></table></figure>\n<p>docker提供了一个非常快捷的方式就是创建自己的docker image. 使用docker commit.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看刚才改动的container ID</span><br><span class=\"line\">docker ps -a -q -l</span><br><span class=\"line\">// 得到 docker_id, 提交到自己的库中</span><br><span class=\"line\">docker commit docker_id villainHR/node</span><br><span class=\"line\">// 之后会返回新的image id</span><br></pre></td></tr></table></figure>\n<p>需要注意,docker commit提交的并不是一个整体的100+MB的ubuntu+node. 他只会将两个仓库的差异提交,比如原来image和新的image比起来,就是多了一个npm install node -g命令.</p>\n<h2 id=\"使用Dockerfile\"><a href=\"#使用Dockerfile\" class=\"headerlink\" title=\"使用Dockerfile\"></a>使用Dockerfile</h2><p>Dockerfile是为了迅速的构建image而出现的. 他与docker commit 的区别在于. 能够迅速的更替历史image 命令. 比如,我们以前下载的npm是version 2, 现在想要更换为npm@3的话,则难度就不是一般的了. 但是,如果我们能够像写命令一样将下载的配置命令下载Dockerfile里面, 那么以后我们想要更换版本,就是很方便的啦.<br>ok, 现在我们来了解一下Dockerfile是怎样的运行的.<br>dockerfile demo讲解<br>这里,我们利用dockerfile 来搭建一个简单的webServer. 首先创建一个你自己的dockerfile目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir first_docker</span><br><span class=\"line\"><span class=\"built_in\">cd</span> first_docker</span><br><span class=\"line\">touch Dockerfile</span><br></pre></td></tr></table></figure>\n<p>然后, 确保你有ubuntu:latest image.因为, 接下来我们就是基于它,来搭建我们的server.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first dockerfile demo</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">设置该dockerfile的作者和联系邮箱</span><br><span class=\"line\">MAINTAINER Jimmy <span class=\"string\">\"villainhr@gmail.com\"</span></span><br><span class=\"line\">开始配置环境, 下载apt-get,生成index.html的文件</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class=\"line\">RUN <span class=\"built_in\">echo</span> <span class=\"string\">'first demo'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class=\"line\">暴露server的port</span><br><span class=\"line\">EXPOSE 80</span><br></pre></td></tr></table></figure>\n<p>说一下上面的命令内涵.<br>•    FROM: 用来指定第一层image, 这是必须有的. 并且指定的image是存在在你的computer中. 相当于是 docker run.  </p>\n<p>•    RUN: 这是用来在container中,做出相应的修改. 相当于 修改+docker commit xxx. 给原来的image加上一层layer. 然后, docker会在你commit新一层之后,重新docker run你最新改动过的image  </p>\n<p>•    MAINTAINER: 设置作者和联系邮箱.其实就是docker commit 后面的Name参数. 而且加上了联系邮箱. 这是在dockerfile 运行完后,会自动添加到image上的.  </p>\n<p>•    EXPOSE: 用来给最新的container 设置与外部交流的port  </p>\n<p>上面简单的介绍了基本的dockerfile的命令. 不过, 这尼玛太简单了,不符合我们一贯追求到底的风格.<br>这里, 我们在来细说一下RUN这个命令. 实际上, 这应该是dockerfile的关键. RUN的原理很简单, 就是commit + run. 先创建一个新的image 然后 在这个基础上将原有的container替换为新的,如果某一步的RUN发生错误,则container会停在那个阶段, 这样,你可以直接进入该container去查看,你那一步的RUN发生了什么BUG。 另外, 使用RUN的时候, 需要注意, 由于,dockerfile是由上到下解析的, 比如你一开始FROM ubuntu的image, 那么此时的环境是停留在ubuntu的shell中的.<br>比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN touch demo.js</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">/bin/sh -c touch demo.js</span><br></pre></td></tr></table></figure>\n<p>所以, 如果你调用的image 并没有shell的话, 那么久需要使用exec调用系统shell 来执行命令.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用系统的shell来运行, 实际上就是 <span class=\"built_in\">exec</span> xxx xxx xxx.</span><br><span class=\"line\">RUN [<span class=\"string\">\"npm\"</span>,<span class=\"string\">\"install\"</span>,<span class=\"string\">\"node\"</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行dockerfile\"><a href=\"#运行dockerfile\" class=\"headerlink\" title=\"运行dockerfile\"></a>运行dockerfile</h2><p>上面的dockerfile文件配置好了之后,就轮到我们运行dockerfile.直接运行docker build即可.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注意后面的<span class=\"string\">\".\"</span>, 用来指定搜索dockerfile文件的路径. </span><br><span class=\"line\">docker build -t=<span class=\"string\">\"jimmy/first_dockerfile\"</span> .</span><br></pre></td></tr></table></figure>\n<p>说一下docker build的指令吧.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基本格式为:</span><br><span class=\"line\">docker build -t=<span class=\"string\">\"repository/name:tag\"</span>  directory</span><br><span class=\"line\">// -t用来指定生成的image的name,比如仓库,image的名字以及他的tag,如果你不指定tag, 那么docker会自动添加latest代替。</span><br><span class=\"line\">// directory 用来相对于当前运行build的目录, 搜索指定的dockerfile.当然,你也可以使用绝对路径了</span><br></pre></td></tr></table></figure>\n<p>顺利的话,应该就会有, 下列的信息出来.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sending build context to Docker daemon 2.048 kB</span><br><span class=\"line\">Step 1 : FROM ubuntu:latest</span><br><span class=\"line\"> ---&gt; c5f1cf30c96b</span><br><span class=\"line\">Step 2 : MAINTAINER jimmy <span class=\"string\">\"villainhr@gmai.com\"</span></span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 078148a5086a</span><br><span class=\"line\"> ---&gt; 11b061f665d1</span><br><span class=\"line\">Removing intermediate container 078148a5086a</span><br><span class=\"line\">Step 3 : RUN <span class=\"built_in\">cd</span> /var</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> ffd3141e64c8</span><br><span class=\"line\"> ---&gt; a4d7c5303b60</span><br><span class=\"line\">Removing intermediate container ffd3141e64c8</span><br><span class=\"line\">Step 4 : RUN touch demo.js</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> c8393a6fcc98</span><br><span class=\"line\"> ---&gt; 109b402b9adc</span><br><span class=\"line\">Removing intermediate container c8393a6fcc98</span><br><span class=\"line\">Step 5 : EXPOSE 80</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 2c064f4bac57</span><br><span class=\"line\"> ---&gt; ff7ad58a5d8a</span><br><span class=\"line\">Removing intermediate container 2c064f4bac57</span><br><span class=\"line\">Successfully built ff7ad58a5d8a</span><br></pre></td></tr></table></figure>\n<p>然后, 你可以使用docker images查看.就会发现多出来一个image.</p>\n<h2 id=\"dockerfile-cache\"><a href=\"#dockerfile-cache\" class=\"headerlink\" title=\"dockerfile cache\"></a>dockerfile cache</h2><p>上面已经提到过,使用docker build的时候,如果你的dockerfile中的某一步出现问题的话,你生成的image会停留在那一步.当你fix errors时, 重新运行docker build, 此时,docker是不会真的重头来建一遍的,他会使用你改动line的前一个image,然后以此为基点继续向下构建.<br>不过,如果你使用缓存的话,他前面的版本id是不会发生改变的.如果你想完整的得到一个新的ID的话,就可以在build的时候,禁用掉cache.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build --no-cache -t=<span class=\"string\">\"jimmy/first_dockerfile\"</span> .</span><br></pre></td></tr></table></figure>\n<p>不过,该方法是不推荐的. 因为一个非常棒的cache机制,就被你硬生生的cancel. 而且,这也极力不推荐使用该方法进行cache的取消.以为,有些地方,我们完全可以利用cache来加快速度.这就需要使用到ENV关键字.来帮助我们,另外利用cache.<br>在讲解ENV之前,先给大家讲解一下docker cache的运行机理.<br>（是不是感觉很激动）<br>实际上,机理就一句话:ID命中. 因为docker在你每次运行一行命令的时候,会自动生成一个id值.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sending build context to Docker daemon 2.048 kB</span><br><span class=\"line\">Step 1 : FROM ubuntu:latest</span><br><span class=\"line\"> ---&gt; c5f1cf30c96b  // 这就是ID值</span><br></pre></td></tr></table></figure>\n<p>docker借由这个ID值,来判断是否有cache镜像.所以,这里就需要借一下ENV这个比较费的指令,来灵活的帮助我们使用cache.</p>\n<h2 id=\"配置化cache\"><a href=\"#配置化cache\" class=\"headerlink\" title=\"配置化cache\"></a>配置化cache</h2><p>ENV的就是给docker来设置变量的. 基本格式为:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个一个的赋值</span><br><span class=\"line\">ENV key value</span><br><span class=\"line\">// demo:</span><br><span class=\"line\">ENV name jimmy</span><br><span class=\"line\">ENV age 18</span><br><span class=\"line\">另外,还可以一起赋值</span><br><span class=\"line\">ENV key=value[...]</span><br><span class=\"line\">// demo:</span><br><span class=\"line\">ENV name=jimmy age=18</span><br></pre></td></tr></table></figure>\n<p>而通过ENV我们就可以完美的告诉docker 从这里开始,你就不能使用cache,自己的重新来.(因为,每条指令都会生成layer并且有独立的id,一旦你更改的ENV,那么从该指令开始id都会发生改变,也就匹配不到缓存了)<br>看个demo:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个dockerfile</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">MAINTAINER jimmy <span class=\"string\">\"villainhr@gmai.com\"</span></span><br><span class=\"line\">ENV REFRESH first <span class=\"comment\"># 这里设置的是refresh=first</span></span><br><span class=\"line\">RUN <span class=\"built_in\">cd</span> /var</span><br><span class=\"line\">RUN touch demo.js</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用docker build ... 后面就会生成一系列新的id和images</span><br><span class=\"line\">// 现在修改dockerfile</span><br><span class=\"line\">第二个dockerfile</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">MAINTAINER jimmy <span class=\"string\">\"villainhr@gmai.com\"</span></span><br><span class=\"line\">ENV REFRESH second <span class=\"comment\"># 这里设置的是refresh=second</span></span><br><span class=\"line\">RUN <span class=\"built_in\">cd</span> /var</span><br><span class=\"line\">RUN touch demo.js</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\"></span><br><span class=\"line\">// 开始运行docker build... 你会发现,从下面语句开始.</span><br><span class=\"line\">ENV REFRESH second</span><br><span class=\"line\">// 其docker id就已经发生了改变,并且docker 没有了use cache的提示.说明,下面就没有命中缓存了. 所以,如果你想在某一段不使用缓存,只需要将ENV后面的value改变即可.</span><br></pre></td></tr></table></figure>\n<p>创建完后, 我们可以使用docker history,查看一下刚才创建的image的整个流程.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看image创建的过程</span><br><span class=\"line\">docker <span class=\"built_in\">history</span> jimmy/first_dockerfile </span><br><span class=\"line\">// 输出的结果为:</span><br><span class=\"line\">2322ddc85cc3        10 hours ago        /bin/sh -c <span class=\"comment\">#(nop) EXPOSE 80/tcp                 0 B                 </span></span><br><span class=\"line\">b39397abc7aa        10 hours ago        /bin/sh -c touch demo.js                        0 B                 </span><br><span class=\"line\">3c9a4daf4c42        10 hours ago        /bin/sh -c <span class=\"built_in\">cd</span> /var                              0 B                 </span><br><span class=\"line\">b1c2f890a262        10 hours ago        /bin/sh -c <span class=\"comment\">#(nop) ENV REFRESH=second            0 B                 </span></span><br><span class=\"line\">2cf0ee3c373c        10 hours ago        /bin/sh -c <span class=\"comment\">#(nop) MAINTAINER jimmy \"villainhr   0 B</span></span><br></pre></td></tr></table></figure>\n<p>俺的目的,其实是想让你们看看,docker在每一层是怎么执行的–/bin/sh. 了解了之后,我们就继续了.</p>\n<h2 id=\"docker-container的接口暴露\"><a href=\"#docker-container的接口暴露\" class=\"headerlink\" title=\"docker container的接口暴露\"></a>docker container的接口暴露</h2><p>上面通过dockerfile 已经暴露了一个80接口,用来和外部通信。 不过,如果我们没有使用EXPOSE暴露接口的话, 那应该怎么做呢？<br>我们可以直接在外部运行docker image, 手动指定暴露的端口.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同样,暴露80端口给外部交互</span><br><span class=\"line\">docker run -d -p 80 --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br><span class=\"line\"></span><br><span class=\"line\">-d是daemon的意思</span><br><span class=\"line\">-p 80 表示暴露80的port给外部</span><br><span class=\"line\">node -jimmy app.js 表示在jimmy/node image里面运行的指令</span><br></pre></td></tr></table></figure>\n<p>这里, 我们需要额外了解一下80端口的开启. docker 其实是在底层上面,虚拟化了存储. 并且,docker在运行的时候,会自动向主机要一个ip(假的), 相当于,有了自己的host. (这不就一个主机吗？)<br>这里我们开启的80端口,是docker在内部虚拟开启的, 他会从32768 到 61000端口之间,随机抽一个映射到docker开启的80端口上, 依此来和外部进行真正的交互(膜拜///).</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用docker ps -l 来查看开启情况</span><br><span class=\"line\">docker ps -l</span><br><span class=\"line\">得到: 只截取了一部分.</span><br><span class=\"line\">0.0.0.0:49154-&gt;80 tcp</span><br><span class=\"line\">或者指定查看docker端口开启情况</span><br><span class=\"line\">docker port c96f2c18bb64 80 // ID也可以使用name代替</span><br><span class=\"line\">返回:</span><br><span class=\"line\"> 0.0.0.0:49154</span><br></pre></td></tr></table></figure>\n<h2 id=\"手动指定端口\"><a href=\"#手动指定端口\" class=\"headerlink\" title=\"手动指定端口\"></a>手动指定端口</h2><p>如果你不想让docker决定的绑定的接口是哪一个,ok, 你可以自己指定.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">手动指定端口</span><br><span class=\"line\">指定docker的8080连接到container暴露的80端口</span><br><span class=\"line\">docker run -d -p 8080:80 --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br><span class=\"line\">甚至你也可以指定ip+port</span><br><span class=\"line\">指定docker的127.0.0.1:8080连接container的80</span><br><span class=\"line\">docker run -d -p 127.0.0.1:8080:80 --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br></pre></td></tr></table></figure>\n<h2 id=\"利用EXPOSE\"><a href=\"#利用EXPOSE\" class=\"headerlink\" title=\"利用EXPOSE\"></a>利用EXPOSE</h2><p>在写dockerfile的时候,我们已经了解了,使用EXPOSE可以完美的实现端口的暴露. 但如果,我们在dockerfile里面暴露多个port的话,那么-p的参数,感觉有点鸡肋啊喂<br>不过,现在我们可以使用-P(注意是大写). 来手动开启所有在dockerfile中,通过EXPOSE暴露的端口.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -P --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br></pre></td></tr></table></figure>\n<h2 id=\"外部访问\"><a href=\"#外部访问\" class=\"headerlink\" title=\"外部访问\"></a>外部访问</h2><p>通过端口开启之后,我们就可以间接的访问docker的路由, 来访问在docker里面开启的端口了.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假如上面我们通过dockre暴露的端口是34251的话,就可以在docker环境外访问了.</span><br><span class=\"line\">ping localhost:34251</span><br></pre></td></tr></table></figure>\n<h2 id=\"dockerfile常用指令\"><a href=\"#dockerfile常用指令\" class=\"headerlink\" title=\"dockerfile常用指令\"></a>dockerfile常用指令</h2><p>自动化运行CMD<br>你是不是已经厌烦了使用docker run 来运行命令了呢？ 你是不是已经讨厌重复的copy命令运行了呢？<br>那么请使用CMD吧.<br>CMD的作用是,用来指定当你调其对应的container时, 运行的命令.<br>比如在dockerfile中,指定/bin/bash.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当调起container时,运行/bin/bash</span><br><span class=\"line\">docker run  -t -i jimmy/ubuntu:latest /bin/bash</span><br><span class=\"line\">等同于在dockerfile中指定CMD</span><br><span class=\"line\">CMD [<span class=\"string\">\"/bin/bash\"</span>]</span><br><span class=\"line\">// 运行docker run</span><br><span class=\"line\">docker run -t -i jimmy/ubuntu:latest</span><br></pre></td></tr></table></figure>\n<p>不过,如果你在run后面手动指定指令运行的话,会默认覆盖掉CMD提供的命令.<br>熟悉了CMD,感觉有种RUN的感觉. 但,这两者的区别还是很大的<br>•    RUN: 一般是用来给image增加layer来完善image, 他一旦执行完,就和后面的运行没有关系了  </p>\n<p>•    CMD: 这个在docker build过程中,是没有半毛钱关系的. 他只和在调用image时,关系比较大  </p>\n<h2 id=\"强制运行ENTRYPOINT\"><a href=\"#强制运行ENTRYPOINT\" class=\"headerlink\" title=\"强制运行ENTRYPOINT\"></a>强制运行ENTRYPOINT</h2><p>这里的ENTRYPOINT和CMD很相似. 可以说,在一定程度上两者可以互相替代,但,两者的实际意义相差还是挺大的.<br>ENTRYPOINT的主要功能是强制执行的环境.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">指定ENTRYPOINT为/bin/sh</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/bin/sh\"</span>]</span><br><span class=\"line\">// 然后在build之后,调起container</span><br><span class=\"line\">我们尝试在run后面加上参数:</span><br><span class=\"line\">docker run -t -i jimmy/demo /bin/bash/</span><br><span class=\"line\">// 不出意外的话,会得到一个bug提示:</span><br><span class=\"line\">&gt;&gt;/bin/sh: 0: Can<span class=\"string\">'t open /bin/bash/</span></span><br></pre></td></tr></table></figure>\n<p>所以, ENTRYPOINT的主要功能实际上是,指定了内部运行命令的解析器. 而使用docker run添加的命令,会被当做参数添加给ENTRYPOINT.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">已经指定了ENTRYPOINT [<span class=\"string\">\"/bin/sh\"</span>]</span><br><span class=\"line\">运行docker run</span><br><span class=\"line\">docker run -t -i jimmy/demo /bin/bash/</span><br><span class=\"line\">实际上相当于(不出错才怪嘞...)</span><br><span class=\"line\">/bin/sh /bin/bash/</span><br></pre></td></tr></table></figure>\n<p>另外,我们还可以使用CMD配合ENTRYPOINT写成默认参数的效果.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认执行 /bin/bash default.sh</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/bin/bash\"</span>]</span><br><span class=\"line\">CMD [<span class=\"string\">\"default.sh\"</span>]</span><br><span class=\"line\">如果你在docker run中指定了参数的话,则CMD会默认被代替 </span><br><span class=\"line\">docker run jimmy/demo sam.sh</span><br></pre></td></tr></table></figure>\n<p>不过,CMD和ENTRYPOINT都只能在dockerfile里面出现一次.</p>\n<h2 id=\"指定运行目录WORKDIR\"><a href=\"#指定运行目录WORKDIR\" class=\"headerlink\" title=\"指定运行目录WORKDIR\"></a>指定运行目录WORKDIR</h2><p>既然,我们能够在dockerfile里面运行指定的命令。 但,有时,我们仅仅是想在不同的目录中执行不同的命令. 那,在dockerfile中,如何做到灵活的目录切换呢？<br>那就得使用docker提供的WORKDIR命令了.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在/var/data里面创建data.js</span><br><span class=\"line\">WORKDIR /var/data</span><br><span class=\"line\">RUN touch data.js</span><br><span class=\"line\">然后在/etc 下创建data.conf文件</span><br><span class=\"line\">WORKDIR /etc</span><br><span class=\"line\">RUN touch data.conf</span><br></pre></td></tr></table></figure>\n<p>并且当你在使用docker run时,他也会停留在使用WORKDIR指定的目录中.</p>\n<h2 id=\"环境变量的设置ENV\"><a href=\"#环境变量的设置ENV\" class=\"headerlink\" title=\"环境变量的设置ENV\"></a>环境变量的设置ENV</h2><p>ENV在dockerfile里面的用处,应该算是灰常大的. 什么灵活更新,什么变量设置,什么更改全局变量等. 都是so easy.<br>那ENV到底是用来干嘛的?<br>答: 就是用来设置变量的啊喂. 只是他是设置全局变量.<br>比如像PATH神马的之类的.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置一个DATA的全局变量.</span><br><span class=\"line\">ENV DATA=jimmy</span><br></pre></td></tr></table></figure>\n<p>ENV最独特之处在于,他所设置的变量,会在你运行的时候生效.即,如果你修改了PATH,他也会在container中立即生效.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修改环境变量</span><br><span class=\"line\">ENV PATH=<span class=\"variable\">$PATH</span>:/user/bin</span><br><span class=\"line\">// 现在进入到运行的container中</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$PATH</span></span><br><span class=\"line\">&gt;&gt; /usr/<span class=\"built_in\">local</span>/sbin:/usr/<span class=\"built_in\">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data</span><br></pre></td></tr></table></figure>\n<h2 id=\"挂载通用盘VOLUME\"><a href=\"#挂载通用盘VOLUME\" class=\"headerlink\" title=\"挂载通用盘VOLUME\"></a>挂载通用盘VOLUME</h2><p>在说里面正式的内容之前,我们先来说一下,什么叫做VOLUME. 说人话吧,VOLUME叫做数据卷, 相当于通用盘一样的东西. 他其实也是一个存储装置,我们就把他叫做硬盘吧. 这个硬盘不普通,有>1的外接口.(说人话) 每一个外接口,都可以接入到一个操作系统里面. 即,实现了多个系统的数据共享.<br>一句话:</p>\n<blockquote>\n<p>VOLUME就是一个数据共享盘<br>而,docker秉承着,虚拟储存idea, 想下面idea践行到底.<br>wirte once, run anywhere<br>(感觉,在哪见过)<br>所以, dockerfile提供了一个VOLUME的指令,能够让我们指定数据卷的位置.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">指定/opt/data为数据卷</span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/opt/data\"</span>]</span><br><span class=\"line\">指定多个目录为数据卷/opt/data, /opt/project</span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/opt/data\"</span>,<span class=\"string\">\"/opt/project\"</span>]</span><br></pre></td></tr></table></figure>\n<p>当然,关于数据卷的操作,肯定不止挂载这一点,还有迁移,备份等等,相关操作. 具体,可以参考: Docker VOLUME</p>\n<h2 id=\"添加外部文件ADD\"><a href=\"#添加外部文件ADD\" class=\"headerlink\" title=\"添加外部文件ADD\"></a>添加外部文件ADD</h2><p>有时,我们仅仅是想将外部文件copy到container中,docker有办法吗？<br>nonsense<br>docker 提供了ADD命令,来帮助我们完成文件的添加. 不过,这里ADD有点限制, 即, 你添加的文件或者目录,只能在docker build运行的目录下, 因为,这是docker在调起container的时候,只将该目录放进了daemon(尴尬)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">现假设,docker build运行的目录为: /data</span><br><span class=\"line\">// 只能添加指定目录下</span><br><span class=\"line\">// 将/data/sam.js 添加到image中的/opt/node/sam.js</span><br><span class=\"line\">// 如果存在该文件,则不会被覆盖</span><br><span class=\"line\">ADD sam.js /opt/node/</span><br><span class=\"line\">添加文件,还可以使用通配符</span><br><span class=\"line\">// 将所有的js文件,添加到node目录下</span><br><span class=\"line\">ADD *.js /opt/node/</span><br><span class=\"line\">如果destination不是绝对路径,则相对于最近的WORKDIR</span><br><span class=\"line\">// 如果最近的WORKDIR为/var</span><br><span class=\"line\">// 则下列添加的路径为/var/opt/node</span><br><span class=\"line\">ADD *.js opt/node/</span><br></pre></td></tr></table></figure>\n<p>当文件被添加到指定目录中时,该文件的权限是755,并且UID和GID都是0.<br>ADD 还支持url添加,以及文件自动解压.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用url添加</span><br><span class=\"line\">// 将指定路由的文件放到根目录当中</span><br><span class=\"line\">ADD http://example.com/foobar /</span><br><span class=\"line\">自动解压tar.gz文件</span><br><span class=\"line\">// 将文件解压过后放在指定目录中</span><br><span class=\"line\">ADD latest.tar.gz /var/www/wordpress/</span><br></pre></td></tr></table></figure>\n<h2 id=\"纯粹的COPY\"><a href=\"#纯粹的COPY\" class=\"headerlink\" title=\"纯粹的COPY\"></a>纯粹的COPY</h2><p>COPY和ADD非常类似. 我们可以做个类比:<br>ADD 包含 COPY<br>COPY做的事情比不上ADD, 他比ADD少了解压缩和URL下载的功能. 不过,他耗费的性能比较少,他只做纯粹的添加和下载.他的结构和ADD一毛一样. 不过, 有一点,COPY的时候,如果遇到目录不存在的情况下,COPY会自动创建</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY file.js /opt/data/</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加个人信息LABEL\"><a href=\"#添加个人信息LABEL\" class=\"headerlink\" title=\"添加个人信息LABEL\"></a>添加个人信息LABEL</h2><p>顾名思义,使用LABEL就是给你的image打上独一无二的标签.让别人能够了解,这个Image是属于你的. 又或是,用来提醒你自己,这个image现在处于哪一个版本状态.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置自己的label</span><br><span class=\"line\">LABEL owner=<span class=\"string\">\"jimmy\"</span> version=<span class=\"string\">\"0.0.1\"</span></span><br></pre></td></tr></table></figure>\n<p>在创建完image之后, 我们可以使用docker inspect来查看我们已经打的LABEL</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect jimmy/node</span><br><span class=\"line\">...</span><br><span class=\"line\">labels:&#123;</span><br><span class=\"line\">owner:<span class=\"string\">\"jimmy\"</span>,</span><br><span class=\"line\">version:<span class=\"string\">\"0.0.1\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>本人觉得, 这个指令其实真的,有时, 母鸡用到什么地方去…<br>并且,书写的时候,最好多个连着写,因为这样只会增加一层image.(image的层数是有限制的)</p>\n<h2 id=\"参数形式ARG\"><a href=\"#参数形式ARG\" class=\"headerlink\" title=\"参数形式ARG\"></a>参数形式ARG</h2><p>这是docker提供的另外一个,让我有点懵逼的命令. 他的实际效果和ENV的区别可以趋近于无。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ARG定义变量</span><br><span class=\"line\">ARG buildno</span><br><span class=\"line\">设置默认值</span><br><span class=\"line\">ARG user1=someuser</span><br></pre></td></tr></table></figure>\n<p>当然,我们可以在命令中,手动指定替换.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在dockerfile定义了默认变量</span><br><span class=\"line\">ARG user=jimy</span><br><span class=\"line\">在运行时,进行手动替换</span><br><span class=\"line\">docker build --build-arg user=sam -t jimmy/demo .</span><br></pre></td></tr></table></figure>\n<p>上面说了ARG和ENV比较类似,不过,里面的区别还是有的. 即, ARG只能用在docker build的阶段, 并且不会被保存在image中,这就是和ENV的区别.</p>\n<h2 id=\"模板image之ONBUILD\"><a href=\"#模板image之ONBUILD\" class=\"headerlink\" title=\"模板image之ONBUILD\"></a>模板image之ONBUILD</h2><p>因为dockerfile的构建的层数有限制,所以,这也带给了我们一些麻烦, 如果搭建的环境过多,则会造成写到一半,发现dockerfile已经full. 这时候, 就轮到ONBUILD出场了. ONBUILD的作用在于,他可以完美的实现模板image的搭建.<br>ONBUILD的主要作用在于,他定义的命令,可以在子dockerfile中使用.(md… 好绕口)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ONBUILD 默认下载Apache</span><br><span class=\"line\">ONBUILD RUN apt-get update &amp;&amp; apt-get install -y apache2</span><br><span class=\"line\"></span><br><span class=\"line\">// 然后运行docker file 会得到下列结果</span><br><span class=\"line\"> Step 3 : ONBUILD RUN apt-get update &amp;&amp; apt-get install -y apache2</span><br><span class=\"line\">   ---&gt; Running <span class=\"keyword\">in</span> 0e117f6ea4ba</span><br><span class=\"line\">   ---&gt; a79983575b8</span><br><span class=\"line\"></span><br><span class=\"line\">//然后生成一个新的image,我们这里暂且叫他jimmy/demo</span><br></pre></td></tr></table></figure>\n<p>接下来,我们再来写一个dockerfile</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里继承上面的jimmy/demo</span><br><span class=\"line\">FROM jimmy/demo:latest</span><br><span class=\"line\">ENV SEX=001</span><br><span class=\"line\"></span><br><span class=\"line\">// 运行上面的dockerfile,得到:</span><br><span class=\"line\">Step 0 : FROM jimmy/demo</span><br><span class=\"line\">Executing 1 build triggers</span><br><span class=\"line\">   Step onbuild-0 : ADD . /var/www/</span><br><span class=\"line\">   ---&gt; 1a018213a59d</span><br><span class=\"line\">   ---&gt; 1a018213a59d</span><br><span class=\"line\"> Step 1: ENV SEX=001</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n<p>细心的童鞋可以发现这一条命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step onbuild-0 : RUN apt-get update &amp;&amp; apt-get install -y apache2</span><br><span class=\"line\">  ---&gt; 1a018213a59d</span><br><span class=\"line\">  ---&gt; 1a018213a59d</span><br></pre></td></tr></table></figure>\n<p>他居然在这里自动运行了. 所以,我们可以将ONBUILD命令理解为模板命令. 即,子dockerfile里面运行时同样生效(这里,我没有说grandchildren的事).<br>但ONBUILD只能往下延伸一级. 相当于你用ONBUILD定义的命令,有两次有效次数,一次在build原来Image时,已经用掉了. 所以, 另外一次(在子dockerfile中使用)用掉了之后就无效了. grandchildren dockerfile就没法使用了.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>转载自<a href=\"https://segmentfault.com/a/1190000006186977?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">快速掌握Dockerfile</a></p>\n<h2 id=\"docker镜像的简单剖析\"><a href=\"#docker镜像的简单剖析\" class=\"headerlink\" title=\"docker镜像的简单剖析\"></a>docker镜像的简单剖析</h2><p>docker的images,我们可以理解为积木, 一层一层往上搭, 最后完成一个工程化的大项目.<br>在最初,docker实际上,只有一个静态的image(Ps: read-only). 相当于只能读, 所以, 你所有的改动并不会影响到原来的image上, 只会一层一层的叠加, 比如, 你在Ubuntu的image上面, 再接一层nodeJS的image. 实际上的结果是, 两个image叠加起来.<br>这里放一张 <strong>the Docker book</strong>的说明图:<br><img src=\"http://p09eeagrw.bkt.clouddn.com/59773500.jpg\" alt=\"\"><br>docker 在下载image的时候,会在/var/lib/docker目录下创建相关的image 目录. 而运行的container则会放在/var/lib/docker/containers中.<br>另外,docker中的image,是存储在docker仓库. 现在,我们通过快速创建自已的仓库来仔细了解一下docker是怎样拥有这样一个完善的生态的.</p>\n<h2 id=\"docker-仓库\"><a href=\"#docker-仓库\" class=\"headerlink\" title=\"docker 仓库\"></a>docker 仓库</h2><p>首先, 要想拥有自己的docker 仓库, 你得有一个自己的docker账号.so, 那就想apply 一个呗. 在docker hub上面注册一下自己的账号就行.</p>\n<h2 id=\"登录指令\"><a href=\"#登录指令\" class=\"headerlink\" title=\"登录指令\"></a>登录指令</h2><p>在docker中,不仅支持web查看docker中的内容, 而且还支持使用命令行登录.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 登录到docker</span><br><span class=\"line\">docker login // 然后输入账户密码就ok了</span><br><span class=\"line\">// 使用完毕,想要登出</span><br><span class=\"line\">docker <span class=\"built_in\">logout</span></span><br></pre></td></tr></table></figure>\n<p>实际上,docker会将你的认证信息存放在. /.docker/config.json当中。</p>\n<h2 id=\"images-常用命令\"><a href=\"#images-常用命令\" class=\"headerlink\" title=\"images 常用命令\"></a>images 常用命令</h2><p>如果浏览了上面的docker仓库, 会发现在一个repository里面会存在很多images, 比如ubuntu的repository.不同的images发布,代表的都是特定的版本系统. 所以,在拉取的时候,需要额外注意一下你需要的指定docker images.</p>\n<h2 id=\"images的拉取\"><a href=\"#images的拉取\" class=\"headerlink\" title=\"images的拉取\"></a>images的拉取</h2><p>在container中,我们讲过,使用docker run的时候, 你会发现如果你的images里面没有存在指定的image时, docker会主动去docker hub里面找,然后下载,并且自动运行.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 运行最新版的ubuntu image</span><br><span class=\"line\">docker run -t -i ubuntu:latest</span><br></pre></td></tr></table></figure>\n<p>如果,你想自己手动下载images的话,可以直接pull</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 手动拉取images</span><br><span class=\"line\">docker pull ubuntu:latest</span><br><span class=\"line\">// 拉取12.04版本的ubuntu images</span><br><span class=\"line\">docker pull ubuntu:12.04</span><br></pre></td></tr></table></figure>\n<p>如果在拉取的时候,想知道这个image是否是真正存在的话,就可以使用.docker 提供的搜索指令.</p>\n<h2 id=\"搜索指定docker\"><a href=\"#搜索指定docker\" class=\"headerlink\" title=\"搜索指定docker\"></a>搜索指定docker</h2><p>在docker中,可以使用自带的search命令,搜索所有含有指定term的image. 相当于js中的search 方法.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 搜索name中含有demo的image</span><br><span class=\"line\">docker search demo</span><br><span class=\"line\">// 结果为: 名字. 通常为: author/image_name . 通常搜索的就是这个</span><br><span class=\"line\">// 描述: 就是一段文字描述</span><br><span class=\"line\">NAME  DESCRIPTION  STARS OFFICIAL   AUTOMATED</span><br></pre></td></tr></table></figure>\n<p>查到之后,我们就可以使用pull将指定的库,拉下来了.</p>\n<h2 id=\"创建自己的image\"><a href=\"#创建自己的image\" class=\"headerlink\" title=\"创建自己的image\"></a>创建自己的image</h2><p>上面说过, contianer是copy image运行的进程容器,image是不会变的read-only 块. 但是,如果我们在container里面, 改动了一些设置,比如,下载了node, 而且,我想要保存我这次改动, 以至于,下次我想重新,启动该image时, 他已经具备了node.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 现在我再ubuntu:latest上面安装了node</span><br><span class=\"line\">// 伪代码</span><br><span class=\"line\">npm install node -g</span><br></pre></td></tr></table></figure>\n<p>docker提供了一个非常快捷的方式就是创建自己的docker image. 使用docker commit.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看刚才改动的container ID</span><br><span class=\"line\">docker ps -a -q -l</span><br><span class=\"line\">// 得到 docker_id, 提交到自己的库中</span><br><span class=\"line\">docker commit docker_id villainHR/node</span><br><span class=\"line\">// 之后会返回新的image id</span><br></pre></td></tr></table></figure>\n<p>需要注意,docker commit提交的并不是一个整体的100+MB的ubuntu+node. 他只会将两个仓库的差异提交,比如原来image和新的image比起来,就是多了一个npm install node -g命令.</p>\n<h2 id=\"使用Dockerfile\"><a href=\"#使用Dockerfile\" class=\"headerlink\" title=\"使用Dockerfile\"></a>使用Dockerfile</h2><p>Dockerfile是为了迅速的构建image而出现的. 他与docker commit 的区别在于. 能够迅速的更替历史image 命令. 比如,我们以前下载的npm是version 2, 现在想要更换为npm@3的话,则难度就不是一般的了. 但是,如果我们能够像写命令一样将下载的配置命令下载Dockerfile里面, 那么以后我们想要更换版本,就是很方便的啦.<br>ok, 现在我们来了解一下Dockerfile是怎样的运行的.<br>dockerfile demo讲解<br>这里,我们利用dockerfile 来搭建一个简单的webServer. 首先创建一个你自己的dockerfile目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir first_docker</span><br><span class=\"line\"><span class=\"built_in\">cd</span> first_docker</span><br><span class=\"line\">touch Dockerfile</span><br></pre></td></tr></table></figure>\n<p>然后, 确保你有ubuntu:latest image.因为, 接下来我们就是基于它,来搭建我们的server.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first dockerfile demo</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">设置该dockerfile的作者和联系邮箱</span><br><span class=\"line\">MAINTAINER Jimmy <span class=\"string\">\"villainhr@gmail.com\"</span></span><br><span class=\"line\">开始配置环境, 下载apt-get,生成index.html的文件</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class=\"line\">RUN <span class=\"built_in\">echo</span> <span class=\"string\">'first demo'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class=\"line\">暴露server的port</span><br><span class=\"line\">EXPOSE 80</span><br></pre></td></tr></table></figure>\n<p>说一下上面的命令内涵.<br>•    FROM: 用来指定第一层image, 这是必须有的. 并且指定的image是存在在你的computer中. 相当于是 docker run.  </p>\n<p>•    RUN: 这是用来在container中,做出相应的修改. 相当于 修改+docker commit xxx. 给原来的image加上一层layer. 然后, docker会在你commit新一层之后,重新docker run你最新改动过的image  </p>\n<p>•    MAINTAINER: 设置作者和联系邮箱.其实就是docker commit 后面的Name参数. 而且加上了联系邮箱. 这是在dockerfile 运行完后,会自动添加到image上的.  </p>\n<p>•    EXPOSE: 用来给最新的container 设置与外部交流的port  </p>\n<p>上面简单的介绍了基本的dockerfile的命令. 不过, 这尼玛太简单了,不符合我们一贯追求到底的风格.<br>这里, 我们在来细说一下RUN这个命令. 实际上, 这应该是dockerfile的关键. RUN的原理很简单, 就是commit + run. 先创建一个新的image 然后 在这个基础上将原有的container替换为新的,如果某一步的RUN发生错误,则container会停在那个阶段, 这样,你可以直接进入该container去查看,你那一步的RUN发生了什么BUG。 另外, 使用RUN的时候, 需要注意, 由于,dockerfile是由上到下解析的, 比如你一开始FROM ubuntu的image, 那么此时的环境是停留在ubuntu的shell中的.<br>比如:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN touch demo.js</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">/bin/sh -c touch demo.js</span><br></pre></td></tr></table></figure>\n<p>所以, 如果你调用的image 并没有shell的话, 那么久需要使用exec调用系统shell 来执行命令.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用系统的shell来运行, 实际上就是 <span class=\"built_in\">exec</span> xxx xxx xxx.</span><br><span class=\"line\">RUN [<span class=\"string\">\"npm\"</span>,<span class=\"string\">\"install\"</span>,<span class=\"string\">\"node\"</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行dockerfile\"><a href=\"#运行dockerfile\" class=\"headerlink\" title=\"运行dockerfile\"></a>运行dockerfile</h2><p>上面的dockerfile文件配置好了之后,就轮到我们运行dockerfile.直接运行docker build即可.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注意后面的<span class=\"string\">\".\"</span>, 用来指定搜索dockerfile文件的路径. </span><br><span class=\"line\">docker build -t=<span class=\"string\">\"jimmy/first_dockerfile\"</span> .</span><br></pre></td></tr></table></figure>\n<p>说一下docker build的指令吧.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基本格式为:</span><br><span class=\"line\">docker build -t=<span class=\"string\">\"repository/name:tag\"</span>  directory</span><br><span class=\"line\">// -t用来指定生成的image的name,比如仓库,image的名字以及他的tag,如果你不指定tag, 那么docker会自动添加latest代替。</span><br><span class=\"line\">// directory 用来相对于当前运行build的目录, 搜索指定的dockerfile.当然,你也可以使用绝对路径了</span><br></pre></td></tr></table></figure>\n<p>顺利的话,应该就会有, 下列的信息出来.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sending build context to Docker daemon 2.048 kB</span><br><span class=\"line\">Step 1 : FROM ubuntu:latest</span><br><span class=\"line\"> ---&gt; c5f1cf30c96b</span><br><span class=\"line\">Step 2 : MAINTAINER jimmy <span class=\"string\">\"villainhr@gmai.com\"</span></span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 078148a5086a</span><br><span class=\"line\"> ---&gt; 11b061f665d1</span><br><span class=\"line\">Removing intermediate container 078148a5086a</span><br><span class=\"line\">Step 3 : RUN <span class=\"built_in\">cd</span> /var</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> ffd3141e64c8</span><br><span class=\"line\"> ---&gt; a4d7c5303b60</span><br><span class=\"line\">Removing intermediate container ffd3141e64c8</span><br><span class=\"line\">Step 4 : RUN touch demo.js</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> c8393a6fcc98</span><br><span class=\"line\"> ---&gt; 109b402b9adc</span><br><span class=\"line\">Removing intermediate container c8393a6fcc98</span><br><span class=\"line\">Step 5 : EXPOSE 80</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 2c064f4bac57</span><br><span class=\"line\"> ---&gt; ff7ad58a5d8a</span><br><span class=\"line\">Removing intermediate container 2c064f4bac57</span><br><span class=\"line\">Successfully built ff7ad58a5d8a</span><br></pre></td></tr></table></figure>\n<p>然后, 你可以使用docker images查看.就会发现多出来一个image.</p>\n<h2 id=\"dockerfile-cache\"><a href=\"#dockerfile-cache\" class=\"headerlink\" title=\"dockerfile cache\"></a>dockerfile cache</h2><p>上面已经提到过,使用docker build的时候,如果你的dockerfile中的某一步出现问题的话,你生成的image会停留在那一步.当你fix errors时, 重新运行docker build, 此时,docker是不会真的重头来建一遍的,他会使用你改动line的前一个image,然后以此为基点继续向下构建.<br>不过,如果你使用缓存的话,他前面的版本id是不会发生改变的.如果你想完整的得到一个新的ID的话,就可以在build的时候,禁用掉cache.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build --no-cache -t=<span class=\"string\">\"jimmy/first_dockerfile\"</span> .</span><br></pre></td></tr></table></figure>\n<p>不过,该方法是不推荐的. 因为一个非常棒的cache机制,就被你硬生生的cancel. 而且,这也极力不推荐使用该方法进行cache的取消.以为,有些地方,我们完全可以利用cache来加快速度.这就需要使用到ENV关键字.来帮助我们,另外利用cache.<br>在讲解ENV之前,先给大家讲解一下docker cache的运行机理.<br>（是不是感觉很激动）<br>实际上,机理就一句话:ID命中. 因为docker在你每次运行一行命令的时候,会自动生成一个id值.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sending build context to Docker daemon 2.048 kB</span><br><span class=\"line\">Step 1 : FROM ubuntu:latest</span><br><span class=\"line\"> ---&gt; c5f1cf30c96b  // 这就是ID值</span><br></pre></td></tr></table></figure>\n<p>docker借由这个ID值,来判断是否有cache镜像.所以,这里就需要借一下ENV这个比较费的指令,来灵活的帮助我们使用cache.</p>\n<h2 id=\"配置化cache\"><a href=\"#配置化cache\" class=\"headerlink\" title=\"配置化cache\"></a>配置化cache</h2><p>ENV的就是给docker来设置变量的. 基本格式为:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个一个的赋值</span><br><span class=\"line\">ENV key value</span><br><span class=\"line\">// demo:</span><br><span class=\"line\">ENV name jimmy</span><br><span class=\"line\">ENV age 18</span><br><span class=\"line\">另外,还可以一起赋值</span><br><span class=\"line\">ENV key=value[...]</span><br><span class=\"line\">// demo:</span><br><span class=\"line\">ENV name=jimmy age=18</span><br></pre></td></tr></table></figure>\n<p>而通过ENV我们就可以完美的告诉docker 从这里开始,你就不能使用cache,自己的重新来.(因为,每条指令都会生成layer并且有独立的id,一旦你更改的ENV,那么从该指令开始id都会发生改变,也就匹配不到缓存了)<br>看个demo:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个dockerfile</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">MAINTAINER jimmy <span class=\"string\">\"villainhr@gmai.com\"</span></span><br><span class=\"line\">ENV REFRESH first <span class=\"comment\"># 这里设置的是refresh=first</span></span><br><span class=\"line\">RUN <span class=\"built_in\">cd</span> /var</span><br><span class=\"line\">RUN touch demo.js</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用docker build ... 后面就会生成一系列新的id和images</span><br><span class=\"line\">// 现在修改dockerfile</span><br><span class=\"line\">第二个dockerfile</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">MAINTAINER jimmy <span class=\"string\">\"villainhr@gmai.com\"</span></span><br><span class=\"line\">ENV REFRESH second <span class=\"comment\"># 这里设置的是refresh=second</span></span><br><span class=\"line\">RUN <span class=\"built_in\">cd</span> /var</span><br><span class=\"line\">RUN touch demo.js</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\"></span><br><span class=\"line\">// 开始运行docker build... 你会发现,从下面语句开始.</span><br><span class=\"line\">ENV REFRESH second</span><br><span class=\"line\">// 其docker id就已经发生了改变,并且docker 没有了use cache的提示.说明,下面就没有命中缓存了. 所以,如果你想在某一段不使用缓存,只需要将ENV后面的value改变即可.</span><br></pre></td></tr></table></figure>\n<p>创建完后, 我们可以使用docker history,查看一下刚才创建的image的整个流程.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看image创建的过程</span><br><span class=\"line\">docker <span class=\"built_in\">history</span> jimmy/first_dockerfile </span><br><span class=\"line\">// 输出的结果为:</span><br><span class=\"line\">2322ddc85cc3        10 hours ago        /bin/sh -c <span class=\"comment\">#(nop) EXPOSE 80/tcp                 0 B                 </span></span><br><span class=\"line\">b39397abc7aa        10 hours ago        /bin/sh -c touch demo.js                        0 B                 </span><br><span class=\"line\">3c9a4daf4c42        10 hours ago        /bin/sh -c <span class=\"built_in\">cd</span> /var                              0 B                 </span><br><span class=\"line\">b1c2f890a262        10 hours ago        /bin/sh -c <span class=\"comment\">#(nop) ENV REFRESH=second            0 B                 </span></span><br><span class=\"line\">2cf0ee3c373c        10 hours ago        /bin/sh -c <span class=\"comment\">#(nop) MAINTAINER jimmy \"villainhr   0 B</span></span><br></pre></td></tr></table></figure>\n<p>俺的目的,其实是想让你们看看,docker在每一层是怎么执行的–/bin/sh. 了解了之后,我们就继续了.</p>\n<h2 id=\"docker-container的接口暴露\"><a href=\"#docker-container的接口暴露\" class=\"headerlink\" title=\"docker container的接口暴露\"></a>docker container的接口暴露</h2><p>上面通过dockerfile 已经暴露了一个80接口,用来和外部通信。 不过,如果我们没有使用EXPOSE暴露接口的话, 那应该怎么做呢？<br>我们可以直接在外部运行docker image, 手动指定暴露的端口.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同样,暴露80端口给外部交互</span><br><span class=\"line\">docker run -d -p 80 --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br><span class=\"line\"></span><br><span class=\"line\">-d是daemon的意思</span><br><span class=\"line\">-p 80 表示暴露80的port给外部</span><br><span class=\"line\">node -jimmy app.js 表示在jimmy/node image里面运行的指令</span><br></pre></td></tr></table></figure>\n<p>这里, 我们需要额外了解一下80端口的开启. docker 其实是在底层上面,虚拟化了存储. 并且,docker在运行的时候,会自动向主机要一个ip(假的), 相当于,有了自己的host. (这不就一个主机吗？)<br>这里我们开启的80端口,是docker在内部虚拟开启的, 他会从32768 到 61000端口之间,随机抽一个映射到docker开启的80端口上, 依此来和外部进行真正的交互(膜拜///).</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用docker ps -l 来查看开启情况</span><br><span class=\"line\">docker ps -l</span><br><span class=\"line\">得到: 只截取了一部分.</span><br><span class=\"line\">0.0.0.0:49154-&gt;80 tcp</span><br><span class=\"line\">或者指定查看docker端口开启情况</span><br><span class=\"line\">docker port c96f2c18bb64 80 // ID也可以使用name代替</span><br><span class=\"line\">返回:</span><br><span class=\"line\"> 0.0.0.0:49154</span><br></pre></td></tr></table></figure>\n<h2 id=\"手动指定端口\"><a href=\"#手动指定端口\" class=\"headerlink\" title=\"手动指定端口\"></a>手动指定端口</h2><p>如果你不想让docker决定的绑定的接口是哪一个,ok, 你可以自己指定.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">手动指定端口</span><br><span class=\"line\">指定docker的8080连接到container暴露的80端口</span><br><span class=\"line\">docker run -d -p 8080:80 --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br><span class=\"line\">甚至你也可以指定ip+port</span><br><span class=\"line\">指定docker的127.0.0.1:8080连接container的80</span><br><span class=\"line\">docker run -d -p 127.0.0.1:8080:80 --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br></pre></td></tr></table></figure>\n<h2 id=\"利用EXPOSE\"><a href=\"#利用EXPOSE\" class=\"headerlink\" title=\"利用EXPOSE\"></a>利用EXPOSE</h2><p>在写dockerfile的时候,我们已经了解了,使用EXPOSE可以完美的实现端口的暴露. 但如果,我们在dockerfile里面暴露多个port的话,那么-p的参数,感觉有点鸡肋啊喂<br>不过,现在我们可以使用-P(注意是大写). 来手动开启所有在dockerfile中,通过EXPOSE暴露的端口.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -P --name demo jimmy/node \\</span><br><span class=\"line\">node -jimmy app.js</span><br></pre></td></tr></table></figure>\n<h2 id=\"外部访问\"><a href=\"#外部访问\" class=\"headerlink\" title=\"外部访问\"></a>外部访问</h2><p>通过端口开启之后,我们就可以间接的访问docker的路由, 来访问在docker里面开启的端口了.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假如上面我们通过dockre暴露的端口是34251的话,就可以在docker环境外访问了.</span><br><span class=\"line\">ping localhost:34251</span><br></pre></td></tr></table></figure>\n<h2 id=\"dockerfile常用指令\"><a href=\"#dockerfile常用指令\" class=\"headerlink\" title=\"dockerfile常用指令\"></a>dockerfile常用指令</h2><p>自动化运行CMD<br>你是不是已经厌烦了使用docker run 来运行命令了呢？ 你是不是已经讨厌重复的copy命令运行了呢？<br>那么请使用CMD吧.<br>CMD的作用是,用来指定当你调其对应的container时, 运行的命令.<br>比如在dockerfile中,指定/bin/bash.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当调起container时,运行/bin/bash</span><br><span class=\"line\">docker run  -t -i jimmy/ubuntu:latest /bin/bash</span><br><span class=\"line\">等同于在dockerfile中指定CMD</span><br><span class=\"line\">CMD [<span class=\"string\">\"/bin/bash\"</span>]</span><br><span class=\"line\">// 运行docker run</span><br><span class=\"line\">docker run -t -i jimmy/ubuntu:latest</span><br></pre></td></tr></table></figure>\n<p>不过,如果你在run后面手动指定指令运行的话,会默认覆盖掉CMD提供的命令.<br>熟悉了CMD,感觉有种RUN的感觉. 但,这两者的区别还是很大的<br>•    RUN: 一般是用来给image增加layer来完善image, 他一旦执行完,就和后面的运行没有关系了  </p>\n<p>•    CMD: 这个在docker build过程中,是没有半毛钱关系的. 他只和在调用image时,关系比较大  </p>\n<h2 id=\"强制运行ENTRYPOINT\"><a href=\"#强制运行ENTRYPOINT\" class=\"headerlink\" title=\"强制运行ENTRYPOINT\"></a>强制运行ENTRYPOINT</h2><p>这里的ENTRYPOINT和CMD很相似. 可以说,在一定程度上两者可以互相替代,但,两者的实际意义相差还是挺大的.<br>ENTRYPOINT的主要功能是强制执行的环境.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">指定ENTRYPOINT为/bin/sh</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/bin/sh\"</span>]</span><br><span class=\"line\">// 然后在build之后,调起container</span><br><span class=\"line\">我们尝试在run后面加上参数:</span><br><span class=\"line\">docker run -t -i jimmy/demo /bin/bash/</span><br><span class=\"line\">// 不出意外的话,会得到一个bug提示:</span><br><span class=\"line\">&gt;&gt;/bin/sh: 0: Can<span class=\"string\">'t open /bin/bash/</span></span><br></pre></td></tr></table></figure>\n<p>所以, ENTRYPOINT的主要功能实际上是,指定了内部运行命令的解析器. 而使用docker run添加的命令,会被当做参数添加给ENTRYPOINT.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">已经指定了ENTRYPOINT [<span class=\"string\">\"/bin/sh\"</span>]</span><br><span class=\"line\">运行docker run</span><br><span class=\"line\">docker run -t -i jimmy/demo /bin/bash/</span><br><span class=\"line\">实际上相当于(不出错才怪嘞...)</span><br><span class=\"line\">/bin/sh /bin/bash/</span><br></pre></td></tr></table></figure>\n<p>另外,我们还可以使用CMD配合ENTRYPOINT写成默认参数的效果.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认执行 /bin/bash default.sh</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/bin/bash\"</span>]</span><br><span class=\"line\">CMD [<span class=\"string\">\"default.sh\"</span>]</span><br><span class=\"line\">如果你在docker run中指定了参数的话,则CMD会默认被代替 </span><br><span class=\"line\">docker run jimmy/demo sam.sh</span><br></pre></td></tr></table></figure>\n<p>不过,CMD和ENTRYPOINT都只能在dockerfile里面出现一次.</p>\n<h2 id=\"指定运行目录WORKDIR\"><a href=\"#指定运行目录WORKDIR\" class=\"headerlink\" title=\"指定运行目录WORKDIR\"></a>指定运行目录WORKDIR</h2><p>既然,我们能够在dockerfile里面运行指定的命令。 但,有时,我们仅仅是想在不同的目录中执行不同的命令. 那,在dockerfile中,如何做到灵活的目录切换呢？<br>那就得使用docker提供的WORKDIR命令了.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在/var/data里面创建data.js</span><br><span class=\"line\">WORKDIR /var/data</span><br><span class=\"line\">RUN touch data.js</span><br><span class=\"line\">然后在/etc 下创建data.conf文件</span><br><span class=\"line\">WORKDIR /etc</span><br><span class=\"line\">RUN touch data.conf</span><br></pre></td></tr></table></figure>\n<p>并且当你在使用docker run时,他也会停留在使用WORKDIR指定的目录中.</p>\n<h2 id=\"环境变量的设置ENV\"><a href=\"#环境变量的设置ENV\" class=\"headerlink\" title=\"环境变量的设置ENV\"></a>环境变量的设置ENV</h2><p>ENV在dockerfile里面的用处,应该算是灰常大的. 什么灵活更新,什么变量设置,什么更改全局变量等. 都是so easy.<br>那ENV到底是用来干嘛的?<br>答: 就是用来设置变量的啊喂. 只是他是设置全局变量.<br>比如像PATH神马的之类的.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置一个DATA的全局变量.</span><br><span class=\"line\">ENV DATA=jimmy</span><br></pre></td></tr></table></figure>\n<p>ENV最独特之处在于,他所设置的变量,会在你运行的时候生效.即,如果你修改了PATH,他也会在container中立即生效.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修改环境变量</span><br><span class=\"line\">ENV PATH=<span class=\"variable\">$PATH</span>:/user/bin</span><br><span class=\"line\">// 现在进入到运行的container中</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$PATH</span></span><br><span class=\"line\">&gt;&gt; /usr/<span class=\"built_in\">local</span>/sbin:/usr/<span class=\"built_in\">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data</span><br></pre></td></tr></table></figure>\n<h2 id=\"挂载通用盘VOLUME\"><a href=\"#挂载通用盘VOLUME\" class=\"headerlink\" title=\"挂载通用盘VOLUME\"></a>挂载通用盘VOLUME</h2><p>在说里面正式的内容之前,我们先来说一下,什么叫做VOLUME. 说人话吧,VOLUME叫做数据卷, 相当于通用盘一样的东西. 他其实也是一个存储装置,我们就把他叫做硬盘吧. 这个硬盘不普通,有>1的外接口.(说人话) 每一个外接口,都可以接入到一个操作系统里面. 即,实现了多个系统的数据共享.<br>一句话:</p>\n<blockquote>\n<p>VOLUME就是一个数据共享盘<br>而,docker秉承着,虚拟储存idea, 想下面idea践行到底.<br>wirte once, run anywhere<br>(感觉,在哪见过)<br>所以, dockerfile提供了一个VOLUME的指令,能够让我们指定数据卷的位置.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">指定/opt/data为数据卷</span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/opt/data\"</span>]</span><br><span class=\"line\">指定多个目录为数据卷/opt/data, /opt/project</span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/opt/data\"</span>,<span class=\"string\">\"/opt/project\"</span>]</span><br></pre></td></tr></table></figure>\n<p>当然,关于数据卷的操作,肯定不止挂载这一点,还有迁移,备份等等,相关操作. 具体,可以参考: Docker VOLUME</p>\n<h2 id=\"添加外部文件ADD\"><a href=\"#添加外部文件ADD\" class=\"headerlink\" title=\"添加外部文件ADD\"></a>添加外部文件ADD</h2><p>有时,我们仅仅是想将外部文件copy到container中,docker有办法吗？<br>nonsense<br>docker 提供了ADD命令,来帮助我们完成文件的添加. 不过,这里ADD有点限制, 即, 你添加的文件或者目录,只能在docker build运行的目录下, 因为,这是docker在调起container的时候,只将该目录放进了daemon(尴尬)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">现假设,docker build运行的目录为: /data</span><br><span class=\"line\">// 只能添加指定目录下</span><br><span class=\"line\">// 将/data/sam.js 添加到image中的/opt/node/sam.js</span><br><span class=\"line\">// 如果存在该文件,则不会被覆盖</span><br><span class=\"line\">ADD sam.js /opt/node/</span><br><span class=\"line\">添加文件,还可以使用通配符</span><br><span class=\"line\">// 将所有的js文件,添加到node目录下</span><br><span class=\"line\">ADD *.js /opt/node/</span><br><span class=\"line\">如果destination不是绝对路径,则相对于最近的WORKDIR</span><br><span class=\"line\">// 如果最近的WORKDIR为/var</span><br><span class=\"line\">// 则下列添加的路径为/var/opt/node</span><br><span class=\"line\">ADD *.js opt/node/</span><br></pre></td></tr></table></figure>\n<p>当文件被添加到指定目录中时,该文件的权限是755,并且UID和GID都是0.<br>ADD 还支持url添加,以及文件自动解压.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用url添加</span><br><span class=\"line\">// 将指定路由的文件放到根目录当中</span><br><span class=\"line\">ADD http://example.com/foobar /</span><br><span class=\"line\">自动解压tar.gz文件</span><br><span class=\"line\">// 将文件解压过后放在指定目录中</span><br><span class=\"line\">ADD latest.tar.gz /var/www/wordpress/</span><br></pre></td></tr></table></figure>\n<h2 id=\"纯粹的COPY\"><a href=\"#纯粹的COPY\" class=\"headerlink\" title=\"纯粹的COPY\"></a>纯粹的COPY</h2><p>COPY和ADD非常类似. 我们可以做个类比:<br>ADD 包含 COPY<br>COPY做的事情比不上ADD, 他比ADD少了解压缩和URL下载的功能. 不过,他耗费的性能比较少,他只做纯粹的添加和下载.他的结构和ADD一毛一样. 不过, 有一点,COPY的时候,如果遇到目录不存在的情况下,COPY会自动创建</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY file.js /opt/data/</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加个人信息LABEL\"><a href=\"#添加个人信息LABEL\" class=\"headerlink\" title=\"添加个人信息LABEL\"></a>添加个人信息LABEL</h2><p>顾名思义,使用LABEL就是给你的image打上独一无二的标签.让别人能够了解,这个Image是属于你的. 又或是,用来提醒你自己,这个image现在处于哪一个版本状态.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置自己的label</span><br><span class=\"line\">LABEL owner=<span class=\"string\">\"jimmy\"</span> version=<span class=\"string\">\"0.0.1\"</span></span><br></pre></td></tr></table></figure>\n<p>在创建完image之后, 我们可以使用docker inspect来查看我们已经打的LABEL</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect jimmy/node</span><br><span class=\"line\">...</span><br><span class=\"line\">labels:&#123;</span><br><span class=\"line\">owner:<span class=\"string\">\"jimmy\"</span>,</span><br><span class=\"line\">version:<span class=\"string\">\"0.0.1\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>本人觉得, 这个指令其实真的,有时, 母鸡用到什么地方去…<br>并且,书写的时候,最好多个连着写,因为这样只会增加一层image.(image的层数是有限制的)</p>\n<h2 id=\"参数形式ARG\"><a href=\"#参数形式ARG\" class=\"headerlink\" title=\"参数形式ARG\"></a>参数形式ARG</h2><p>这是docker提供的另外一个,让我有点懵逼的命令. 他的实际效果和ENV的区别可以趋近于无。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ARG定义变量</span><br><span class=\"line\">ARG buildno</span><br><span class=\"line\">设置默认值</span><br><span class=\"line\">ARG user1=someuser</span><br></pre></td></tr></table></figure>\n<p>当然,我们可以在命令中,手动指定替换.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在dockerfile定义了默认变量</span><br><span class=\"line\">ARG user=jimy</span><br><span class=\"line\">在运行时,进行手动替换</span><br><span class=\"line\">docker build --build-arg user=sam -t jimmy/demo .</span><br></pre></td></tr></table></figure>\n<p>上面说了ARG和ENV比较类似,不过,里面的区别还是有的. 即, ARG只能用在docker build的阶段, 并且不会被保存在image中,这就是和ENV的区别.</p>\n<h2 id=\"模板image之ONBUILD\"><a href=\"#模板image之ONBUILD\" class=\"headerlink\" title=\"模板image之ONBUILD\"></a>模板image之ONBUILD</h2><p>因为dockerfile的构建的层数有限制,所以,这也带给了我们一些麻烦, 如果搭建的环境过多,则会造成写到一半,发现dockerfile已经full. 这时候, 就轮到ONBUILD出场了. ONBUILD的作用在于,他可以完美的实现模板image的搭建.<br>ONBUILD的主要作用在于,他定义的命令,可以在子dockerfile中使用.(md… 好绕口)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用ONBUILD 默认下载Apache</span><br><span class=\"line\">ONBUILD RUN apt-get update &amp;&amp; apt-get install -y apache2</span><br><span class=\"line\"></span><br><span class=\"line\">// 然后运行docker file 会得到下列结果</span><br><span class=\"line\"> Step 3 : ONBUILD RUN apt-get update &amp;&amp; apt-get install -y apache2</span><br><span class=\"line\">   ---&gt; Running <span class=\"keyword\">in</span> 0e117f6ea4ba</span><br><span class=\"line\">   ---&gt; a79983575b8</span><br><span class=\"line\"></span><br><span class=\"line\">//然后生成一个新的image,我们这里暂且叫他jimmy/demo</span><br></pre></td></tr></table></figure>\n<p>接下来,我们再来写一个dockerfile</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里继承上面的jimmy/demo</span><br><span class=\"line\">FROM jimmy/demo:latest</span><br><span class=\"line\">ENV SEX=001</span><br><span class=\"line\"></span><br><span class=\"line\">// 运行上面的dockerfile,得到:</span><br><span class=\"line\">Step 0 : FROM jimmy/demo</span><br><span class=\"line\">Executing 1 build triggers</span><br><span class=\"line\">   Step onbuild-0 : ADD . /var/www/</span><br><span class=\"line\">   ---&gt; 1a018213a59d</span><br><span class=\"line\">   ---&gt; 1a018213a59d</span><br><span class=\"line\"> Step 1: ENV SEX=001</span><br><span class=\"line\"> ...</span><br></pre></td></tr></table></figure>\n<p>细心的童鞋可以发现这一条命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step onbuild-0 : RUN apt-get update &amp;&amp; apt-get install -y apache2</span><br><span class=\"line\">  ---&gt; 1a018213a59d</span><br><span class=\"line\">  ---&gt; 1a018213a59d</span><br></pre></td></tr></table></figure>\n<p>他居然在这里自动运行了. 所以,我们可以将ONBUILD命令理解为模板命令. 即,子dockerfile里面运行时同样生效(这里,我没有说grandchildren的事).<br>但ONBUILD只能往下延伸一级. 相当于你用ONBUILD定义的命令,有两次有效次数,一次在build原来Image时,已经用掉了. 所以, 另外一次(在子dockerfile中使用)用掉了之后就无效了. grandchildren dockerfile就没法使用了.</p>\n"},{"title":"搭建ShadowSocks","data":"2017-12-11T06:53:01.000Z","_content":"\n## VPS安装ShadowSocks\n推荐看秋水逸冰的[《Shadowsocks 一键安装脚本（四合一）》][1]的安装教程。\n运行以下命令:\n\n```bash\nwget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh\nchmod +x shadowsocks-all.sh\n./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log\n```\n\n选择脚本（Python、R、Go、libev），任选一个：\n\n```bash\nWhich Shadowsocks server you'd select:\n1.Shadowsocks-Python\n2.ShadowsocksR\n3.Shadowsocks-Go\n4.Shadowsocks-libev\nPlease enter a number (default 1):\n```\n\n笔者选择Shadowsocks-Go，输入3......然后，输入密码和端口，笔者直接回车用默认：\n\n```bash\nYou choose = Shadowsocks-Go\n\nPlease enter password for Shadowsocks-Go\n(default password: teddysun.com):\n\npassword = teddysun.com\n\nPlease enter a port for Shadowsocks-Go [1-65535]\n(default port: 8989):\n\nport = 8989\n\n\nPress any key to start...or Press Ctrl+C to cancel\n```\n\n安装成功后，命令行出现：\n\n```bash\nCongratulations, Shadowsocks-Go server install completed!\nYour Server IP        :  45.32.73.59\nYour Server Port      :  8989\nYour Password         :  teddysun.com\nYour Encryption Method:  aes-256-cfb\n\nWelcome to visit: https://teddysun.com/486.html\nEnjoy it!\n```\n\n（如果安装失败，请尝试其他脚本）\n\n\n[1]:\thttps://teddysun.com/486.html","source":"_posts/搭建ShadowSocks.md","raw":"---\ntitle: 搭建ShadowSocks\ndata:  2017-12-11 14:53:01\ntag:\n- ShadowSocks\ncategories: Linux\n---\n\n## VPS安装ShadowSocks\n推荐看秋水逸冰的[《Shadowsocks 一键安装脚本（四合一）》][1]的安装教程。\n运行以下命令:\n\n```bash\nwget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh\nchmod +x shadowsocks-all.sh\n./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log\n```\n\n选择脚本（Python、R、Go、libev），任选一个：\n\n```bash\nWhich Shadowsocks server you'd select:\n1.Shadowsocks-Python\n2.ShadowsocksR\n3.Shadowsocks-Go\n4.Shadowsocks-libev\nPlease enter a number (default 1):\n```\n\n笔者选择Shadowsocks-Go，输入3......然后，输入密码和端口，笔者直接回车用默认：\n\n```bash\nYou choose = Shadowsocks-Go\n\nPlease enter password for Shadowsocks-Go\n(default password: teddysun.com):\n\npassword = teddysun.com\n\nPlease enter a port for Shadowsocks-Go [1-65535]\n(default port: 8989):\n\nport = 8989\n\n\nPress any key to start...or Press Ctrl+C to cancel\n```\n\n安装成功后，命令行出现：\n\n```bash\nCongratulations, Shadowsocks-Go server install completed!\nYour Server IP        :  45.32.73.59\nYour Server Port      :  8989\nYour Password         :  teddysun.com\nYour Encryption Method:  aes-256-cfb\n\nWelcome to visit: https://teddysun.com/486.html\nEnjoy it!\n```\n\n（如果安装失败，请尝试其他脚本）\n\n\n[1]:\thttps://teddysun.com/486.html","slug":"搭建ShadowSocks","published":1,"date":"2017-12-11T06:53:24.000Z","updated":"2017-12-11T06:55:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjyw0013xqs6v9tmi50x","content":"<h2 id=\"VPS安装ShadowSocks\"><a href=\"#VPS安装ShadowSocks\" class=\"headerlink\" title=\"VPS安装ShadowSocks\"></a>VPS安装ShadowSocks</h2><p>推荐看秋水逸冰的<a href=\"https://teddysun.com/486.html\" target=\"_blank\" rel=\"noopener\">《Shadowsocks 一键安装脚本（四合一）》</a>的安装教程。<br>运行以下命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class=\"line\">chmod +x shadowsocks-all.sh</span><br><span class=\"line\">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>\n<p>选择脚本（Python、R、Go、libev），任选一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Which Shadowsocks server you<span class=\"string\">'d select:</span></span><br><span class=\"line\"><span class=\"string\">1.Shadowsocks-Python</span></span><br><span class=\"line\"><span class=\"string\">2.ShadowsocksR</span></span><br><span class=\"line\"><span class=\"string\">3.Shadowsocks-Go</span></span><br><span class=\"line\"><span class=\"string\">4.Shadowsocks-libev</span></span><br><span class=\"line\"><span class=\"string\">Please enter a number (default 1):</span></span><br></pre></td></tr></table></figure>\n<p>笔者选择Shadowsocks-Go，输入3……然后，输入密码和端口，笔者直接回车用默认：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You choose = Shadowsocks-Go</span><br><span class=\"line\"></span><br><span class=\"line\">Please enter password <span class=\"keyword\">for</span> Shadowsocks-Go</span><br><span class=\"line\">(default password: teddysun.com):</span><br><span class=\"line\"></span><br><span class=\"line\">password = teddysun.com</span><br><span class=\"line\"></span><br><span class=\"line\">Please enter a port <span class=\"keyword\">for</span> Shadowsocks-Go [1-65535]</span><br><span class=\"line\">(default port: 8989):</span><br><span class=\"line\"></span><br><span class=\"line\">port = 8989</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Press any key to start...or Press Ctrl+C to cancel</span><br></pre></td></tr></table></figure>\n<p>安装成功后，命令行出现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, Shadowsocks-Go server install completed!</span><br><span class=\"line\">Your Server IP        :  45.32.73.59</span><br><span class=\"line\">Your Server Port      :  8989</span><br><span class=\"line\">Your Password         :  teddysun.com</span><br><span class=\"line\">Your Encryption Method:  aes-256-cfb</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to visit: https://teddysun.com/486.html</span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure>\n<p>（如果安装失败，请尝试其他脚本）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"VPS安装ShadowSocks\"><a href=\"#VPS安装ShadowSocks\" class=\"headerlink\" title=\"VPS安装ShadowSocks\"></a>VPS安装ShadowSocks</h2><p>推荐看秋水逸冰的<a href=\"https://teddysun.com/486.html\" target=\"_blank\" rel=\"noopener\">《Shadowsocks 一键安装脚本（四合一）》</a>的安装教程。<br>运行以下命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class=\"line\">chmod +x shadowsocks-all.sh</span><br><span class=\"line\">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>\n<p>选择脚本（Python、R、Go、libev），任选一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Which Shadowsocks server you<span class=\"string\">'d select:</span></span><br><span class=\"line\"><span class=\"string\">1.Shadowsocks-Python</span></span><br><span class=\"line\"><span class=\"string\">2.ShadowsocksR</span></span><br><span class=\"line\"><span class=\"string\">3.Shadowsocks-Go</span></span><br><span class=\"line\"><span class=\"string\">4.Shadowsocks-libev</span></span><br><span class=\"line\"><span class=\"string\">Please enter a number (default 1):</span></span><br></pre></td></tr></table></figure>\n<p>笔者选择Shadowsocks-Go，输入3……然后，输入密码和端口，笔者直接回车用默认：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You choose = Shadowsocks-Go</span><br><span class=\"line\"></span><br><span class=\"line\">Please enter password <span class=\"keyword\">for</span> Shadowsocks-Go</span><br><span class=\"line\">(default password: teddysun.com):</span><br><span class=\"line\"></span><br><span class=\"line\">password = teddysun.com</span><br><span class=\"line\"></span><br><span class=\"line\">Please enter a port <span class=\"keyword\">for</span> Shadowsocks-Go [1-65535]</span><br><span class=\"line\">(default port: 8989):</span><br><span class=\"line\"></span><br><span class=\"line\">port = 8989</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Press any key to start...or Press Ctrl+C to cancel</span><br></pre></td></tr></table></figure>\n<p>安装成功后，命令行出现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, Shadowsocks-Go server install completed!</span><br><span class=\"line\">Your Server IP        :  45.32.73.59</span><br><span class=\"line\">Your Server Port      :  8989</span><br><span class=\"line\">Your Password         :  teddysun.com</span><br><span class=\"line\">Your Encryption Method:  aes-256-cfb</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to visit: https://teddysun.com/486.html</span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure>\n<p>（如果安装失败，请尝试其他脚本）</p>\n"},{"title":"手把手搭建Hexo+OSChina博客","date":"2017-11-17T08:03:58.000Z","_content":"\n# 开始之前\n在安装[hexo][1]之前，必须确认你已经安装了[Node.js][2]和[Git][3]。\n## 1.创建GitHub仓库\n注册[OSChina]()账号，创建一个以[https://gitee.com/ding-data/zhengdingblog.git][5]命名的仓库，其中zhengdingblog为仓库名，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。\n## 2.配置Git\n设置Git的用户名和邮件地址（邮箱就是你注册OSChina时候的邮箱），打开Git Bash(MAC打开终端即可)，键入：\n\n``` bash\n$ git config --global user.name \"username\"\n$ git config --global user.email \"email@example.com\"\n```\n\n## 3.本地Git与OSChina建立联系\n这里介绍SSH的配置，先检查电脑是否已经有SSH  \n\n``` bash\n$ ls -al ~/.ssh\n```\n\n如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。  \n输入以下指令后，一路回车就好：  \n\n``` bash\n$ ssh-keygen -t rsa -C \"emailt@example.com\"\n```\n\n然后键入以下指令：\n\n``` bash\n$ ssh-agent -s\n$ ssh-add ~/.ssh/id_rsa\n```\n\n如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：  \n\n``` bash\n$ ssh-agent bash\n```\n\n再重新输入指令：  \n\n```bash\n$ ssh-add ~/.ssh/id_rsa\n```\n\n到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：  \n\n```bash\n$ clip < ~/.ssh/id_rsa.pub\n```\n\n在OSChina上点击你的头像–\\>设置–\\> SSH 公钥  \n标题自己随便取，然后这个公钥就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id\\_rsa.pub复制其内容），最后点击确定。\n最后还是测试一下吧，键入以下命令：  \n\n```bash\n$ ssh -T git@github.com\n```\n\n你可能会看到有警告，没事，输入“yes”就好。\n## 4.初始化hexo文件夹\n到OSChina的[https://gitee.com/ding-data/zhengdingblog.git][6]仓库下，点击克隆/下载,复制里面的HTTPS地址。  \n在E盘或是你喜爱的文件夹下，右键Git Bash Here（windows）或者终端 中在目标目录下: 键入git clone -b develop \\<刚复制的地址\\>  \n\n```bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n$ mkdir Hexo-admin\n```\n\n---- \n\n# Hexo安装配置\n## 1.Hexo初始化\n进入Hexo-admin文件夹  \n\n```bash\n$ cd Hexo-admin\n```\n\n接下来只需要使用 npm 即可完成 Hexo 的安装:  \n\n```bash\n$ npm install -g hexo-cli\n```\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:  \n\n```bash\n$ hexo init\n$ npm install\n```\n\n接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。  \n\n```bash\n$ hexo generate\n$ hexo server\n```\n\n输入Ctrl+C停止服务。\n## 2.Hexo配置\n用编辑器打开 Hexo-admin/ 下的配置文件config.yml找到：\n\n```bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\ntype: \nrepository:\n```\n\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。  \n\n```bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n type: git\n repository: https://github.com/chaooo/chaooo.github.io.git\n branch: master\n```\n\n## 3.完成部署\n最后一步，快要成功了，键入指令：  \n\n```bash\n$ npm install hexo-deployer-git --save\n$ hexo generate\n$ hexo deploy\n```\n\n输入弹出框的用户名与密码(首次使用git会弹出)。  \nOK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：[http://ding-data.gitee.io/zhengdingblog/][7]  \n每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：  \n\n```bash\nTo https://github.com/chaooo/chaooo.github.io.git\n7f3b50a..128a10d  HEAD -> master\nINFO  Deploy done: git\n```\n当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。\n\n---- \n\n# 日常操作\n## 1.写文章\n执行new命令，生成指定名称的文章至 Admin-blog\\source\\_posts\\文章标题.md 。  \n\n```bash\n$ hexo new [layout] \"文章标题\" #新建文章\n```\n\n然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。  \n其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，  \n同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md  \n\n```bash\ntitle: { { title } }\ndate: { { date } }\ntags:\n---\n```\n\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：  \n\n```bash\ntitle: { { title } }\ndate: { { date } }\ncategories:\ntags:\n---\n```\n\n文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。  \n请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件\"：\"后面都必须有个空格，不然会报错。\n## 2.提交\n每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。  \n\n```bash\n$ git add .\n$ git commit -m \"...\"\n$ git push origin develop\n```\n\n然后才执行hexo generate -d发布网站到master分支上。  \n\n```bash\n$ hexo generate -d\n```\n\n## 3.本地仓库丢失\n当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：\n### 3.1拷贝仓库\n\n```bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n```\n\n### 3.2配置Hexo\n在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:  \n\n```bash\n$ npm install -g hexo-cli\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git --save\n```\n\n---- \n\n# 小Tips:hexo 命令\n\n```bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\nhexo deploy -g  #生成加部署\nhexo server -g  #生成加预览\n#命令的简写\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n\n\n\n[1]:\thttps://hexo.io/zh-cn/\n[2]:\thttps://nodejs.org/en/\n[3]:\thttps://git-scm.com/\n[5]:\thttps://gitee.com/ding-data/zhengdingblog.git\n[6]:\thttps://gitee.com/ding-data/zhengdingblog.git\n[7]:\thttp://ding-data.gitee.io/zhengdingblog/","source":"_posts/手把手搭建Hexo+OSChina博客.md","raw":"---\ntitle: 手把手搭建Hexo+OSChina博客\ndate: 2017-11-17 16:03:58\ntags: \n- Hexo\n- OSChina\n- 博客\ncategories: 前端\n---\n\n# 开始之前\n在安装[hexo][1]之前，必须确认你已经安装了[Node.js][2]和[Git][3]。\n## 1.创建GitHub仓库\n注册[OSChina]()账号，创建一个以[https://gitee.com/ding-data/zhengdingblog.git][5]命名的仓库，其中zhengdingblog为仓库名，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。\n## 2.配置Git\n设置Git的用户名和邮件地址（邮箱就是你注册OSChina时候的邮箱），打开Git Bash(MAC打开终端即可)，键入：\n\n``` bash\n$ git config --global user.name \"username\"\n$ git config --global user.email \"email@example.com\"\n```\n\n## 3.本地Git与OSChina建立联系\n这里介绍SSH的配置，先检查电脑是否已经有SSH  \n\n``` bash\n$ ls -al ~/.ssh\n```\n\n如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。  \n输入以下指令后，一路回车就好：  \n\n``` bash\n$ ssh-keygen -t rsa -C \"emailt@example.com\"\n```\n\n然后键入以下指令：\n\n``` bash\n$ ssh-agent -s\n$ ssh-add ~/.ssh/id_rsa\n```\n\n如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：  \n\n``` bash\n$ ssh-agent bash\n```\n\n再重新输入指令：  \n\n```bash\n$ ssh-add ~/.ssh/id_rsa\n```\n\n到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：  \n\n```bash\n$ clip < ~/.ssh/id_rsa.pub\n```\n\n在OSChina上点击你的头像–\\>设置–\\> SSH 公钥  \n标题自己随便取，然后这个公钥就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id\\_rsa.pub复制其内容），最后点击确定。\n最后还是测试一下吧，键入以下命令：  \n\n```bash\n$ ssh -T git@github.com\n```\n\n你可能会看到有警告，没事，输入“yes”就好。\n## 4.初始化hexo文件夹\n到OSChina的[https://gitee.com/ding-data/zhengdingblog.git][6]仓库下，点击克隆/下载,复制里面的HTTPS地址。  \n在E盘或是你喜爱的文件夹下，右键Git Bash Here（windows）或者终端 中在目标目录下: 键入git clone -b develop \\<刚复制的地址\\>  \n\n```bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n$ mkdir Hexo-admin\n```\n\n---- \n\n# Hexo安装配置\n## 1.Hexo初始化\n进入Hexo-admin文件夹  \n\n```bash\n$ cd Hexo-admin\n```\n\n接下来只需要使用 npm 即可完成 Hexo 的安装:  \n\n```bash\n$ npm install -g hexo-cli\n```\n\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:  \n\n```bash\n$ hexo init\n$ npm install\n```\n\n接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。  \n\n```bash\n$ hexo generate\n$ hexo server\n```\n\n输入Ctrl+C停止服务。\n## 2.Hexo配置\n用编辑器打开 Hexo-admin/ 下的配置文件config.yml找到：\n\n```bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\ntype: \nrepository:\n```\n\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。  \n\n```bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n type: git\n repository: https://github.com/chaooo/chaooo.github.io.git\n branch: master\n```\n\n## 3.完成部署\n最后一步，快要成功了，键入指令：  \n\n```bash\n$ npm install hexo-deployer-git --save\n$ hexo generate\n$ hexo deploy\n```\n\n输入弹出框的用户名与密码(首次使用git会弹出)。  \nOK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：[http://ding-data.gitee.io/zhengdingblog/][7]  \n每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：  \n\n```bash\nTo https://github.com/chaooo/chaooo.github.io.git\n7f3b50a..128a10d  HEAD -> master\nINFO  Deploy done: git\n```\n当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。\n\n---- \n\n# 日常操作\n## 1.写文章\n执行new命令，生成指定名称的文章至 Admin-blog\\source\\_posts\\文章标题.md 。  \n\n```bash\n$ hexo new [layout] \"文章标题\" #新建文章\n```\n\n然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。  \n其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，  \n同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md  \n\n```bash\ntitle: { { title } }\ndate: { { date } }\ntags:\n---\n```\n\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：  \n\n```bash\ntitle: { { title } }\ndate: { { date } }\ncategories:\ntags:\n---\n```\n\n文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。  \n请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件\"：\"后面都必须有个空格，不然会报错。\n## 2.提交\n每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。  \n\n```bash\n$ git add .\n$ git commit -m \"...\"\n$ git push origin develop\n```\n\n然后才执行hexo generate -d发布网站到master分支上。  \n\n```bash\n$ hexo generate -d\n```\n\n## 3.本地仓库丢失\n当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：\n### 3.1拷贝仓库\n\n```bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n```\n\n### 3.2配置Hexo\n在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:  \n\n```bash\n$ npm install -g hexo-cli\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git --save\n```\n\n---- \n\n# 小Tips:hexo 命令\n\n```bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\nhexo deploy -g  #生成加部署\nhexo server -g  #生成加预览\n#命令的简写\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n\n\n\n[1]:\thttps://hexo.io/zh-cn/\n[2]:\thttps://nodejs.org/en/\n[3]:\thttps://git-scm.com/\n[5]:\thttps://gitee.com/ding-data/zhengdingblog.git\n[6]:\thttps://gitee.com/ding-data/zhengdingblog.git\n[7]:\thttp://ding-data.gitee.io/zhengdingblog/","slug":"手把手搭建Hexo+OSChina博客","published":1,"updated":"2017-11-30T03:37:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjz20018xqs6mrehnets","content":"<h1 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h1><p>在安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>之前，必须确认你已经安装了<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h2 id=\"1-创建GitHub仓库\"><a href=\"#1-创建GitHub仓库\" class=\"headerlink\" title=\"1.创建GitHub仓库\"></a>1.创建GitHub仓库</h2><p>注册<a href=\"\">OSChina</a>账号，创建一个以<a href=\"https://gitee.com/ding-data/zhengdingblog.git\" target=\"_blank\" rel=\"noopener\">https://gitee.com/ding-data/zhengdingblog.git</a>命名的仓库，其中zhengdingblog为仓库名，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>\n<h2 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2.配置Git\"></a>2.配置Git</h2><p>设置Git的用户名和邮件地址（邮箱就是你注册OSChina时候的邮箱），打开Git Bash(MAC打开终端即可)，键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-本地Git与OSChina建立联系\"><a href=\"#3-本地Git与OSChina建立联系\" class=\"headerlink\" title=\"3.本地Git与OSChina建立联系\"></a>3.本地Git与OSChina建立联系</h2><p>这里介绍SSH的配置，先检查电脑是否已经有SSH  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"emailt@example.com\"</span></span><br></pre></td></tr></table></figure>\n<p>然后键入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p>如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent bash</span><br></pre></td></tr></table></figure>\n<p>再重新输入指令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>在OSChina上点击你的头像–>设置–> SSH 公钥<br>标题自己随便取，然后这个公钥就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后点击确定。<br>最后还是测试一下吧，键入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>你可能会看到有警告，没事，输入“yes”就好。</p>\n<h2 id=\"4-初始化hexo文件夹\"><a href=\"#4-初始化hexo文件夹\" class=\"headerlink\" title=\"4.初始化hexo文件夹\"></a>4.初始化hexo文件夹</h2><p>到OSChina的<a href=\"https://gitee.com/ding-data/zhengdingblog.git\" target=\"_blank\" rel=\"noopener\">https://gitee.com/ding-data/zhengdingblog.git</a>仓库下，点击克隆/下载,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here（windows）或者终端 中在目标目录下: 键入git clone -b develop \\&lt;刚复制的地址>  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Hexo安装配置\"><a href=\"#Hexo安装配置\" class=\"headerlink\" title=\"Hexo安装配置\"></a>Hexo安装配置</h1><h2 id=\"1-Hexo初始化\"><a href=\"#1-Hexo初始化\" class=\"headerlink\" title=\"1.Hexo初始化\"></a>1.Hexo初始化</h2><p>进入Hexo-admin文件夹  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>\n<p>接下来只需要使用 npm 即可完成 Hexo 的安装:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>输入Ctrl+C停止服务。</p>\n<h2 id=\"2-Hexo配置\"><a href=\"#2-Hexo配置\" class=\"headerlink\" title=\"2.Hexo配置\"></a>2.Hexo配置</h2><p>用编辑器打开 Hexo-admin/ 下的配置文件config.yml找到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\"><span class=\"built_in\">type</span>: </span><br><span class=\"line\">repository:</span><br></pre></td></tr></table></figure>\n<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\"> <span class=\"built_in\">type</span>: git</span><br><span class=\"line\"> repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\"> branch: master</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-完成部署\"><a href=\"#3-完成部署\" class=\"headerlink\" title=\"3.完成部署\"></a>3.完成部署</h2><p>最后一步，快要成功了，键入指令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href=\"http://ding-data.gitee.io/zhengdingblog/\">http://ding-data.gitee.io/zhengdingblog/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">7f3b50a..128a10d  HEAD -&gt; master</span><br><span class=\"line\">INFO  Deploy <span class=\"keyword\">done</span>: git</span><br></pre></td></tr></table></figure>\n<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>\n<hr>\n<h1 id=\"日常操作\"><a href=\"#日常操作\" class=\"headerlink\" title=\"日常操作\"></a>日常操作</h1><h2 id=\"1-写文章\"><a href=\"#1-写文章\" class=\"headerlink\" title=\"1.写文章\"></a>1.写文章</h2><p>执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] <span class=\"string\">\"文章标题\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n<p>然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。<br>其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br>同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">categories:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件”：”后面都必须有个空格，不然会报错。</p>\n<h2 id=\"2-提交\"><a href=\"#2-提交\" class=\"headerlink\" title=\"2.提交\"></a>2.提交</h2><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">$ git push origin develop</span><br></pre></td></tr></table></figure>\n<p>然后才执行hexo generate -d发布网站到master分支上。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-本地仓库丢失\"><a href=\"#3-本地仓库丢失\" class=\"headerlink\" title=\"3.本地仓库丢失\"></a>3.本地仓库丢失</h2><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>\n<h3 id=\"3-1拷贝仓库\"><a href=\"#3-1拷贝仓库\" class=\"headerlink\" title=\"3.1拷贝仓库\"></a>3.1拷贝仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2配置Hexo\"><a href=\"#3-2配置Hexo\" class=\"headerlink\" title=\"3.2配置Hexo\"></a>3.2配置Hexo</h3><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"小Tips-hexo-命令\"><a href=\"#小Tips-hexo-命令\" class=\"headerlink\" title=\"小Tips:hexo 命令\"></a>小Tips:hexo 命令</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo deploy -g  <span class=\"comment\">#生成加部署</span></span><br><span class=\"line\">hexo server -g  <span class=\"comment\">#生成加预览</span></span><br><span class=\"line\"><span class=\"comment\">#命令的简写</span></span><br><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h1><p>在安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>之前，必须确认你已经安装了<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h2 id=\"1-创建GitHub仓库\"><a href=\"#1-创建GitHub仓库\" class=\"headerlink\" title=\"1.创建GitHub仓库\"></a>1.创建GitHub仓库</h2><p>注册<a href=\"\">OSChina</a>账号，创建一个以<a href=\"https://gitee.com/ding-data/zhengdingblog.git\" target=\"_blank\" rel=\"noopener\">https://gitee.com/ding-data/zhengdingblog.git</a>命名的仓库，其中zhengdingblog为仓库名，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>\n<h2 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2.配置Git\"></a>2.配置Git</h2><p>设置Git的用户名和邮件地址（邮箱就是你注册OSChina时候的邮箱），打开Git Bash(MAC打开终端即可)，键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-本地Git与OSChina建立联系\"><a href=\"#3-本地Git与OSChina建立联系\" class=\"headerlink\" title=\"3.本地Git与OSChina建立联系\"></a>3.本地Git与OSChina建立联系</h2><p>这里介绍SSH的配置，先检查电脑是否已经有SSH  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"emailt@example.com\"</span></span><br></pre></td></tr></table></figure>\n<p>然后键入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p>如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent bash</span><br></pre></td></tr></table></figure>\n<p>再重新输入指令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>在OSChina上点击你的头像–>设置–> SSH 公钥<br>标题自己随便取，然后这个公钥就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后点击确定。<br>最后还是测试一下吧，键入以下命令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>你可能会看到有警告，没事，输入“yes”就好。</p>\n<h2 id=\"4-初始化hexo文件夹\"><a href=\"#4-初始化hexo文件夹\" class=\"headerlink\" title=\"4.初始化hexo文件夹\"></a>4.初始化hexo文件夹</h2><p>到OSChina的<a href=\"https://gitee.com/ding-data/zhengdingblog.git\" target=\"_blank\" rel=\"noopener\">https://gitee.com/ding-data/zhengdingblog.git</a>仓库下，点击克隆/下载,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here（windows）或者终端 中在目标目录下: 键入git clone -b develop \\&lt;刚复制的地址>  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"Hexo安装配置\"><a href=\"#Hexo安装配置\" class=\"headerlink\" title=\"Hexo安装配置\"></a>Hexo安装配置</h1><h2 id=\"1-Hexo初始化\"><a href=\"#1-Hexo初始化\" class=\"headerlink\" title=\"1.Hexo初始化\"></a>1.Hexo初始化</h2><p>进入Hexo-admin文件夹  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>\n<p>接下来只需要使用 npm 即可完成 Hexo 的安装:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>输入Ctrl+C停止服务。</p>\n<h2 id=\"2-Hexo配置\"><a href=\"#2-Hexo配置\" class=\"headerlink\" title=\"2.Hexo配置\"></a>2.Hexo配置</h2><p>用编辑器打开 Hexo-admin/ 下的配置文件config.yml找到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\"><span class=\"built_in\">type</span>: </span><br><span class=\"line\">repository:</span><br></pre></td></tr></table></figure>\n<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\"> <span class=\"built_in\">type</span>: git</span><br><span class=\"line\"> repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\"> branch: master</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-完成部署\"><a href=\"#3-完成部署\" class=\"headerlink\" title=\"3.完成部署\"></a>3.完成部署</h2><p>最后一步，快要成功了，键入指令：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href=\"http://ding-data.gitee.io/zhengdingblog/\">http://ding-data.gitee.io/zhengdingblog/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">7f3b50a..128a10d  HEAD -&gt; master</span><br><span class=\"line\">INFO  Deploy <span class=\"keyword\">done</span>: git</span><br></pre></td></tr></table></figure>\n<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>\n<hr>\n<h1 id=\"日常操作\"><a href=\"#日常操作\" class=\"headerlink\" title=\"日常操作\"></a>日常操作</h1><h2 id=\"1-写文章\"><a href=\"#1-写文章\" class=\"headerlink\" title=\"1.写文章\"></a>1.写文章</h2><p>执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] <span class=\"string\">\"文章标题\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n<p>然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。<br>其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br>同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">categories:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件”：”后面都必须有个空格，不然会报错。</p>\n<h2 id=\"2-提交\"><a href=\"#2-提交\" class=\"headerlink\" title=\"2.提交\"></a>2.提交</h2><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">$ git push origin develop</span><br></pre></td></tr></table></figure>\n<p>然后才执行hexo generate -d发布网站到master分支上。  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-本地仓库丢失\"><a href=\"#3-本地仓库丢失\" class=\"headerlink\" title=\"3.本地仓库丢失\"></a>3.本地仓库丢失</h2><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>\n<h3 id=\"3-1拷贝仓库\"><a href=\"#3-1拷贝仓库\" class=\"headerlink\" title=\"3.1拷贝仓库\"></a>3.1拷贝仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2配置Hexo\"><a href=\"#3-2配置Hexo\" class=\"headerlink\" title=\"3.2配置Hexo\"></a>3.2配置Hexo</h3><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"小Tips-hexo-命令\"><a href=\"#小Tips-hexo-命令\" class=\"headerlink\" title=\"小Tips:hexo 命令\"></a>小Tips:hexo 命令</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo deploy -g  <span class=\"comment\">#生成加部署</span></span><br><span class=\"line\">hexo server -g  <span class=\"comment\">#生成加预览</span></span><br><span class=\"line\"><span class=\"comment\">#命令的简写</span></span><br><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>\n"},{"title":"解决 mac （windows）终端上代理的难题","data":"2017-12-12T06:07:01.000Z","_content":"\n买了 ss （shadowsocks）帐号，装了 ss 代理的软件，浏览器上也装了代理的插件，一直用的都挺好的，但是最近遇到了一些情况\n情况1：最近网络抽风，网页上访问 github 还好，但是在终端里，git clone 一个 repository，或者在 webstorm 中检出一个 github 上的repository，那是相当的痛苦\n情况2：同事在安装 brew 的过程中，需要下载 github 上的repository，于是遭受了和上面一样的痛苦\n不仅仅如此，为了解决类似的麻烦，很多人使用了 cnpm（淘宝出的代替 npm 的工具），或者更换各种包仓库的地址为国内镜像的地址，归根到底为一个原因，终端里的命令：诸如 wget，curl，git ，npm 等等，不好设置代理翻墙。\n经过本人的探索，找出了一条解决之道，先不说麻不麻烦，总归是解决了长久以来困扰自己的问题\n你所需要的，要有一个 ss 帐号，mac 上安装 shadowsocksX，已设置本地代理：socks5：127.0.0.1：1080\n还需要另外一个神器：proxifier\n举个例子，在终端里 git clone 一个repository，究竟是什么程序发起了网络请求，我现在可以直接告诉你答案，是 git-remote-https，请求 github.com:443，使用proxifier，就可以做到这一点，定位到是什么程序，请求的 host 以及 port，并且给它设置代理\n下面这张图就是proxifier的庐山真面目了\n![][image-1]\n上面的日志给出了详细的解释   \n当我在终端里敲下 npm install xxx，对应的就是 node 请求 registry.npmjs.org:443   \n当我在webstorm中设置 github 帐户的时候，对应的是 webstorm，请求 api.github.com:443   \n当我在 git clone repository的时候，对应的是git-remote-https 请求 github.com:443\n第一步：你得在shadowsocksX中开启 socks5 的本地代理，这是最重要的前提   \n第二步：在proxifier使用第一步设置的代理，如下图所示\n![][image-2]\n第三步：设置代理规则   \n![][image-3]\n解释一下我所设置的规则：   \n![][image-4]  \n规则匹配的顺序是从上往下的   \n1. 生效的第一条规则是shadowsocksX，因为我们的代理就是靠这个程序的，所以不能让它自己代理自己，否则proxifier 会报无限循环，动作选 direct   \n2. 规则 github，这里也并没有指定程序git-remote-https，因为 像 webstorm等 GUI 之流，也会访问 github：443的请求，所以不指定程序，只限制 主机和端口，应用范围就不限于终端了   \n3. 规则 node，解决 npm install 的代理，可以不用 cnpm 了   \n4. 规则 brew，解决终端下使用 brew 安装 package 的代理   \n5. 规则 google-analytics，，解决终端下使用 brew 安装 package 的代理   \n6. 规则 default，不能删除，当匹配不到任何规则的时候，使用该规则\n任何一个连接请求，从上往下匹配，匹配到了，就会停止   \n以上就是我摸索出来的方法，如果 ss 速度快的话，相信我，你会开心死的\n一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦，   \n也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理\nps：shadowsocks和proxifier windows 下也有，按照道理，windows 下也可用，我自己未测试过\n\n\n\n[image-1]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4oengilkbc1djbb48m7e1hbnm.png\n[image-2]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4ofiiia5821397ea0phm6rn13.png\n[image-3]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4og01u91alg1ggk1mh51omdurr1g.png\n[image-4]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4og4c2k2i6j8b1jdjd03has1t.png","source":"_posts/解决 mac （windows）终端上代理的难题.md","raw":"---\ntitle: 解决 mac （windows）终端上代理的难题\ndata:  2017-12-12 14:07:01\ntag:\n-  ShadowSocks\ncategories: 干货\n---\n\n买了 ss （shadowsocks）帐号，装了 ss 代理的软件，浏览器上也装了代理的插件，一直用的都挺好的，但是最近遇到了一些情况\n情况1：最近网络抽风，网页上访问 github 还好，但是在终端里，git clone 一个 repository，或者在 webstorm 中检出一个 github 上的repository，那是相当的痛苦\n情况2：同事在安装 brew 的过程中，需要下载 github 上的repository，于是遭受了和上面一样的痛苦\n不仅仅如此，为了解决类似的麻烦，很多人使用了 cnpm（淘宝出的代替 npm 的工具），或者更换各种包仓库的地址为国内镜像的地址，归根到底为一个原因，终端里的命令：诸如 wget，curl，git ，npm 等等，不好设置代理翻墙。\n经过本人的探索，找出了一条解决之道，先不说麻不麻烦，总归是解决了长久以来困扰自己的问题\n你所需要的，要有一个 ss 帐号，mac 上安装 shadowsocksX，已设置本地代理：socks5：127.0.0.1：1080\n还需要另外一个神器：proxifier\n举个例子，在终端里 git clone 一个repository，究竟是什么程序发起了网络请求，我现在可以直接告诉你答案，是 git-remote-https，请求 github.com:443，使用proxifier，就可以做到这一点，定位到是什么程序，请求的 host 以及 port，并且给它设置代理\n下面这张图就是proxifier的庐山真面目了\n![][image-1]\n上面的日志给出了详细的解释   \n当我在终端里敲下 npm install xxx，对应的就是 node 请求 registry.npmjs.org:443   \n当我在webstorm中设置 github 帐户的时候，对应的是 webstorm，请求 api.github.com:443   \n当我在 git clone repository的时候，对应的是git-remote-https 请求 github.com:443\n第一步：你得在shadowsocksX中开启 socks5 的本地代理，这是最重要的前提   \n第二步：在proxifier使用第一步设置的代理，如下图所示\n![][image-2]\n第三步：设置代理规则   \n![][image-3]\n解释一下我所设置的规则：   \n![][image-4]  \n规则匹配的顺序是从上往下的   \n1. 生效的第一条规则是shadowsocksX，因为我们的代理就是靠这个程序的，所以不能让它自己代理自己，否则proxifier 会报无限循环，动作选 direct   \n2. 规则 github，这里也并没有指定程序git-remote-https，因为 像 webstorm等 GUI 之流，也会访问 github：443的请求，所以不指定程序，只限制 主机和端口，应用范围就不限于终端了   \n3. 规则 node，解决 npm install 的代理，可以不用 cnpm 了   \n4. 规则 brew，解决终端下使用 brew 安装 package 的代理   \n5. 规则 google-analytics，，解决终端下使用 brew 安装 package 的代理   \n6. 规则 default，不能删除，当匹配不到任何规则的时候，使用该规则\n任何一个连接请求，从上往下匹配，匹配到了，就会停止   \n以上就是我摸索出来的方法，如果 ss 速度快的话，相信我，你会开心死的\n一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦，   \n也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理\nps：shadowsocks和proxifier windows 下也有，按照道理，windows 下也可用，我自己未测试过\n\n\n\n[image-1]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4oengilkbc1djbb48m7e1hbnm.png\n[image-2]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4ofiiia5821397ea0phm6rn13.png\n[image-3]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4og01u91alg1ggk1mh51omdurr1g.png\n[image-4]:\thttp://p09eeagrw.bkt.clouddn.com/image_1b4og4c2k2i6j8b1jdjd03has1t.png","slug":"解决 mac （windows）终端上代理的难题","published":1,"date":"2017-12-12T06:06:16.000Z","updated":"2017-12-12T06:50:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbfukjz7001bxqs6n6rlehfb","content":"<p>买了 ss （shadowsocks）帐号，装了 ss 代理的软件，浏览器上也装了代理的插件，一直用的都挺好的，但是最近遇到了一些情况<br>情况1：最近网络抽风，网页上访问 github 还好，但是在终端里，git clone 一个 repository，或者在 webstorm 中检出一个 github 上的repository，那是相当的痛苦<br>情况2：同事在安装 brew 的过程中，需要下载 github 上的repository，于是遭受了和上面一样的痛苦<br>不仅仅如此，为了解决类似的麻烦，很多人使用了 cnpm（淘宝出的代替 npm 的工具），或者更换各种包仓库的地址为国内镜像的地址，归根到底为一个原因，终端里的命令：诸如 wget，curl，git ，npm 等等，不好设置代理翻墙。<br>经过本人的探索，找出了一条解决之道，先不说麻不麻烦，总归是解决了长久以来困扰自己的问题<br>你所需要的，要有一个 ss 帐号，mac 上安装 shadowsocksX，已设置本地代理：socks5：127.0.0.1：1080<br>还需要另外一个神器：proxifier<br>举个例子，在终端里 git clone 一个repository，究竟是什么程序发起了网络请求，我现在可以直接告诉你答案，是 git-remote-https，请求 github.com:443，使用proxifier，就可以做到这一点，定位到是什么程序，请求的 host 以及 port，并且给它设置代理<br>下面这张图就是proxifier的庐山真面目了<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4oengilkbc1djbb48m7e1hbnm.png\" alt=\"\"><br>上面的日志给出了详细的解释<br>当我在终端里敲下 npm install xxx，对应的就是 node 请求 registry.npmjs.org:443<br>当我在webstorm中设置 github 帐户的时候，对应的是 webstorm，请求 api.github.com:443<br>当我在 git clone repository的时候，对应的是git-remote-https 请求 github.com:443<br>第一步：你得在shadowsocksX中开启 socks5 的本地代理，这是最重要的前提<br>第二步：在proxifier使用第一步设置的代理，如下图所示<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4ofiiia5821397ea0phm6rn13.png\" alt=\"\"><br>第三步：设置代理规则<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4og01u91alg1ggk1mh51omdurr1g.png\" alt=\"\"><br>解释一下我所设置的规则：<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4og4c2k2i6j8b1jdjd03has1t.png\" alt=\"\"><br>规则匹配的顺序是从上往下的   </p>\n<ol>\n<li>生效的第一条规则是shadowsocksX，因为我们的代理就是靠这个程序的，所以不能让它自己代理自己，否则proxifier 会报无限循环，动作选 direct   </li>\n<li>规则 github，这里也并没有指定程序git-remote-https，因为 像 webstorm等 GUI 之流，也会访问 github：443的请求，所以不指定程序，只限制 主机和端口，应用范围就不限于终端了   </li>\n<li>规则 node，解决 npm install 的代理，可以不用 cnpm 了   </li>\n<li>规则 brew，解决终端下使用 brew 安装 package 的代理   </li>\n<li>规则 google-analytics，，解决终端下使用 brew 安装 package 的代理   </li>\n<li>规则 default，不能删除，当匹配不到任何规则的时候，使用该规则<br>任何一个连接请求，从上往下匹配，匹配到了，就会停止<br>以上就是我摸索出来的方法，如果 ss 速度快的话，相信我，你会开心死的<br>一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦，<br>也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理<br>ps：shadowsocks和proxifier windows 下也有，按照道理，windows 下也可用，我自己未测试过</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>买了 ss （shadowsocks）帐号，装了 ss 代理的软件，浏览器上也装了代理的插件，一直用的都挺好的，但是最近遇到了一些情况<br>情况1：最近网络抽风，网页上访问 github 还好，但是在终端里，git clone 一个 repository，或者在 webstorm 中检出一个 github 上的repository，那是相当的痛苦<br>情况2：同事在安装 brew 的过程中，需要下载 github 上的repository，于是遭受了和上面一样的痛苦<br>不仅仅如此，为了解决类似的麻烦，很多人使用了 cnpm（淘宝出的代替 npm 的工具），或者更换各种包仓库的地址为国内镜像的地址，归根到底为一个原因，终端里的命令：诸如 wget，curl，git ，npm 等等，不好设置代理翻墙。<br>经过本人的探索，找出了一条解决之道，先不说麻不麻烦，总归是解决了长久以来困扰自己的问题<br>你所需要的，要有一个 ss 帐号，mac 上安装 shadowsocksX，已设置本地代理：socks5：127.0.0.1：1080<br>还需要另外一个神器：proxifier<br>举个例子，在终端里 git clone 一个repository，究竟是什么程序发起了网络请求，我现在可以直接告诉你答案，是 git-remote-https，请求 github.com:443，使用proxifier，就可以做到这一点，定位到是什么程序，请求的 host 以及 port，并且给它设置代理<br>下面这张图就是proxifier的庐山真面目了<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4oengilkbc1djbb48m7e1hbnm.png\" alt=\"\"><br>上面的日志给出了详细的解释<br>当我在终端里敲下 npm install xxx，对应的就是 node 请求 registry.npmjs.org:443<br>当我在webstorm中设置 github 帐户的时候，对应的是 webstorm，请求 api.github.com:443<br>当我在 git clone repository的时候，对应的是git-remote-https 请求 github.com:443<br>第一步：你得在shadowsocksX中开启 socks5 的本地代理，这是最重要的前提<br>第二步：在proxifier使用第一步设置的代理，如下图所示<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4ofiiia5821397ea0phm6rn13.png\" alt=\"\"><br>第三步：设置代理规则<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4og01u91alg1ggk1mh51omdurr1g.png\" alt=\"\"><br>解释一下我所设置的规则：<br><img src=\"http://p09eeagrw.bkt.clouddn.com/image_1b4og4c2k2i6j8b1jdjd03has1t.png\" alt=\"\"><br>规则匹配的顺序是从上往下的   </p>\n<ol>\n<li>生效的第一条规则是shadowsocksX，因为我们的代理就是靠这个程序的，所以不能让它自己代理自己，否则proxifier 会报无限循环，动作选 direct   </li>\n<li>规则 github，这里也并没有指定程序git-remote-https，因为 像 webstorm等 GUI 之流，也会访问 github：443的请求，所以不指定程序，只限制 主机和端口，应用范围就不限于终端了   </li>\n<li>规则 node，解决 npm install 的代理，可以不用 cnpm 了   </li>\n<li>规则 brew，解决终端下使用 brew 安装 package 的代理   </li>\n<li>规则 google-analytics，，解决终端下使用 brew 安装 package 的代理   </li>\n<li>规则 default，不能删除，当匹配不到任何规则的时候，使用该规则<br>任何一个连接请求，从上往下匹配，匹配到了，就会停止<br>以上就是我摸索出来的方法，如果 ss 速度快的话，相信我，你会开心死的<br>一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦，<br>也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理<br>ps：shadowsocks和proxifier windows 下也有，按照道理，windows 下也可用，我自己未测试过</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjbfukjw20001xqs6zhdbu3ed","category_id":"cjbfukjwn0004xqs6jc8u3o2p","_id":"cjbfukjxu000exqs6g38ukmk5"},{"post_id":"cjbfukjwi0003xqs61ssjcb3y","category_id":"cjbfukjxj000axqs6jhxsfjrc","_id":"cjbfukjy4000jxqs6qqhnfm8a"},{"post_id":"cjbfukjwy0007xqs622jixcnp","category_id":"cjbfukjxu000fxqs6gaaxsndl","_id":"cjbfukjye000oxqs6scijkqgq"},{"post_id":"cjbfukjy1000ixqs6nzffymgn","category_id":"cjbfukjxu000fxqs6gaaxsndl","_id":"cjbfukjyi000sxqs6ygdw92jp"},{"post_id":"cjbfukjxd0008xqs6emzejmio","category_id":"cjbfukjy4000kxqs6r1mq6fsc","_id":"cjbfukjyn000wxqs6r1771tej"},{"post_id":"cjbfukjxh0009xqs66haioy6p","category_id":"cjbfukjye000pxqs60oog87lm","_id":"cjbfukjz00015xqs6drajfw06"},{"post_id":"cjbfukjyn000xxqs60jkl3q90","category_id":"cjbfukjxu000fxqs6gaaxsndl","_id":"cjbfukjz50019xqs6m6wxl75z"},{"post_id":"cjbfukjys0011xqs65sg2zqj7","category_id":"cjbfukjxj000axqs6jhxsfjrc","_id":"cjbfukjzb001dxqs6twt2cq59"},{"post_id":"cjbfukjxl000cxqs6byv10yhw","category_id":"cjbfukjye000pxqs60oog87lm","_id":"cjbfukjzd001fxqs65jjw2edf"},{"post_id":"cjbfukjyw0013xqs6v9tmi50x","category_id":"cjbfukjwn0004xqs6jc8u3o2p","_id":"cjbfukjzf001gxqs6h212dacl"},{"post_id":"cjbfukjz20018xqs6mrehnets","category_id":"cjbfukjye000pxqs60oog87lm","_id":"cjbfukjzg001jxqs637qq1jtj"},{"post_id":"cjbfukjxr000dxqs6w68yjs56","category_id":"cjbfukjye000pxqs60oog87lm","_id":"cjbfukjzg001lxqs6dbgc5vt0"},{"post_id":"cjbfukjxv000hxqs60fmwg607","category_id":"cjbfukjzb001cxqs65r8h1tz5","_id":"cjbfukjzi001oxqs6vnakpr1k"},{"post_id":"cjbfukjy5000mxqs6im9brr8f","category_id":"cjbfukjzf001hxqs6wrz5pygs","_id":"cjbfukjzl001sxqs62eu47imk"},{"post_id":"cjbfukjy8000nxqs6h65gsbyz","category_id":"cjbfukjye000pxqs60oog87lm","_id":"cjbfukjzn001vxqs6xbuuf5cj"},{"post_id":"cjbfukjyf000rxqs6wse3k1lc","category_id":"cjbfukjye000pxqs60oog87lm","_id":"cjbfukjzp001zxqs659p90ynf"},{"post_id":"cjbfukjyj000uxqs6pc20dkbb","category_id":"cjbfukjzf001hxqs6wrz5pygs","_id":"cjbfukjzs0022xqs6fp0um6sg"},{"post_id":"cjbfukjz7001bxqs6n6rlehfb","category_id":"cjbfukjzf001hxqs6wrz5pygs","_id":"cjbfukjzt0024xqs68cnkt3u1"}],"PostTag":[{"post_id":"cjbfukjw20001xqs6zhdbu3ed","tag_id":"cjbfukjwv0005xqs6def27g6u","_id":"cjbfukjyj000txqs6z7ot3psv"},{"post_id":"cjbfukjw20001xqs6zhdbu3ed","tag_id":"cjbfukjxk000bxqs6b15x9tj0","_id":"cjbfukjym000vxqs6mrar5oza"},{"post_id":"cjbfukjw20001xqs6zhdbu3ed","tag_id":"cjbfukjxu000gxqs6it9oe268","_id":"cjbfukjys0010xqs6f6stzdsu"},{"post_id":"cjbfukjw20001xqs6zhdbu3ed","tag_id":"cjbfukjy4000lxqs6u9usyqym","_id":"cjbfukjyv0012xqs69hr9jvkg"},{"post_id":"cjbfukjwi0003xqs61ssjcb3y","tag_id":"cjbfukjyf000qxqs65w0xkx0x","_id":"cjbfukjz20017xqs6g2lystk5"},{"post_id":"cjbfukjwy0007xqs622jixcnp","tag_id":"cjbfukjyp000zxqs65m9t3gb6","_id":"cjbfukjz6001axqs6645lr3tz"},{"post_id":"cjbfukjxd0008xqs6emzejmio","tag_id":"cjbfukjz10016xqs6u1henvrx","_id":"cjbfukjzg001kxqs6egrjwys2"},{"post_id":"cjbfukjxd0008xqs6emzejmio","tag_id":"cjbfukjzc001exqs6u8vnj69k","_id":"cjbfukjzh001nxqs6pmfn181l"},{"post_id":"cjbfukjxh0009xqs66haioy6p","tag_id":"cjbfukjzf001ixqs6kw5s8fho","_id":"cjbfukjzk001qxqs6l462jwh2"},{"post_id":"cjbfukjxl000cxqs6byv10yhw","tag_id":"cjbfukjzi001pxqs64m2dcfuq","_id":"cjbfukjzp001xxqs6ilu8yhqr"},{"post_id":"cjbfukjxl000cxqs6byv10yhw","tag_id":"cjbfukjzl001txqs6zangcwyt","_id":"cjbfukjzr0020xqs61kbe9g7x"},{"post_id":"cjbfukjxr000dxqs6w68yjs56","tag_id":"cjbfukjzo001wxqs64lj2u3zr","_id":"cjbfukjzt0025xqs6cwj1p2nc"},{"post_id":"cjbfukjxr000dxqs6w68yjs56","tag_id":"cjbfukjzf001ixqs6kw5s8fho","_id":"cjbfukjzt0026xqs6rlx1iq1x"},{"post_id":"cjbfukjxv000hxqs60fmwg607","tag_id":"cjbfukjzt0023xqs6vnfesuiz","_id":"cjbfukjzu0029xqs6gopr4x50"},{"post_id":"cjbfukjxv000hxqs60fmwg607","tag_id":"cjbfukjzt0027xqs6je6g41jj","_id":"cjbfukjzv002axqs6ca93gexm"},{"post_id":"cjbfukjy1000ixqs6nzffymgn","tag_id":"cjbfukjyp000zxqs65m9t3gb6","_id":"cjbfukjzv002cxqs63shp333b"},{"post_id":"cjbfukjy5000mxqs6im9brr8f","tag_id":"cjbfukjzv002bxqs63xihushh","_id":"cjbfukjzw002exqs6xr6rnm0h"},{"post_id":"cjbfukjy8000nxqs6h65gsbyz","tag_id":"cjbfukjzv002dxqs6csk376ca","_id":"cjbfukjzx002hxqs6xr6qsxvr"},{"post_id":"cjbfukjy8000nxqs6h65gsbyz","tag_id":"cjbfukjzw002fxqs6kfk84a04","_id":"cjbfukjzy002ixqs6qqhze1xt"},{"post_id":"cjbfukjyf000rxqs6wse3k1lc","tag_id":"cjbfukjzx002gxqs6hfhxqjpi","_id":"cjbfukjzy002kxqs6ax91op7m"},{"post_id":"cjbfukjyj000uxqs6pc20dkbb","tag_id":"cjbfukjzy002jxqs6rri80o39","_id":"cjbfukjzz002mxqs68j8ff7ml"},{"post_id":"cjbfukjyn000xxqs60jkl3q90","tag_id":"cjbfukjyp000zxqs65m9t3gb6","_id":"cjbfukjzz002oxqs6j8wvystc"},{"post_id":"cjbfukjys0011xqs65sg2zqj7","tag_id":"cjbfukjyf000qxqs65w0xkx0x","_id":"cjbfukk00002qxqs6qwld2r8j"},{"post_id":"cjbfukjys0011xqs65sg2zqj7","tag_id":"cjbfukjzz002nxqs6kr8pnc1d","_id":"cjbfukk00002rxqs6qjv0r1pp"},{"post_id":"cjbfukjyw0013xqs6v9tmi50x","tag_id":"cjbfukjzz002pxqs6aks8mgk3","_id":"cjbfukk00002txqs6birrhhin"},{"post_id":"cjbfukjz20018xqs6mrehnets","tag_id":"cjbfukk00002sxqs6d2a9qme8","_id":"cjbfukk02002xxqs6snrmybg4"},{"post_id":"cjbfukjz20018xqs6mrehnets","tag_id":"cjbfukk01002uxqs6url4ttzo","_id":"cjbfukk02002yxqs6taup812p"},{"post_id":"cjbfukjz20018xqs6mrehnets","tag_id":"cjbfukk01002vxqs6iake51c4","_id":"cjbfukk02002zxqs6ldu71tvr"},{"post_id":"cjbfukjz7001bxqs6n6rlehfb","tag_id":"cjbfukjzz002pxqs6aks8mgk3","_id":"cjbfukk020030xqs6kotszcd2"}],"Tag":[{"name":"防火墙","_id":"cjbfukjwv0005xqs6def27g6u"},{"name":"iptables","_id":"cjbfukjxk000bxqs6b15x9tj0"},{"name":"firewall","_id":"cjbfukjxu000gxqs6it9oe268"},{"name":"SELINUX","_id":"cjbfukjy4000lxqs6u9usyqym"},{"name":"Docker","_id":"cjbfukjyf000qxqs65w0xkx0x"},{"name":"Git","_id":"cjbfukjyp000zxqs65m9t3gb6"},{"name":"Mac","_id":"cjbfukjz10016xqs6u1henvrx"},{"name":"PHP7","_id":"cjbfukjzc001exqs6u8vnj69k"},{"name":"React","_id":"cjbfukjzf001ixqs6kw5s8fho"},{"name":"全文搜索","_id":"cjbfukjzi001pxqs64m2dcfuq"},{"name":"Elasticsearch","_id":"cjbfukjzl001txqs6zangcwyt"},{"name":"componentWillReceiveProps","_id":"cjbfukjzo001wxqs64lj2u3zr"},{"name":"filter","_id":"cjbfukjzt0023xqs6vnfesuiz"},{"name":"跨域","_id":"cjbfukjzt0027xqs6je6g41jj"},{"name":"git","_id":"cjbfukjzv002bxqs63xihushh"},{"name":"NPM","_id":"cjbfukjzv002dxqs6csk376ca"},{"name":"nrm","_id":"cjbfukjzw002fxqs6kfk84a04"},{"name":"node-sass","_id":"cjbfukjzx002gxqs6hfhxqjpi"},{"name":"travis","_id":"cjbfukjzy002jxqs6rri80o39"},{"name":"Dockerfile","_id":"cjbfukjzz002nxqs6kr8pnc1d"},{"name":"ShadowSocks","_id":"cjbfukjzz002pxqs6aks8mgk3"},{"name":"Hexo","_id":"cjbfukk00002sxqs6d2a9qme8"},{"name":"OSChina","_id":"cjbfukk01002uxqs6url4ttzo"},{"name":"博客","_id":"cjbfukk01002vxqs6iake51c4"}]}}