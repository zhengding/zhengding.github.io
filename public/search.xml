<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React新的生命周期]]></title>
    <url>%2F2019%2F04%2F24%2FReact%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[组件生命周期的三个阶段 Mounting（加载阶段） Updating（更新阶段） Unmounting（卸载阶段） 旧的生命周期 Mounting（加载阶段：涉及6个钩子函数）constructor() 1加载的时候调用一次，可以初始化state getDefaultProps() 1设置默认的props，也可以用dufaultProps设置组件的默认属性。 getInitialState() 1初始化state，可以直接在constructor中定义this.state componentWillMount() 1组件加载时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state render() 1react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 componentDidMount() 1组件渲染之后调用，只调用一次 Updating（更新阶段：涉及5个钩子函数)componentWillReceivePorps(nextProps) 1组件加载时不调用，组件接受新的props时调用 shouldComponentUpdate(nextProps, nextState) 1组件接收到新的props或者state时调用，return true就会更新dom（使用diff算法更新），return false能阻止更新（不调用render） componentWillUpdata(nextProps, nextState) 1组件加载时不调用，只有在组件将要更新时才调用，此时可以修改state render() 1react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 componentDidUpdate() 1组件加载时不调用，组件更新完成后调用 Unmounting（卸载阶段：涉及1个钩子函数）componentWillUnmount() 1组件渲染之后调用，只调用一次 组件的基本写法1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react'export default class OldReactComponent extends Component &#123; constructor(props) &#123; super(props) // getDefaultProps：接收初始props // getInitialState：初始化state &#125; state = &#123; &#125; componentWillMount() &#123; // 组件挂载前触发 &#125; render() &#123; return ( &lt;h2&gt;Old React.Component&lt;/h2&gt; ) &#125; componentDidMount() &#123; // 组件挂载后触发 &#125; componentWillReceivePorps(nextProps) &#123; // 接收到新的props时触发 &#125; shouldComponentUpdate(nextProps, nextState) &#123; // 组件Props或者state改变时触发，true：更新，false：不更新 return true &#125; componentWillUpdate(nextProps, nextState) &#123; // 组件更新前触发 &#125; componentDidUpdate() &#123; // 组件更新后触发 &#125; componentWillUnmount() &#123; // 组件卸载时触发 &#125;&#125; 新的生命周期Mounting（加载阶段：涉及4个钩子函数）constructor() 1加载的时候调用一次，可以初始化state static getDerivedStateFromProps(props, state) 1组件每次被rerender的时候，包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state；配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法 render() 1react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 componentDidMount() 1组件渲染之后调用，只调用一次 Updating（更新阶段：涉及5个钩子函数)static getDerivedStateFromProps(props, state) 1组件每次被rerender的时候，包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state；配合componentDidUpdate，可以覆盖componentWillReceiveProps的所有用法 shouldComponentUpdate(nextProps, nextState) 1组件接收到新的props或者state时调用，return true就会更新dom（使用diff算法更新），return false能阻止更新（不调用render） render() 1react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行 getSnapshotBeforeUpdate(prevProps, prevState) 1触发时间: update发生的时候，在render之后，在组件dom渲染之前；返回一个值，作为componentDidUpdate的第三个参数；配合componentDidUpdate, 可以覆盖componentWillUpdate的所有用法 componentDidUpdate() 1组件加载时不调用，组件更新完成后调用 Unmounting（卸载阶段：涉及1个钩子函数）1组件渲染之后调用，只调用一次 Error Handling(错误处理)componentDidCatch(error，info) 1任何一处的javascript报错会触发 组件的基本写法1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react'export default class NewReactComponent extends Component &#123; constructor(props) &#123; super(props) // getDefaultProps：接收初始props // getInitialState：初始化state &#125; state = &#123; &#125; static getDerivedStateFromProps(props, state) &#123; // 组件每次被rerender的时候，包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新的props或state之后；;每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state return state &#125; componentDidCatch(error, info) &#123; // 获取到javascript错误 &#125; render() &#123; return ( &lt;h2&gt;New React.Component&lt;/h2&gt; ) &#125; componentDidMount() &#123; // 挂载后 &#125; shouldComponentUpdate(nextProps, nextState) &#123; // 组件Props或者state改变时触发，true：更新，false：不更新 return true &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 组件更新前触发 &#125; componentDidUpdate() &#123; // 组件更新后触发 &#125; componentWillUnmount() &#123; // 组件卸载时触发 &#125;&#125; 总结旧的生命周期新的生命周期 React16新的生命周期弃用了componentWillMount、componentWillReceivePorps，componentWillUpdate 新增了getDerivedStateFromProps、getSnapshotBeforeUpdate来代替弃用的三个钩子函数（componentWillMount、componentWillReceivePorps，componentWillUpdate） React16并没有删除这三个钩子函数，但是不能和新增的钩子函数（getDerivedStateFromProps、getSnapshotBeforeUpdate）混用，React17将会删除componentWillMount、componentWillReceivePorps，componentWillUpdate 新增了对错误的处理（componentDidCatch）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sessionStorage可共享情况和localStorage]]></title>
    <url>%2F2019%2F04%2F19%2FsessionStorage%E5%8F%AF%E5%85%B1%E4%BA%AB%E6%83%85%E5%86%B5%E5%92%8ClocalStorage%2F</url>
    <content type="text"><![CDATA[1、不同浏览器无法共享localStorage和sessionStorage的值。 2、相同浏览器下，并且是同源窗口（协议、域名、端口一致），不同页面可以共享localStorage值，通过跳转的页面可以共享sessionStorage值。 3、关于sessionStorage，通常说sessionStorage关闭页面即消失，但是通过跳转的页面可以共享sessionStorage值，跳转有多种方式： ​ (1) 12// 原窗口&lt;a href="同源页面" target="_self"&gt;跳转&lt;/a&gt; ​ (2) 12// 新开窗口&lt;a href="同源页面" target="_blank"&gt;跳转&lt;/a&gt; ​ (3) window.location.href = ‘同源页面’ //原窗口 ​ (4) window.location.replace(‘同源页面’) //原窗口 ​ (5) window.open(‘同源页面’) //新开窗口 ​ (6) this.$router.push({path: ‘同源页面’}) //通过路由跳转共享值 app端通过原生方法更换webView实现跳转，这种方式不能共享sessionStorage，原窗口跳转的页面传递sessionStorage，改变存储值会相互影响，新开窗口跳转方式传递sessionStorage，改变存储值互不影响。]]></content>
      <tags>
        <tag>sessionStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始搭建K8S--搭建K8S Dashboard]]></title>
    <url>%2F2019%2F04%2F10%2F%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAK8S-%E6%90%AD%E5%BB%BAK8S-Dashboard%2F</url>
    <content type="text"><![CDATA[一、K8S Dashboard简介简单的说，K8S Dashboard是官方的一个基于WEB的用户界面，专门用来管理K8S集群，并可展示集群的状态。K8S集群安装好后默认没有包含Dashboard，我们需要额外创建它。 Dashboard的搭建过程中，会遇到一些坑。现在开始，咱们一步一步踩来，走你! 二、RABC简介还是那句话，官方文档是最重要的参考资料：https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/该文档中，创建kubernetes-dashboard的命令为：kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml当然，直接这样创建的dashboard会有很多问题，参见： Please note, this works only if the apiserver is set up to allow authentication with username and password. This is not currently the case with some setup tools (e.g., kubeadm). Refer to the authentication admin documentation for information on how to configure authentication manually. 因为我们使用kubeadm搭建的集群会默认开启RABC（角色访问控制机制），所以我们必须要进行额外的设置。关于RABC的概念，网上资料很多，大家务必提前了解。这里简要介绍一下几个重要概念： RBACK8S 1.6引进，是让用户能够访问 k8S API 资源的授权方式【不授权就没有资格访问K8S的资源】用户K8S有两种用户：User和Service Account。其中，User给人用，Service Account给进程用，让进程有相关权限。如Dashboard就是一个进程，我们就可以创建一个Service Account给它角色Role是一系列权限的集合，例如一个Role可包含读取和列出 Pod的权限【 ClusterRole 和 Role 类似，其权限范围是整个集群】角色绑定RoleBinding把角色映射到用户，从而让这些用户拥有该角色的权限【ClusterRoleBinding 和RoleBinding 类似，可让用户拥有 ClusterRole 的权限】SecretSecret是一个包含少量敏感信息如密码，令牌，或秘钥的对象。把这些信息保存在 Secret对象中，可以在这些信息被使用时加以控制，并可以降低信息泄露的风险如下图，灰色是“角色”，蓝色是“用户”，绿色是“角色绑定”，黄色是该角色拥有的权限。简言之 ，角色绑定将角色和用户进行挂钩： 三、官方kubernetes-dashboard.yaml简介很有必要介绍一下官方的kubernetes-dashboard.yaml，我们首先将其下载下来：wget https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml 该文件分为以下几部分： Dashboard ServiceDashboard DeploymentDashboard RoleRoleBindingDashboard Service AccountDashboard Secret这里，我们简单的对各个部分的功能进行介绍： Dashboard Role123456789101112131415161718192021222324252627282930313233kind: RoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: kubernetes-dashboard-minimal namespace: kube-systemrules: # Allow Dashboard to create 'kubernetes-dashboard-key-holder' secret.- apiGroups: [""] resources: ["secrets"] verbs: ["create"] # Allow Dashboard to create 'kubernetes-dashboard-settings' config map.- apiGroups: [""] resources: ["configmaps"] verbs: ["create"] # Allow Dashboard to get, update and delete Dashboard exclusive secrets.- apiGroups: [""] resources: ["secrets"] resourceNames: ["kubernetes-dashboard-key-holder", "kubernetes-dashboard-certs"] verbs: ["get", "update", "delete"] # Allow Dashboard to get and update 'kubernetes-dashboard-settings' config map.- apiGroups: [""] resources: ["configmaps"] resourceNames: ["kubernetes-dashboard-settings"] verbs: ["get", "update"] # Allow Dashboard to get metrics from heapster.- apiGroups: [""] resources: ["services"] resourceNames: ["heapster"] verbs: ["proxy"]- apiGroups: [""] resources: ["services/proxy"] resourceNames: ["heapster", "http:heapster:", "https:heapster:"] verbs: ["get"] 如上定义了Dashboard 的角色，其角色名称为kubernetes-dashboard-minimal，rules中清晰的列出了其拥有的多个权限。通过名称我们可以猜到，这个权限级别是比较低的。 123456kind: ServiceAccountmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-system 如上定义了Dashboard的用户，其类型为ServiceAccount，名称为kubernetes-dashboard。 RoleBinding123456789101112kind: RoleBindingmetadata: name: kubernetes-dashboard-minimal namespace: kube-systemroleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: kubernetes-dashboard-minimalsubjects:- kind: ServiceAccount name: kubernetes-dashboard namespace: kube-system 如上定义了Dashboard的角色绑定，其名称为kubernetes-dashboard-minimal，roleRef中为被绑定的角色，也叫kubernetes-dashboard-minimal，subjects中为绑定的用户：kubernetes-dashboard。 Dashboard Secret1234567kind: Secretmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard-certs namespace: kube-systemtype: Opaque Dashboard Deployment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354kind: DeploymentapiVersion: apps/v1beta2metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemspec: replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s-app: kubernetes-dashboard template: metadata: labels: k8s-app: kubernetes-dashboard spec: containers: - name: kubernetes-dashboard image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3 ports: - containerPort: 8443 protocol: TCP args: - --auto-generate-certificates # Uncomment the following line to manually specify Kubernetes API server Host # If not specified, Dashboard will attempt to auto discover the API server and connect # to it. Uncomment only if the default does not work. # - --apiserver-host=http://my-address:port volumeMounts: - name: kubernetes-dashboard-certs mountPath: /certs # Create on-disk volume to store exec logs - mountPath: /tmp name: tmp-volume livenessProbe: httpGet: scheme: HTTPS path: / port: 8443 initialDelaySeconds: 30 timeoutSeconds: 30 volumes: - name: kubernetes-dashboard-certs secret: secretName: kubernetes-dashboard-certs - name: tmp-volume emptyDir: &#123;&#125; serviceAccountName: kubernetes-dashboard # Comment the following tolerations if Dashboard must not be deployed on master tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule 如上可以看到，Dashboard的Deployment指定了其使用的ServiceAccount是kubernetes-dashboard。并且还将Secret kubernetes-dashboard-certs通过volumes挂在到pod内部的/certs路径。为何要挂载Secret ？原因是创建Secret 时会自动生成token。请注意参数–auto-generate-certificates，其表示Dashboard会自动生成证书。 四、安装Dashboard1.导入镜像如果直接使用官方的kubernetes-dashboard.yaml创建Dashboard，你会踩到很多坑，首先是镜像拉取会超时失败。截止目前，Dashboard的最新版本是1.8.3，我已经将镜像k8s.gcr.io#kubernetes-dashboard-amd64.tar导出，提供给大家：链接：https://pan.baidu.com/s/11AheivJxFzc4X6Q5_qCw8A 密码：2zov 在所有节点上（因为你不知道K8S会将Dashboard的pod调度到哪个节点），使用如下命令导入镜像：docker load &lt; k8s.gcr.io#kubernetes-dashboard-amd64.tar 导入成功后，执行docker images可以看到Dashboard的版本是1.8.3： 2.创建Dashboard导入镜像后，使用之前下载的yaml文件即可创建Dashboard：kubectl create -f kubernetes-dashboard.yaml 3.访问Dashboard根据官方文档，目前访问Dashboard有四种方式： NodePortAPI Serverkubectl proxyIngress以上四种方式，我测试了前三种，目前只有NodePort和kubectl proxy可用，API Server暂时没有解决。 使用NodePort为kubernetes-dashboard.yaml添加Service后，就可以使用NodePort访问Dashboard。在我们的物理机上，使用Chrome访问https://192.168.56.101:32159/，结果如下图所示： 如上可以看到，这里提示了证书错误NET::ERR_CERT_INVALID，原因是由于物理机的浏览器证书不可用。但是，不要放弃，我们这里不打算使用物理机访问浏览器，而使用Dashboard所在节点上的浏览器来访问（即CentOS自带的浏览器），这样的证书应该是可行的（官方默认就是这种方式）。 由于之前建立虚拟机环境时，我们关闭了CentOS的图形界面，这里我们为了访问Dashboard临时开启，执行：systemctl set-default graphical.target。重启后，即可进入图形界面。我们用Firefox访问：https://192.168.56.101:32159/，成功后出现如下界面： 需要注意的是，若提示“连接不安全”的警告时，点击“高级”，点击“添加例外”后即可： 使用API Server在我们的物理机上，使用Chrome访问地址：https://192.168.56.101:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/，返回如下错误： { “kind”: “Status”, “apiVersion”: “v1”, “metadata”: { }, “status”: “Failure”, “message”: “services “https:kubernetes-dashboard:” is forbidden: User “system:anonymous” cannot get services/proxy in the namespace “kube-system””, “reason”: “Forbidden”, “details”: { “name”: “https:kubernetes-dashboard:”, “kind”: “services” }, “code”: 403} 原因是由于kube-apiserver使用了TLS认证，而我们的真实物理机上的浏览器使用匿名证书（因为没有可用的证书）去访问Dashboard，导致授权失败而不无法访问。官方提供的解决方法是将kubelet的证书转化为浏览器可用的证书，然后导入进浏览器。 Note: This way of accessing Dashboard is only possible if you choose to install your user certificates in the browser. In example certificates used by kubeconfig file to contact API Server can be used. 但是该方法目前似乎不适用于kubeadm方式安装的集群，参见：https://github.com/opsnull/follow-me-install-kubernetes-cluster/issues/5 那如果使用节点自带的Firefox呢？我们在Firefox中访问：https://192.168.56.101:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/，仍然提示上面的错误： 看来，无论物理机还是K8S节点上的浏览器，都需要导入这个证书，暂时无解。 使用kubectl proxy这里，我主要介绍一下最便捷的kubectl proxy方式。在Master上执行kubecll proxy，然后使用如下地址访问Dashboard：http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy但限制就是必须在Master上访问，这显然是个坑，我们的目标是在我们真实的物理机上去访问Master的Dashboard。 所以，在主节点上，我们执行kubectl proxy –address=192.168.56.101 –disable-filter=true开启代理。其中： address表示外界可以使用192.168.56.101来访问Dashboard，我们也可以使用0.0.0.0disable-filter=true表示禁用请求过滤功能，否则我们的请求会被拒绝，并提示 Forbidden (403) Unauthorized。我们也可以指定端口，具体请查看kubectl proxy –help如下图所示，proxy默认对Master的8001端口进行监听： 这样，我们就可以使用如下地址访问登录界面：http://192.168.56.101:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login 4.配置DashboardDashboard的配置是难点，尤其是涉及到安全权限相关，相当复杂，坑也比较多。 进入Dashboard的登录界面后，认证方式有Kubeconfig和令牌两种方式（实际上还有账号密码的方式，默认不开启不显示）。看到Kubeconfig和令牌，估计头都大了。是否有简便的方法，让我们能直接访问Dashboard？当然有，选择跳过，会出现如下页面： 如上图，很遗憾，我们看到了很多权限错误提示，主要是system:serviceaccount:kube-system:kubernetes-dashboard的权限不足引起的。 我们回想本文第三小节对kubernetes-dashboard.yaml的介绍，现在就理解了为什么其角色的名称为kubernetes-dashboard-minimal。一句话，这个Role的权限不够！ 因此，我们可以更改RoleBinding修改为ClusterRoleBinding，并且修改roleRef中的kind和name，使用cluster-admin这个非常牛逼的CusterRole（超级用户权限，其拥有访问kube-apiserver的所有权限）。如下： 123456789101112apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: kubernetes-dashboard-minimal namespace: kube-systemroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: kubernetes-dashboard 修改后，重新创建kubernetes-dashboard.yaml，Dashboard就可以拥有访问整个K8S 集群API的权限。我们重新访问Dashboard，如下图所示： 如上，一切正常，请在界面上尽情的乱点吧。另外，如果有兴趣，你还可以安装Dashboard的Heapster插件，这里就不再介绍了。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant design pro 页面加载原理及过程，@connect 装饰器]]></title>
    <url>%2F2019%2F04%2F02%2Fant%20design%20pro%20%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%8F%8A%E8%BF%87%E7%A8%8B%EF%BC%8C%40connect%20%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、概述 以列表页中的标准列表为主 Ant Design Pro 默认通过只需浏览器单方面就可处理的 HashHistory 来完成路由。如果要切换为 BrowserHistory，那在 src/index.js 中也有对应的内容可以直接修改，但需要在后端服务器进行相应路由配置。 二、详述 加载过程图 2.1、菜单→路由→组件 在左侧的导航栏点击 列表页 &gt; 标准列表 后，可以进入到上面截图所示的页面。导航栏的内容在 src/common/menu.js 中【或者服务获取的地址】 菜单：12345678910111213141516&#123; name: '列表页', icon: 'table', path: 'list', children: [ &#123; name: '查询表格', path: 'table-list', &#125;, &#123; name: '标准列表', path: 'basic-list', &#125;, //…… ], &#125;, 路由 全局的路由关系是：src/index.js 中通过 app.router(require(&#39;./router&#39;).default);，将 src/router.js 绑定到 dva 实例的 router 方法上。而在 src/router.js 中又引入了 src/common/router.js 中的 getRouterData 作为数据源。 其实就是相当于：src/common/menu.js 中 path 所指向的路径对应于 src/common/router.js 中的路由记录。 12345678910export const getRouterData = (app) =&gt; &#123; const routerConfig = &#123; ..., '/list/basic-list': &#123; component: dynamicWrapper(app, ['list'], () =&gt; import('../routes/List/BasicList')), &#125;, ..., &#125;; ...&#125; 这里调用了同文件内的 lazy-loading 的动态加载函数 dynamicWrapper，有 3 个参数，app 为全局 dva 实例，models 为一个带有相关 dva Model 的 Array，component 即为该路由记录对应的实际组件。 1const dynamicWrapper = (app, models, component) =&gt; &#123;...&#125;; 可以看到： 1、加载路由的时候,会动态加载当前文件下的model文件,也就是对应文件下的src/models/list.js 组件： src/routes/List/BasicList.js，具体组件。已省略部分代码 123456789101112131415161718192021222324import React, &#123; PureComponent &#125; from 'react';import &#123; connect &#125; from 'dva';//……import PageHeaderLayout from '../../layouts/PageHeaderLayout';@connect((&#123; list, loading &#125;) =&gt; (&#123; list, loading: loading.models.list,&#125;))export default class BasicList extends PureComponent &#123; componentDidMount() &#123; this.props.dispatch(&#123; type: 'list/fetch', payload: &#123; count: 5, &#125;, &#125;); &#125; render() &#123; return ( &lt;PageHeaderLayout&gt;&#123;/* 页面内容…… */&#125;&lt;/PageHeaderLayout&gt; ); &#125;&#125; 2.2、@connect 装饰器 组件写法中调用了 dva 所封装的 react-redux 的 @connect 装饰器，用来接收绑定的 list 这个 model 对应的 redux store。注意到这里的装饰器实际除了 app.state.list 以外还实际接收 app.state.loading 作为参数，这个 loading 的来源是 src/index.js 中调用的 dva-loading这个插件。 12345/** src/index.js*/import createLoading from 'dva-loading';app.use(createLoading()); 它返回的信息包含了 global、model 和 effect 的异步加载完成情况。 数据map一 12345678910111213&#123; "global": true, "models": &#123; "list": false, "user": true, "rule": false &#125;, "effects": &#123; "list/fetch": false, "user/fetchCurrent": true, "rule/fetch": false &#125;&#125; 注意到在这里带上 {count: 5} 这个 payload 向 store 进行了一个类型为 list/fetch 的 dispatch，在 src/models/list.js 中就可以找到具体的对应操作。 1234567891011121314151617181920212223242526import &#123; queryFakeList &#125; from '../services/api';export default &#123; namespace: 'list', state: &#123; list: [], &#125;, effects: &#123; *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123; const response = yield call(queryFakeList, payload); yield put(&#123; type: 'queryList', payload: Array.isArray(response) ? response : [], &#125;); &#125;, /* ... */ &#125;, reducers: &#123; queryList(state, action) &#123; return &#123; ...state, list: action.payload, &#125;; &#125;, /* ... */ &#125;,&#125;; View中使用 1、connect使用 1234@connect((&#123; list, loading &#125;) =&gt; (&#123; list,//① loading: loading.models.list,//②&#125;)) 说明： 1、connect 有两个参数,mapStateToProps以及mapDispatchToProps,一个将状态绑定到组件的props一个将方法绑定到组件的props 2、代码①：将实体list中的state数据绑定到props，注意绑定的是实体list整体，使用时需要list.[state中的具体变量] 3、代码②：通过loading将上文“数据map一”中的models的list的key对应的value读取出来。赋值给loading，以方便使用，如表格是否有加载图标 当然代码②也可以通过key value编写：loading.effects[“list/fetch”] 2、变量获取 因，在src/models/list.js 12345export default &#123; namespace: 'list', state: &#123; list: [], &#125;, 故在view中使用 12render() &#123; const &#123; list: &#123; list &#125;, loading &#125; = this.props; 说明： 定义使用时：list: { list } ，含义实体list下的state类型的list变量]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>connect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React渲染机制解析]]></title>
    <url>%2F2019%2F04%2F01%2FReact%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在介绍React渲染机制之间先来说一说下面几个概念，对于新入手React的学员来说，经常会被搞蒙圈。 React与ReactDOM区别 在v0.14前,ReactDOM是React的函数，之所以在v0.14之后分成两个包是package是因为 ​ As we look at packages like react-native, react-art, react-canvas, and react-three, it has become clear that the beauty and essence of React has nothing to do with browsers or the DOM.​ To make this more clear and to make it easier to build more environments that React can render to, we’re splitting the main react package into two: react and react-dom. This paves the way to writing components that can be shared between the web version of React and React Native. We don’t expect all the code in an app to be shared, but we want to be able to share the components that do behave the same across platforms. ​ 可见，React分为react-dom和react的原因是React-Native的出现，它可以实现跨平台实现相同的组件。​ react包包含了React.createElement、 .createClass、 .Component、 .PropTypes、.Children以及其他的描述元素和组件的类。​ react-dom包包含了ReactDOM.render、.unmountComponentAtNode和.findDOMNode等。下面看一个创建组件的实例： 12345678var React = require('react');var ReactDOM = require('react-dom');var MyComponent = React.createClass(&#123;render: function() &#123;return &lt;div&gt;Hello World&lt;/div&gt;;&#125;&#125;);ReactDOM.render(&lt;MyComponent /&gt;, node); ​ ReactDOM.render是React的最基本方法用于将模板转为HTML语言，并插入指定的DOM节点。它可以将一个React元素呈现在指定的DOM container中，并返回对组件的引用对象。 ​ Component、Element和Component ​ Component​ Component组件就是JavaScript函数，可以接受任意参数。可以使用createClass和Component创建组件。createClass如其名就是创建React组件对应的类，描述你将要创建组件的各种行为，其中只有当组件被渲染时需要输出的内容的render接口是必须实现的，其他都是可选： 12345var SayHello = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;); 从 React 0.13 开始，可以使用 ES6 Class代替 React.createClass了 12345class SayHello extends React.Component &#123;render() &#123;return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/a&gt; &lt;/div&gt;;&#125;&#125; 注意：（1）为了区分Component和DOM 元素，所有Component名字要首字母大写。 （2）所有的React组件都不能修改它的prop属性的值 Element Element是class的一个实例，它描述DOM节点或component实例的字面级对象。它包含一些信息，包括组件类型type和属性props。就像一个描述DOM节点的元素(虚拟节点)。可以使用createElement，创建React组件实例 123ReactElement.createElement= function(type, config, children) &#123;...&#125; 在上一篇文章中我们已经讲到，当我们用JSX来描述&lt; SayHello /&gt;时 ，编译后就是React.createElement()。 Factory React.createFactory和ReactElement.createElement一样，但是 Factory返回的是给定元素类型或组件类的实例。React.createFactory的定义基本就是如下形式，Element 的类型被提前绑定了 12345ReactElement.createFactory = function (type) &#123;var factory = ReactElement.createElement.bind(null, type); factory.type = type; return factory;&#125;; 官方鼓励使用JSX或者React.creatElement。下面进入今天的主题：React的渲染机制 React渲染机制 假设要实现的渲染代码如下： 12345678910111213141516171819 class Form extends React.Component &#123; constructor() &#123; super(); &#125; render() &#123; return ( &lt;form&gt; &lt;input type="text"/&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render( ( &lt;div className="test"&gt; &lt;p&gt;请输入你的信息&lt;/p&gt; &lt;Form/&gt; &lt;/div&gt;), document.getElementById('example')) ​ 从ReactDOM入口开始，找到ReactDOM.js文件 1234567891011121314151617181920212223var ReactDOMComponentTree = require('./ReactDOMComponentTree');var ReactDefaultInjection = require('./ReactDefaultInjection');var ReactMount = require('./ReactMount');var ReactReconciler = require('./ReactReconciler');var ReactUpdates = require('./ReactUpdates');var ReactVersion = require('./ReactVersion');var findDOMNode = require('./findDOMNode');var getHostComponentFromComposite = require('./getHostComponentFromComposite');var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');var warning = require('fbjs/lib/warning');ReactDefaultInjection.inject(); var ReactDOM = &#123; findDOMNode: findDOMNode, render: ReactMount.render, unmountComponentAtNode: ReactMount.unmountComponentAtNode, version: ReactVersion, /* eslint-disable camelcase */ unstable_batchedUpdates: ReactUpdates.batchedUpdates, unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer /* eslint-enable camelcase */&#125;; ​ ReactDOM.render()方法来自ReactMount文件的render方法： 123render: function (nextElement, container, callback) &#123; return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback); &#125;, ​ Render方法返回的是当前文件下的_renderSubtreeIntoContainer方法，顾名思义，它的作用是将子树nextElement注入到指定的container中，并调用其回调方法_renderSubtreeIntoContainer方法主要完成以下一个功能： 调用React.createElement生成待插入节点的虚拟DOM的实例对象（上篇文章中已经讲到，这里就不再重复叙述） 与之前的component比较，如果是初次渲染直接将虚拟DOM转换为真实DOM 将真实的组件写到对应的container节点中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253_renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) &#123;/**将callback放入到React的更新队列中，判断nextElement有效性以及当前是发开环境还是生产环境。（代码省略）*/…var nextWrappedElement = React.createElement(TopLevelWrapper, &#123;child: nextElement&#125;);// 返回一个ReactElement实例对象，也就是虚拟DOM的实例对象，下面就要把它渲染出来var nextContext;/*（1）判断是否有parentComponent，如果有则将其写到parentComponent*/if (parentComponent) &#123;var parentInst = ReactInstanceMap.get(parentComponent);nextContext = parentInst._processChildContext(parentInst._context);&#125; else &#123;nextContext = emptyObject;&#125;var prevComponent =getTopLevelWrapperInContainer(container); /**（2）判断是否有prevComponent，如果有则取其child，利用Diff算法判断是否需要更新，如果需要则调用_updateRootComponen 方法，并return结果。对于初次渲染不需要该过程。 */if (prevComponent) &#123;var prevWrappedElement = prevComponent._currentElement;var prevElement = prevWrappedElement.props.child; // shouldUpdateReactComponent方法判断是否需要更新,对同一DOM进行比较，type相同，key(如果有)相同的组件做DOM diff if (shouldUpdateReactComponent(prevElement, nextElement)) &#123;var publicInst = prevComponent._renderedComponent.getPublicInstance();var updatedCallback = callback &amp;&amp; function () &#123;callback.call(publicInst);&#125;;ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);return publicInst;&#125; else &#123;ReactMount.unmountComponentAtNode(container);&#125;&#125;/**（3）对于prevElement为null直接跳到此步var reactRootElement = getReactRootElementInContainer(container);var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement);var containerHasNonRootReactChild = hasNonRootReactChild(container);var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild;/**3核心部分，调用_renderNewRootComponent，_renderedComponent，getPublicInstance三个方法，*/var component =ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();if (callback) &#123;callback.call(component);&#125;return component;&#125; 下面来看一看ＲenderNewRootComponent方法的源码 （1）_renderNewRootComponent： 12345678910111213141516_renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) &#123;… … /**第一部分是调用instantiateReactComponen方法返回虚拟DOM对应的DOM，并将其返回结果作为_renderNewRootComponent的最终返回结果 */var componentInstance = &lt;a name="OLE_LINK14"&gt;&lt;/a&gt; &lt;a name="OLE_LINK13"&gt;instantiateReactComponent&lt;/a&gt; (nextElement, false);return componentInstance; /**第二部分是处理batchedMountComponentIntoNode方法，并将上面的结果componentInstance 结果插入到DOM中*/*ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);var wrapperID = componentInstance._instance.rootID;instancesByReactRootID[wrapperID] = componentInstance;return componentInstance;&#125; 解析第一部分：将虚拟DOM生成DOM 再来看一看instantiateReactComponent方法，它是从instantiateReactComponent文件require进来的，输入参数是虚拟DOM节点，主要实现的功能是将虚拟DOM生成DOM。根element的类型不同，分别实例化ReactDOMTextComponent, ReactDOMComponent, ReactCompositeComponent类。 下面来看一看instantiateReactComponent.js源码的伪代码 123456789101112131415function instantiateReactComponent(node, shouldHaveDebugID) &#123;var instance;/**判断node类型，不同的类型调用不同的渲染方法*//*节点为空*/instance = ReactEmptyComponent.create(instantiateReactComponent); /*如果节点是宿主内置节点，譬如浏览器的 的节点*/instance = ReactHostComponent.createInternalComponent(element);instance = new ReactCompositeComponentWrapper(element);/*如果节点是字符串或数字*/instance = ReactHostComponent.createInstanceForText(node);return instance;&#125; 解析第二部分：将新的component分批插入到DOM中 batchedUpdates是ReactUpdates的一个方法，使用batchingStrategy更新DOM 1234function batchedUpdates(callback, a, b, c, d, e) &#123;ensureInjected();return batchingStrategy .batchedUpdates(callback, a, b, c, d, e);&#125; ​ batchedUpdates 方法的回调函数是batchedMountComponentIntoNode方法 1234567function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) &#123;var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(/* useCreateElement */!shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement);transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);ReactUpdates.ReactReconcileTransaction.release(transaction);&#125; batchedMountComponentIntoNode 方法通过 transaction.perform调用mountComponentIntoNode方法。 12345678910111213141516171819202122232425/** Mounts this component and inserts it into the DOM.* @param &#123;ReactComponent&#125; componentInstance The instance to mount.* @param &#123;DOMElement&#125; container DOM element to mount into.* @param &#123;ReactReconcileTransaction&#125; transaction* @param &#123;boolean&#125; shouldReuseMarkup If true, do not insert markup*/function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) &#123;var markerName;if (ReactFeatureFlags.logTopLevelRenders) &#123;var wrappedElement = wrapperInstance._currentElement.props.child;var type = wrappedElement.type;markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);console.time(markerName);&#125; **//*调用对应ReactReconciler中的mountComponent方法来渲染组件,返回React组件解析后的HTML** var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */);if (markerName) &#123;console.timeEnd(markerName);&#125;wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance; /*将解析出来的HTML插入DOM中 ReactMount._mountImageIntoNode&lt;/a&gt; (markup, container, wrapperInstance, shouldReuseMarkup, transaction);&#125; _mountImageIntoNode 可以实现将HTML插入DOM中的操作方法是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152_mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) &#123;/*是否复用markupif (shouldReuseMarkup) &#123;/*如果可以复用，直接将instance插入到根元素** var rootElement = getReactRootElementInContainer(container);if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) &#123;ReactDOMComponentTree.precacheNode(instance, rootElement);return;&#125; else &#123;/*创建新的normalizedMarkupvar checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);var rootMarkup = rootElement.outerHTML;rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);var normalizedMarkup = markup;if (process.env.NODE_ENV !== 'production') &#123;var normalizer;if (container.nodeType === ELEMENT_NODE_TYPE) &#123;normalizer = document.createElement('div');normalizer.innerHTML = markup;normalizedMarkup = normalizer.innerHTML;&#125; else &#123;normalizer = document.createElement('iframe');document.body.appendChild(normalizer);normalizer.contentDocument.write(markup);normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;document.body.removeChild(normalizer);&#125;&#125;if (transaction.while (container.lastChild) &#123;container.removeChild(container.lastChild);&#125;DOMLazyTree.insertTreeBefore(container, markup, null);&#125; else &#123;/*利用innerHTML将markup插入到container这个DOM元素上** setInnerHTML(container, markup); /*将instance保存到container的原生节点firstChild上*/ReactDOMComponentTree.precacheNode(instance, container.firstChild);&#125;if (process.env.NODE_ENV !== 'production') &#123;var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);if (hostNode._debugID !== 0) &#123;ReactInstrumentation.debugTool.onHostOperation(&#123;instanceID: hostNode._debugID,type: 'mount',payload: markup.toString()&#125;);&#125;&#125;&#125;&#125;; 这么多的内容有点懵懵的，下面我们通过简单的流程图总结：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客图片问题]]></title>
    <url>%2F2019%2F04%2F01%2Fhexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[开始用hexo搭建博客，开始的时候觉得还不错。用着用着感觉图片是一个问题。最开始的时候用七牛来存储图片。 图片似乎有了解决方案。某次写博客的时候觉得图片多了真是太麻烦了。每次要把图片先上传到七牛的服务器然后再使用。这使我一度出于放弃的边缘，差点用回博客园或者CSND。后面试着搜索了下本地方式引用。发现了CodeFalling/hexo-asset-image的插件来加载本地图片。使用方法 1.首先确认_config.yml 中有 post_asset_folder:true。 Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder 当您设置post_asset_folder为true参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.在hexo的目录下执行 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save （需要等待一段时间）。 3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。 生成的结构为 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 1&lt;img src="/2016/3/9/本地图片测试/logo.jpg" alt="logo"&gt; 而不是愚蠢的 1&lt;img src="本地图片测试/logo.jpg" alt="logo"&gt; 注意: 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo3的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 [](/example.jpg)，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是markdown]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fitech-Gitlab启动流程]]></title>
    <url>%2F2019%2F04%2F01%2FFitech-Gitlab%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>Fitech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora功能新发现-自动复制图片到指定目录下]]></title>
    <url>%2F2019%2F03%2F29%2FTypora%E5%8A%9F%E8%83%BD%E6%96%B0%E5%8F%91%E7%8E%B0-%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[Typora一款小巧, 清新, 简洁易用的Markdown文件编辑器. 个人较为喜欢. 但是之前一直有个”缺陷”让我不满意. 即插入图片不是很方便: 粘贴粘贴板里的图片, 会在当前光标下生成图片引用路径(赞), but, 只是图片的绝对路径, 这意味着, 当你想将辛苦书写的Markdown文件和别人分享交流时, 图片就是很大问题, 所以这样操作根本就没有用处. Typora是什么? Typora — a markdown editor, markdown reader.官网暂时打不开, 找到别人介绍她的文章链接, 可以大概了解下. 安利一下Typora：极致简洁的markdown编辑器 新发现了什么功能?读过上文, 就知道, 这款软件让我最大不满意的地方就是, 图片引用的问题.今天以为get到了她的新功能. 听我慢慢道来. 通过配置可以使得, 粘贴图片至光标处时, 做了两件伟大的事情: 将复制的图片copy一份至md文档当前路径下的media文件夹里; 光标出自动生成图片的引用路径, 且是相对路径, 如./media/xxx.png 配置 打开复制图片功能 md文件下建立media文件夹, 并指定它为复制图片的存储路径 效果 按下 1ctrl+/ 可进入 源码模式 查看: 后话以后如何方便的使用这个功能?注意: 单个md文件的配置只是针对它自己有效, 重新新建的文件, 复制图片的路径配置失效. 所以为了方便, 有两种思路: 提前准备md文件模板: 123| root | Note_index.md | media/ 配置好模板md图片复制的路径为media. 记住头文件配置: 123---typora-copy-images-to: media--- 为什么用media文件夹?这是因为笔者想和另一款word+Markdown插件Writage无缝对接. 该插件使得word能够编辑md文件, 复制粘贴图片会在当前md文件的media路径下保存此图片. 即实现使用word(带Writage插件)编辑和使用Typora编辑效果一样.]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说 tabindex 的那些事儿]]></title>
    <url>%2F2019%2F03%2F29%2F%E8%AF%B4%E8%AF%B4%20tabindex%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[tabindex 属性用于管理键盘焦点，决定元素是否能被选中，以及按下 tab 键过程中被选中的顺序，使用得当能够极大的提高应用的易用性，然而，不恰当地使用时可以键盘用户对应用的可用性。到底如何使用？设置为 0 会有什么效果？设置为 -1 会有什么效果？本文将为你揭晓。 ​ 要理解为什么 tabindex 属性对可用性有如此大的影响，有必要知道一些键盘交互的方式。键盘用户通常会使用 tab 键将光标从一个可获取焦点的元素有序地移动到下一个元素。 ​ 像链接和 form 表单元素默认都是可获取焦点的，他们的默认焦点顺序取决于他们在源代码中出现的顺序。 1234567&lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Log in&quot;&gt; ​ 按下 tab 键时将依次选中用户名输入框、密码输入框和登录按钮，这三个元素默认就是可获取焦点的，并且焦点顺序与其在源码中的顺序一致。也就是说，对此并不需要显示设置 tabindex属性，浏览器将有效地处理它们。 tabindex=0​ 当 tabindex 设置为 0 时，元素的 tab 键序与其在源码中的顺序一致。默认情况下，如果元素本身是可获取焦点的就没有必要设置 tabindex 属性。但，如果你想让一个不能获取焦点的元素，比如 &lt;span&gt; 或 &lt;div&gt;，也被包含在 tab 键序列表中，那么设置 tabindex = 0 就可以使这些元素按其在源码中的顺序出现在 tab 键序中。 值得一提的是，那些可获取焦点的元素使用起来比较方便，例如，当你使用 &lt;button&gt; 或 &lt;input type=&quot;checkbox&quot;&gt;，键盘焦点和交互由浏览器自动处理。当你使用其他元素来构建自定义组件时，你需要人为地提供键盘焦点和交互支持。 tabindex=-1​ 当 tabindex 被设置为像 -1 一样的负数时，该元素就变成可由代码获取焦点，但其本身并不在 tab 键序列表中。也就是说，在按下 tab 键时，该元素不能获取到焦点，但是可以通过代码来获取到焦点。 ​ 请看下面例子，表单返回错误汇总信息时，将通过代码使其获取到焦点，并将其放置在表单的顶部，这样屏幕阅读器或屏幕放大器用户就能得到提示，以便他们能够纠正错误，同时对于键盘用户，这个元素并不会出现在 tab 键序中。 123456&lt;div role=&quot;group&quot; id=&quot;errorSummary&quot; aria-labelledby=&quot;errorSummaryHeading&quot; tabindex=&quot;-1&quot;&gt; &lt;h2 id=&quot;errorSummaryHeading&quot;&gt;Your information contains three errors&lt;/h2&gt; &lt;ul&gt; ... &lt;/ul&gt;&lt;/div&gt; tabindex=1+​ 当 tabindex 设置为一个正数时，情况就复杂了。它可以使一个元素不按页面顺序来获取焦点。 1234567&lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot; tabindex=&quot;3&quot;&gt;&lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; tabindex=&quot;1&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Log in&quot; tabindex=&quot;2&quot;&gt; ​ 在上面例子中，视觉预期的 tab 顺序是：用户名输入框，密码输入框，最后是登陆按钮。然而，这里设置的 tabindex 属性，将使其变得不可预期，焦点移动顺序分别是：密码输入框，登陆按钮，最后才是用户名输入框。 ​ 当你意识到密码输入框是表单中第一个能获取到焦点的元素时，事情也许已经变糟。不管在密码输入框之前有多少个可获取焦点的元素，tabindex=1 就意味着它将是页面上第一个可获得焦点的元素，而与视觉样式和源码顺序无关。 总结tabindex 属性很常用，它可以改善或破坏键盘用户对页面的可用性。使用该属性时，请谨记： tabindex=0 可以使一个元素按自然顺序出现在 tab 键序中，同时，尽量使用默认可获取焦点的元素。 tabindex=-1 可以使一个元素可由代码获取到焦点，但其本身并不在 tab 键序中。 避免设置 tabindex=1+。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ShadowSocks]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%90%AD%E5%BB%BAShadowSocks%2F</url>
    <content type="text"><![CDATA[VPS安装ShadowSocks推荐看秋水逸冰的《Shadowsocks 一键安装脚本（四合一）》的安装教程。运行以下命令: 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 选择脚本（Python、R、Go、libev），任选一个： 123456Which Shadowsocks server you'd select:1.Shadowsocks-Python2.ShadowsocksR3.Shadowsocks-Go4.Shadowsocks-libevPlease enter a number (default 1): 笔者选择Shadowsocks-Go，输入3……然后，输入密码和端口，笔者直接回车用默认： 1234567891011121314You choose = Shadowsocks-GoPlease enter password for Shadowsocks-Go(default password: teddysun.com):password = teddysun.comPlease enter a port for Shadowsocks-Go [1-65535](default port: 8989):port = 8989Press any key to start...or Press Ctrl+C to cancel 安装成功后，命令行出现： 12345678Congratulations, Shadowsocks-Go server install completed!Your Server IP : 45.32.73.59Your Server Port : 8989Your Password : teddysun.comYour Encryption Method: aes-256-cfbWelcome to visit: https://teddysun.com/486.htmlEnjoy it! （如果安装失败，请尝试其他脚本）]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决mac（windows）终端上代理的难题]]></title>
    <url>%2F2019%2F03%2F29%2F%E8%A7%A3%E5%86%B3%20mac%20%EF%BC%88windows%EF%BC%89%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BB%A3%E7%90%86%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[买了 ss （shadowsocks）帐号，装了 ss 代理的软件，浏览器上也装了代理的插件，一直用的都挺好的，但是最近遇到了一些情况情况1：最近网络抽风，网页上访问 github 还好，但是在终端里，git clone 一个 repository，或者在 webstorm 中检出一个 github 上的repository，那是相当的痛苦情况2：同事在安装 brew 的过程中，需要下载 github 上的repository，于是遭受了和上面一样的痛苦不仅仅如此，为了解决类似的麻烦，很多人使用了 cnpm（淘宝出的代替 npm 的工具），或者更换各种包仓库的地址为国内镜像的地址，归根到底为一个原因，终端里的命令：诸如 wget，curl，git ，npm 等等，不好设置代理翻墙。经过本人的探索，找出了一条解决之道，先不说麻不麻烦，总归是解决了长久以来困扰自己的问题你所需要的，要有一个 ss 帐号，mac 上安装 shadowsocksX，已设置本地代理：socks5：127.0.0.1：1080还需要另外一个神器：proxifier举个例子，在终端里 git clone 一个repository，究竟是什么程序发起了网络请求，我现在可以直接告诉你答案，是 git-remote-https，请求 github.com:443，使用proxifier，就可以做到这一点，定位到是什么程序，请求的 host 以及 port，并且给它设置代理下面这张图就是proxifier的庐山真面目了终端上代理的难题/image_1b4oengilkbc1djbb48m7e1hbnm.png)上面的日志给出了详细的解释当我在终端里敲下 npm install xxx，对应的就是 node 请求 registry.npmjs.org:443当我在webstorm中设置 github 帐户的时候，对应的是 webstorm，请求 api.github.com:443当我在 git clone repository的时候，对应的是git-remote-https 请求 github.com:443第一步：你得在shadowsocksX中开启 socks5 的本地代理，这是最重要的前提第二步：在proxifier使用第一步设置的代理，如下图所示终端上代理的难题/image_1b4ofiiia5821397ea0phm6rn13.png)第三步：设置代理规则终端上代理的难题/image_1b4og01u91alg1ggk1mh51omdurr1g.png)解释一下我所设置的规则：终端上代理的难题/image_1b4og01u91alg1ggk1mh51omdurr1g-1554097364886.png)规则匹配的顺序是从上往下的 生效的第一条规则是shadowsocksX，因为我们的代理就是靠这个程序的，所以不能让它自己代理自己，否则proxifier 会报无限循环，动作选 direct 规则 github，这里也并没有指定程序git-remote-https，因为 像 webstorm等 GUI 之流，也会访问 github：443的请求，所以不指定程序，只限制 主机和端口，应用范围就不限于终端了 规则 node，解决 npm install 的代理，可以不用 cnpm 了 规则 brew，解决终端下使用 brew 安装 package 的代理 规则 google-analytics，，解决终端下使用 brew 安装 package 的代理 规则 default，不能删除，当匹配不到任何规则的时候，使用该规则任何一个连接请求，从上往下匹配，匹配到了，就会停止以上就是我摸索出来的方法，如果 ss 速度快的话，相信我，你会开心死的一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦，也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理ps：shadowsocks和proxifier windows 下也有，按照道理，windows 下也可用，我自己未测试过]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把项目同时托管到github和oschina]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%8A%8A%E9%A1%B9%E7%9B%AE%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Coschina%2F</url>
    <content type="text"><![CDATA[一、方法一（分别提交）1、添加远程地址，给地址命名来区分123git remote add oschina https://git.oschina.net/xxx/xxx.git或者git remote add github https://github.com/xxx/xxx.git 2、查看远程地址1git remote -v 3、然后push123git push -u oschina或者git push -u github 二、方法二（同时提交）假设你现在想要增加3个远程库地址，分别为 : https://git.oschina.net/shede333/swioslibary.git https://git.oschina.net/shede333/swscrollbar.git https://github.com/shede333/CoreAnimationTestSW.git 首先，先增加第一个地址 git remote add origin &lt;url1&gt;然后增加第二个地址 git remote set-url --add origin &lt;url2&gt;增加第三个地址 git remote set-url --add origin &lt;url3&gt;….依次类推 这样就完成了添加多个地址到origin库中了，以后只要使用git push origin master 就可以一次性push到3各库里面了(使用git push也可) 原理解析git remote set-url --add origin 就是往当前git项目的config文件里增加一行记录config文件打开方式有两种： 使用命令git config -e 在当前git项目的根目录下，文件位于 .git/config (.git目录为隐藏文件) 你每执行一次git remote set-url --add origin 就会增加一行，如下图： 1git remote -v`:显示当前所有远程库的详细信息，显示格式为 `远程库名字 url连接(类型)]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握Dockerfile]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1dockerfile%2F</url>
    <content type="text"><![CDATA[转载自快速掌握Dockerfile docker镜像的简单剖析docker的images,我们可以理解为积木, 一层一层往上搭, 最后完成一个工程化的大项目.在最初,docker实际上,只有一个静态的image(Ps: read-only). 相当于只能读, 所以, 你所有的改动并不会影响到原来的image上, 只会一层一层的叠加, 比如, 你在Ubuntu的image上面, 再接一层nodeJS的image. 实际上的结果是, 两个image叠加起来.这里放一张 the Docker book的说明图:docker 在下载image的时候,会在/var/lib/docker目录下创建相关的image 目录. 而运行的container则会放在/var/lib/docker/containers中.另外,docker中的image,是存储在docker仓库. 现在,我们通过快速创建自已的仓库来仔细了解一下docker是怎样拥有这样一个完善的生态的. docker 仓库首先, 要想拥有自己的docker 仓库, 你得有一个自己的docker账号.so, 那就想apply 一个呗. 在docker hub上面注册一下自己的账号就行. 登录指令在docker中,不仅支持web查看docker中的内容, 而且还支持使用命令行登录. 1234// 登录到dockerdocker login // 然后输入账户密码就ok了// 使用完毕,想要登出docker logout 实际上,docker会将你的认证信息存放在. /.docker/config.json当中。 images 常用命令如果浏览了上面的docker仓库, 会发现在一个repository里面会存在很多images, 比如ubuntu的repository.不同的images发布,代表的都是特定的版本系统. 所以,在拉取的时候,需要额外注意一下你需要的指定docker images. images的拉取在container中,我们讲过,使用docker run的时候, 你会发现如果你的images里面没有存在指定的image时, docker会主动去docker hub里面找,然后下载,并且自动运行. 12// 运行最新版的ubuntu imagedocker run -t -i ubuntu:latest 如果,你想自己手动下载images的话,可以直接pull 1234// 手动拉取imagesdocker pull ubuntu:latest// 拉取12.04版本的ubuntu imagesdocker pull ubuntu:12.04 如果在拉取的时候,想知道这个image是否是真正存在的话,就可以使用.docker 提供的搜索指令. 搜索指定docker在docker中,可以使用自带的search命令,搜索所有含有指定term的image. 相当于js中的search 方法. 12345// 搜索name中含有demo的imagedocker search demo// 结果为: 名字. 通常为: author/image_name . 通常搜索的就是这个// 描述: 就是一段文字描述NAME DESCRIPTION STARS OFFICIAL AUTOMATED 查到之后,我们就可以使用pull将指定的库,拉下来了. 创建自己的image上面说过, contianer是copy image运行的进程容器,image是不会变的read-only 块. 但是,如果我们在container里面, 改动了一些设置,比如,下载了node, 而且,我想要保存我这次改动, 以至于,下次我想重新,启动该image时, 他已经具备了node. 123// 现在我再ubuntu:latest上面安装了node// 伪代码npm install node -g docker提供了一个非常快捷的方式就是创建自己的docker image. 使用docker commit. 12345// 查看刚才改动的container IDdocker ps -a -q -l// 得到 docker_id, 提交到自己的库中docker commit docker_id villainHR/node// 之后会返回新的image id 需要注意,docker commit提交的并不是一个整体的100+MB的ubuntu+node. 他只会将两个仓库的差异提交,比如原来image和新的image比起来,就是多了一个npm install node -g命令. 使用DockerfileDockerfile是为了迅速的构建image而出现的. 他与docker commit 的区别在于. 能够迅速的更替历史image 命令. 比如,我们以前下载的npm是version 2, 现在想要更换为npm@3的话,则难度就不是一般的了. 但是,如果我们能够像写命令一样将下载的配置命令下载Dockerfile里面, 那么以后我们想要更换版本,就是很方便的啦.ok, 现在我们来了解一下Dockerfile是怎样的运行的.dockerfile demo讲解这里,我们利用dockerfile 来搭建一个简单的webServer. 首先创建一个你自己的dockerfile目录 123mkdir first_dockercd first_dockertouch Dockerfile 然后, 确保你有ubuntu:latest image.因为, 接下来我们就是基于它,来搭建我们的server. 123456789first dockerfile demoFROM ubuntu:latest设置该dockerfile的作者和联系邮箱MAINTAINER Jimmy "villainhr@gmail.com"开始配置环境, 下载apt-get,生成index.html的文件RUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo 'first demo' &gt; /usr/share/nginx/html/index.html暴露server的portEXPOSE 80 说一下上面的命令内涵.• FROM: 用来指定第一层image, 这是必须有的. 并且指定的image是存在在你的computer中. 相当于是 docker run. • RUN: 这是用来在container中,做出相应的修改. 相当于 修改+docker commit xxx. 给原来的image加上一层layer. 然后, docker会在你commit新一层之后,重新docker run你最新改动过的image • MAINTAINER: 设置作者和联系邮箱.其实就是docker commit 后面的Name参数. 而且加上了联系邮箱. 这是在dockerfile 运行完后,会自动添加到image上的. • EXPOSE: 用来给最新的container 设置与外部交流的port 上面简单的介绍了基本的dockerfile的命令. 不过, 这尼玛太简单了,不符合我们一贯追求到底的风格.这里, 我们在来细说一下RUN这个命令. 实际上, 这应该是dockerfile的关键. RUN的原理很简单, 就是commit + run. 先创建一个新的image 然后 在这个基础上将原有的container替换为新的,如果某一步的RUN发生错误,则container会停在那个阶段, 这样,你可以直接进入该container去查看,你那一步的RUN发生了什么BUG。 另外, 使用RUN的时候, 需要注意, 由于,dockerfile是由上到下解析的, 比如你一开始FROM ubuntu的image, 那么此时的环境是停留在ubuntu的shell中的.比如: 123RUN touch demo.js// 等同于/bin/sh -c touch demo.js 所以, 如果你调用的image 并没有shell的话, 那么久需要使用exec调用系统shell 来执行命令. 12// 调用系统的shell来运行, 实际上就是 exec xxx xxx xxx.RUN ["npm","install","node"] 运行dockerfile上面的dockerfile文件配置好了之后,就轮到我们运行dockerfile.直接运行docker build即可. 12// 注意后面的".", 用来指定搜索dockerfile文件的路径. docker build -t="jimmy/first_dockerfile" . 说一下docker build的指令吧. 1234// 基本格式为:docker build -t="repository/name:tag" directory// -t用来指定生成的image的name,比如仓库,image的名字以及他的tag,如果你不指定tag, 那么docker会自动添加latest代替。// directory 用来相对于当前运行build的目录, 搜索指定的dockerfile.当然,你也可以使用绝对路径了 顺利的话,应该就会有, 下列的信息出来. 1234567891011121314151617181920Sending build context to Docker daemon 2.048 kBStep 1 : FROM ubuntu:latest ---&gt; c5f1cf30c96bStep 2 : MAINTAINER jimmy "villainhr@gmai.com" ---&gt; Running in 078148a5086a ---&gt; 11b061f665d1Removing intermediate container 078148a5086aStep 3 : RUN cd /var ---&gt; Running in ffd3141e64c8 ---&gt; a4d7c5303b60Removing intermediate container ffd3141e64c8Step 4 : RUN touch demo.js ---&gt; Running in c8393a6fcc98 ---&gt; 109b402b9adcRemoving intermediate container c8393a6fcc98Step 5 : EXPOSE 80 ---&gt; Running in 2c064f4bac57 ---&gt; ff7ad58a5d8aRemoving intermediate container 2c064f4bac57Successfully built ff7ad58a5d8a 然后, 你可以使用docker images查看.就会发现多出来一个image. dockerfile cache上面已经提到过,使用docker build的时候,如果你的dockerfile中的某一步出现问题的话,你生成的image会停留在那一步.当你fix errors时, 重新运行docker build, 此时,docker是不会真的重头来建一遍的,他会使用你改动line的前一个image,然后以此为基点继续向下构建.不过,如果你使用缓存的话,他前面的版本id是不会发生改变的.如果你想完整的得到一个新的ID的话,就可以在build的时候,禁用掉cache. 1docker build --no-cache -t="jimmy/first_dockerfile" . 不过,该方法是不推荐的. 因为一个非常棒的cache机制,就被你硬生生的cancel. 而且,这也极力不推荐使用该方法进行cache的取消.以为,有些地方,我们完全可以利用cache来加快速度.这就需要使用到ENV关键字.来帮助我们,另外利用cache.在讲解ENV之前,先给大家讲解一下docker cache的运行机理.（是不是感觉很激动）实际上,机理就一句话:ID命中. 因为docker在你每次运行一行命令的时候,会自动生成一个id值. 123Sending build context to Docker daemon 2.048 kBStep 1 : FROM ubuntu:latest ---&gt; c5f1cf30c96b // 这就是ID值 docker借由这个ID值,来判断是否有cache镜像.所以,这里就需要借一下ENV这个比较费的指令,来灵活的帮助我们使用cache. 配置化cacheENV的就是给docker来设置变量的. 基本格式为: 123456789一个一个的赋值ENV key value// demo:ENV name jimmyENV age 18另外,还可以一起赋值ENV key=value[...]// demo:ENV name=jimmy age=18 而通过ENV我们就可以完美的告诉docker 从这里开始,你就不能使用cache,自己的重新来.(因为,每条指令都会生成layer并且有独立的id,一旦你更改的ENV,那么从该指令开始id都会发生改变,也就匹配不到缓存了)看个demo: 123456789101112131415161718192021第一个dockerfileFROM ubuntu:latestMAINTAINER jimmy "villainhr@gmai.com"ENV REFRESH first # 这里设置的是refresh=firstRUN cd /varRUN touch demo.jsEXPOSE 80// 使用docker build ... 后面就会生成一系列新的id和images// 现在修改dockerfile第二个dockerfileFROM ubuntu:latestMAINTAINER jimmy "villainhr@gmai.com"ENV REFRESH second # 这里设置的是refresh=secondRUN cd /varRUN touch demo.jsEXPOSE 80// 开始运行docker build... 你会发现,从下面语句开始.ENV REFRESH second// 其docker id就已经发生了改变,并且docker 没有了use cache的提示.说明,下面就没有命中缓存了. 所以,如果你想在某一段不使用缓存,只需要将ENV后面的value改变即可. 创建完后, 我们可以使用docker history,查看一下刚才创建的image的整个流程. 12345678// 查看image创建的过程docker history jimmy/first_dockerfile // 输出的结果为:2322ddc85cc3 10 hours ago /bin/sh -c #(nop) EXPOSE 80/tcp 0 B b39397abc7aa 10 hours ago /bin/sh -c touch demo.js 0 B 3c9a4daf4c42 10 hours ago /bin/sh -c cd /var 0 B b1c2f890a262 10 hours ago /bin/sh -c #(nop) ENV REFRESH=second 0 B 2cf0ee3c373c 10 hours ago /bin/sh -c #(nop) MAINTAINER jimmy "villainhr 0 B 俺的目的,其实是想让你们看看,docker在每一层是怎么执行的–/bin/sh. 了解了之后,我们就继续了. docker container的接口暴露上面通过dockerfile 已经暴露了一个80接口,用来和外部通信。 不过,如果我们没有使用EXPOSE暴露接口的话, 那应该怎么做呢？我们可以直接在外部运行docker image, 手动指定暴露的端口. 1234567同样,暴露80端口给外部交互docker run -d -p 80 --name demo jimmy/node \node -jimmy app.js-d是daemon的意思-p 80 表示暴露80的port给外部node -jimmy app.js 表示在jimmy/node image里面运行的指令 这里, 我们需要额外了解一下80端口的开启. docker 其实是在底层上面,虚拟化了存储. 并且,docker在运行的时候,会自动向主机要一个ip(假的), 相当于,有了自己的host. (这不就一个主机吗？)这里我们开启的80端口,是docker在内部虚拟开启的, 他会从32768 到 61000端口之间,随机抽一个映射到docker开启的80端口上, 依此来和外部进行真正的交互(膜拜///). 12345678使用docker ps -l 来查看开启情况docker ps -l得到: 只截取了一部分.0.0.0.0:49154-&gt;80 tcp或者指定查看docker端口开启情况docker port c96f2c18bb64 80 // ID也可以使用name代替返回: 0.0.0.0:49154 手动指定端口如果你不想让docker决定的绑定的接口是哪一个,ok, 你可以自己指定. 12345678手动指定端口指定docker的8080连接到container暴露的80端口docker run -d -p 8080:80 --name demo jimmy/node \node -jimmy app.js甚至你也可以指定ip+port指定docker的127.0.0.1:8080连接container的80docker run -d -p 127.0.0.1:8080:80 --name demo jimmy/node \node -jimmy app.js 利用EXPOSE在写dockerfile的时候,我们已经了解了,使用EXPOSE可以完美的实现端口的暴露. 但如果,我们在dockerfile里面暴露多个port的话,那么-p的参数,感觉有点鸡肋啊喂不过,现在我们可以使用-P(注意是大写). 来手动开启所有在dockerfile中,通过EXPOSE暴露的端口. 12docker run -d -P --name demo jimmy/node \node -jimmy app.js 外部访问通过端口开启之后,我们就可以间接的访问docker的路由, 来访问在docker里面开启的端口了. 12假如上面我们通过dockre暴露的端口是34251的话,就可以在docker环境外访问了.ping localhost:34251 dockerfile常用指令自动化运行CMD你是不是已经厌烦了使用docker run 来运行命令了呢？ 你是不是已经讨厌重复的copy命令运行了呢？那么请使用CMD吧.CMD的作用是,用来指定当你调其对应的container时, 运行的命令.比如在dockerfile中,指定/bin/bash. 123456当调起container时,运行/bin/bashdocker run -t -i jimmy/ubuntu:latest /bin/bash等同于在dockerfile中指定CMDCMD ["/bin/bash"]// 运行docker rundocker run -t -i jimmy/ubuntu:latest 不过,如果你在run后面手动指定指令运行的话,会默认覆盖掉CMD提供的命令.熟悉了CMD,感觉有种RUN的感觉. 但,这两者的区别还是很大的• RUN: 一般是用来给image增加layer来完善image, 他一旦执行完,就和后面的运行没有关系了 • CMD: 这个在docker build过程中,是没有半毛钱关系的. 他只和在调用image时,关系比较大 强制运行ENTRYPOINT这里的ENTRYPOINT和CMD很相似. 可以说,在一定程度上两者可以互相替代,但,两者的实际意义相差还是挺大的.ENTRYPOINT的主要功能是强制执行的环境. 1234567指定ENTRYPOINT为/bin/shENTRYPOINT ["/bin/sh"]// 然后在build之后,调起container我们尝试在run后面加上参数:docker run -t -i jimmy/demo /bin/bash/// 不出意外的话,会得到一个bug提示:&gt;&gt;/bin/sh: 0: Can't open /bin/bash/ 所以, ENTRYPOINT的主要功能实际上是,指定了内部运行命令的解析器. 而使用docker run添加的命令,会被当做参数添加给ENTRYPOINT. 12345已经指定了ENTRYPOINT ["/bin/sh"]运行docker rundocker run -t -i jimmy/demo /bin/bash/实际上相当于(不出错才怪嘞...)/bin/sh /bin/bash/ 另外,我们还可以使用CMD配合ENTRYPOINT写成默认参数的效果. 12345默认执行 /bin/bash default.shENTRYPOINT ["/bin/bash"]CMD ["default.sh"]如果你在docker run中指定了参数的话,则CMD会默认被代替 docker run jimmy/demo sam.sh 不过,CMD和ENTRYPOINT都只能在dockerfile里面出现一次. 指定运行目录WORKDIR既然,我们能够在dockerfile里面运行指定的命令。 但,有时,我们仅仅是想在不同的目录中执行不同的命令. 那,在dockerfile中,如何做到灵活的目录切换呢？那就得使用docker提供的WORKDIR命令了. 123456在/var/data里面创建data.jsWORKDIR /var/dataRUN touch data.js然后在/etc 下创建data.conf文件WORKDIR /etcRUN touch data.conf 并且当你在使用docker run时,他也会停留在使用WORKDIR指定的目录中. 环境变量的设置ENVENV在dockerfile里面的用处,应该算是灰常大的. 什么灵活更新,什么变量设置,什么更改全局变量等. 都是so easy.那ENV到底是用来干嘛的?答: 就是用来设置变量的啊喂. 只是他是设置全局变量.比如像PATH神马的之类的. 12设置一个DATA的全局变量.ENV DATA=jimmy ENV最独特之处在于,他所设置的变量,会在你运行的时候生效.即,如果你修改了PATH,他也会在container中立即生效. 12345修改环境变量ENV PATH=$PATH:/user/bin// 现在进入到运行的container中echo $PATH&gt;&gt; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/data 挂载通用盘VOLUME在说里面正式的内容之前,我们先来说一下,什么叫做VOLUME. 说人话吧,VOLUME叫做数据卷, 相当于通用盘一样的东西. 他其实也是一个存储装置,我们就把他叫做硬盘吧. 这个硬盘不普通,有>1的外接口.(说人话) 每一个外接口,都可以接入到一个操作系统里面. 即,实现了多个系统的数据共享.一句话: VOLUME就是一个数据共享盘而,docker秉承着,虚拟储存idea, 想下面idea践行到底.wirte once, run anywhere(感觉,在哪见过)所以, dockerfile提供了一个VOLUME的指令,能够让我们指定数据卷的位置. 1234指定/opt/data为数据卷VOLUME ["/opt/data"]指定多个目录为数据卷/opt/data, /opt/projectVOLUME ["/opt/data","/opt/project"] 当然,关于数据卷的操作,肯定不止挂载这一点,还有迁移,备份等等,相关操作. 具体,可以参考: Docker VOLUME 添加外部文件ADD有时,我们仅仅是想将外部文件copy到container中,docker有办法吗？nonsensedocker 提供了ADD命令,来帮助我们完成文件的添加. 不过,这里ADD有点限制, 即, 你添加的文件或者目录,只能在docker build运行的目录下, 因为,这是docker在调起container的时候,只将该目录放进了daemon(尴尬) 123456789101112现假设,docker build运行的目录为: /data// 只能添加指定目录下// 将/data/sam.js 添加到image中的/opt/node/sam.js// 如果存在该文件,则不会被覆盖ADD sam.js /opt/node/添加文件,还可以使用通配符// 将所有的js文件,添加到node目录下ADD *.js /opt/node/如果destination不是绝对路径,则相对于最近的WORKDIR// 如果最近的WORKDIR为/var// 则下列添加的路径为/var/opt/nodeADD *.js opt/node/ 当文件被添加到指定目录中时,该文件的权限是755,并且UID和GID都是0.ADD 还支持url添加,以及文件自动解压. 123456使用url添加// 将指定路由的文件放到根目录当中ADD http://example.com/foobar /自动解压tar.gz文件// 将文件解压过后放在指定目录中ADD latest.tar.gz /var/www/wordpress/ 纯粹的COPYCOPY和ADD非常类似. 我们可以做个类比:ADD 包含 COPYCOPY做的事情比不上ADD, 他比ADD少了解压缩和URL下载的功能. 不过,他耗费的性能比较少,他只做纯粹的添加和下载.他的结构和ADD一毛一样. 不过, 有一点,COPY的时候,如果遇到目录不存在的情况下,COPY会自动创建 1COPY file.js /opt/data/ 添加个人信息LABEL顾名思义,使用LABEL就是给你的image打上独一无二的标签.让别人能够了解,这个Image是属于你的. 又或是,用来提醒你自己,这个image现在处于哪一个版本状态. 12设置自己的labelLABEL owner="jimmy" version="0.0.1" 在创建完image之后, 我们可以使用docker inspect来查看我们已经打的LABEL 1234567docker inspect jimmy/node...labels:&#123;owner:"jimmy",version:"0.0.1"&#125;... 本人觉得, 这个指令其实真的,有时, 母鸡用到什么地方去…并且,书写的时候,最好多个连着写,因为这样只会增加一层image.(image的层数是有限制的) 参数形式ARG这是docker提供的另外一个,让我有点懵逼的命令. 他的实际效果和ENV的区别可以趋近于无。 1234使用ARG定义变量ARG buildno设置默认值ARG user1=someuser 当然,我们可以在命令中,手动指定替换. 1234在dockerfile定义了默认变量ARG user=jimy在运行时,进行手动替换docker build --build-arg user=sam -t jimmy/demo . 上面说了ARG和ENV比较类似,不过,里面的区别还是有的. 即, ARG只能用在docker build的阶段, 并且不会被保存在image中,这就是和ENV的区别. 模板image之ONBUILD因为dockerfile的构建的层数有限制,所以,这也带给了我们一些麻烦, 如果搭建的环境过多,则会造成写到一半,发现dockerfile已经full. 这时候, 就轮到ONBUILD出场了. ONBUILD的作用在于,他可以完美的实现模板image的搭建.ONBUILD的主要作用在于,他定义的命令,可以在子dockerfile中使用.(md… 好绕口) 123456789使用ONBUILD 默认下载ApacheONBUILD RUN apt-get update &amp;&amp; apt-get install -y apache2// 然后运行docker file 会得到下列结果 Step 3 : ONBUILD RUN apt-get update &amp;&amp; apt-get install -y apache2 ---&gt; Running in 0e117f6ea4ba ---&gt; a79983575b8//然后生成一个新的image,我们这里暂且叫他jimmy/demo 接下来,我们再来写一个dockerfile 123456789101112这里继承上面的jimmy/demoFROM jimmy/demo:latestENV SEX=001// 运行上面的dockerfile,得到:Step 0 : FROM jimmy/demoExecuting 1 build triggers Step onbuild-0 : ADD . /var/www/ ---&gt; 1a018213a59d ---&gt; 1a018213a59d Step 1: ENV SEX=001 ... 细心的童鞋可以发现这一条命令: 123Step onbuild-0 : RUN apt-get update &amp;&amp; apt-get install -y apache2 ---&gt; 1a018213a59d ---&gt; 1a018213a59d 他居然在这里自动运行了. 所以,我们可以将ONBUILD命令理解为模板命令. 即,子dockerfile里面运行时同样生效(这里,我没有说grandchildren的事).但ONBUILD只能往下延伸一级. 相当于你用ONBUILD定义的命令,有两次有效次数,一次在build原来Image时,已经用掉了. 所以, 另外一次(在子dockerfile中使用)用掉了之后就无效了. grandchildren dockerfile就没法使用了.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用软件]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、MarkDown编辑：Typora 2、七牛同步：QSunSync 3、前端开发：VSCode 4、node版本控制：nvm 5、sftp文件传输：FileZilla 6、远程控制：TeamViewer 7、ssh管理：MobaXterm]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Verdaccio搭建npm仓库]]></title>
    <url>%2F2019%2F03%2F29%2F%E4%BD%BF%E7%94%A8Verdaccio%E6%90%AD%E5%BB%BAnpm%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[使用Verdaccio搭建npm仓库Verdaccio是一个轻量级的私有NPM的Registry（从Sinopiafork过来的，sinopia最后一次更新是在几年前了）。最开始是打算使用cnpmjs这个来搭建私有的npm仓库但是搭建完成之后存在一些问题，所以使用了Sinopia，本文记录下来搭建的过程。 直接安装1npm install verdaccio -g 安装完成之后直接执行命令即可完成启动： verdaccio 对于服务器上面部署可以使用pm2 更多关于PM2的用法的可以参考：https://wohugb.gitbooks.io/pm2 使用Docker安装由于之前搭建Nexus的时候安装了Docker的环境，刚好verdaccio支持Docker，所以直接使用Docker来安装了。 1、创建配置文件123mkdir -p /home/dockergit clone https://github.com/verdaccio/docker-examplesmv docker-local-storage-volume /home/docker/verdaccio 2、修改配置文件（1）修改conf/config.yaml 1234# 使用淘宝的cnpmjs镜像，加速uplinks: npmjs: url: https://registry.npm.taobao.org/ （2）修改conf/htpasswd 到http://tool.oschina.net/htpasswd生成需要的账号密码 （3）删除storage下面的文件 3、创建并运行容器1docker run --name verdaccio -d -v /home/docker/verdaccio:/verdaccio -p 4873:4873 verdaccio/verdaccio:latest 通过docker logs verdaccio查看日志发现存在权限问题，是由于使用了挂载的数据卷和容器内部的权限不一致的问题，需要修改下权限： （1）进入容器 1docker exec -it verdaccio sh （2）查看用户ID 1whoami &amp; id （3）修改文件夹权限 1sudo chown -R 200 verdaccio 客户端配置启动容器之后访问http://localhost:4873出现如下界面表示安装成功： （1）配置使用私有的镜像 1npm set registry http://localhost:4873 （2）登录 1npm adduser --registry http://localhost:4873 （3）发布 1npm publish --registry http://localhost:4873]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云平台通用操作手册]]></title>
    <url>%2F2019%2F03%2F29%2F%E4%BA%91%E5%B9%B3%E5%8F%B0%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 云平台通用操作手册云平台简介云平台目前共以下4种管理平台 平台 访问地址 云管理平台 dc.fitech.tech:10012 192.168.101.30:10012 gitlab私库 gitlab.fitech.tech:10002 192.168.101.30:10002 npm私库 npm.fitech.tech:10005 192.168.101.30:10005 LDAP账号管理平台 192.168.101.30:8081/phpldapadmin 一、云管理平台主要用于容器的创建及管理，可以实现服务发现和负载均衡等 二、gitlab私库1、配置ssh key 2、编辑~/.ssh/config文件，添加 Host gitlab.fitech.tech HostName gitlab.fitech.tech Port 10003 Windows系统在C:/User/用户名/ssh/config 如果没有config文件新增即可 3、gitlab现有两种登录模式，一种gitlab注册账号登录，另一种LDAP创建的账号登录 三、npm私库使用步骤： 1、 2、npm包发布私库 npm login username:fitech password:123123 email:fitech@fitech.tech npm publish 四、LDAP账号管理平台主要用于云平台各个平台的统一账号管理，phpldapadmin的账户名cn=admin,dc=fitech,dc=fitech 新增账号流程： 1、选择Create new entry here 2、选择Generic: User Account 3、填写信息，选择Create Object]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>云平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[width&height&top&bottom]]></title>
    <url>%2F2019%2F03%2F29%2Fwidth%26height%26top%26bottom%2F</url>
    <content type="text"><![CDATA[1、Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。 ​ 返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。 ​ DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。 1rectObject = object.getBoundingClientRect();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack踩坑之路图片的路径与打包]]></title>
    <url>%2F2019%2F03%2F29%2Fwebpack%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF%E5%9B%BE%E7%89%87%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[刚开始用webpack的同学很容易掉进图片打包这个坑里，比如打包出来的图片地址不对或者有的图片并不能打包进我们的目标文件夹里(bundle)。下面我们就来分析下在webpack项目中图片的应用场景。 在实际生产中有以下几种图片的引用方式： \1. HTML文件中img标签的src属性引用或者内嵌样式引用 12&lt;img src=&quot;photo.jpg&quot; /&gt;&lt;div style=&quot;background:url(photo.jpg)&quot;&gt;&lt;/div&gt; \2. CSS文件中的背景图等设置 123.photo &#123; background: url(photo.jpg);&#125; \3. JavaScript文件中动态添加或者改变的图片引用 12var imgTempl = &apos;&lt;img src=&quot;photo.jpg&quot; /&gt;&apos;;document.body.innerHTML = imgTempl; \4. ReactJS中图片的引用 ;) 12345678910import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;class App extends React.Component &#123; render() &#123; return (&lt;img src=&apos;photo.jpg&apos; /&gt;); &#125;&#125;ReactDom.render(&lt;App /&gt;, document.querySelector(&apos;#container&apos;)); ;) url-loader 在 webpack 中引入图片需要依赖 url-loader 这个加载器。 安装： 1npm install url-loader --save-dev 当然你可以将其写入配置中，以后与其他工具模块一起安装。 在 webpack.config.js 文件中配置如下： ;) 12345678module: &#123; loaders: [ &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos; &#125; ]&#125; ;) test 属性代表可以匹配的图片类型，除了 png、jpg 之外也可以添加 gif 等，以竖线隔开即开。 loader 后面 limit 字段代表图片打包限制，这个限制并不是说超过了就不能打包，而是指当图片大小小于限制时会自动转成 base64 码引用。上例中大于8192字节的图片正常打包，小于8192字节的图片以 base64 的方式引用。 url-loader 后面除了 limit 字段，还可以通过 name 字段来指定图片打包的目录与文件名： ;) 12345678module: &#123; loaders: [ &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&amp;name=images/[hash:8].[name].[ext]&apos; &#125; ]&#125; ;) 上例中的 name 字段指定了在打包根目录（output.path）下生成名为 images 的文件夹，并在原图片名前加上8位 hash 值。 例：工程目录如下 在 main.css 中引用了同级 images 文件夹下的 bg.jpg 图片 1background-image: url(./images/bg.jpg); 通过之前的配置，使用 $ webpack 命令对代码进行打包后生成如下目录 打包目录中，css 文件和 images 文件夹保持了同样的层级，可以不做任务修改即能访问到图片。区别是打包后的图片加了 hash 值，bundle.css 文件里引入的也是有hash值的图片。 1background-image: url(images/f593fbb9.bg.jpg); （上例中，使用了单独打包css的技术，只是为了方便演示） publicPath output.publicPath 表示资源的发布地址，当配置过该属性后，打包文件中所有通过相对路径引用的资源都会被配置的路径所替换。 12345output: &#123; path: &apos;dist&apos;, publicPath: &apos;/assets/&apos;, filename: &apos;bundle.js&apos;&#125; main.css 1background-image: url(./images/bg.jpg); bundle.css 1background-image: url(/assets/images/f593fbb9.bg.jpg); 该属性的好处在于当你配置了图片 CDN 的地址，本地开发时引用本地的图片资源，上线打包时就将资源全部指向 CDN 了。 但是要注意，如果没有确定的发布地址不建议配置该属性，否则会让你打包后的资源路径很混乱。 JS中的图片 初用 webpack 进行项目开发的同学会发现：在 js 或者 react 中引用的图片都没有打包进 bundle 文件夹中。 正确写法应该是通过模块化的方式引用图片路径，这样引用的图片就可以成功打包进 bundle 文件夹里了 js 123var imgUrl = require(&apos;./images/bg.jpg&apos;), imgTempl = &apos;&lt;img src=&quot;&apos;+imgUrl+&apos;&quot; /&gt;&apos;;document.body.innerHTML = imgTempl; react 123render() &#123; return (&lt;img src=&#123;require(&apos;./images/bg.jpg&apos;)&#125; /&gt;);&#125; HTML中的图片 由于 webpack 对 html 的处理不太好，打包 HTML 文件中的图片资源是相对来说最麻烦的。这里需要引用一个插件—— html-withimg-loder 1$ npm install html-withimg-loader --save-dev webpack.config.js 添加配置 ;) 12345678module: &#123; loaders: [ &#123; test: /\.html$/, loader: &apos;html-withimg-loader&apos; &#125; ]&#125; ;) 在 bundle.js 中引用 html 文件 1import &apos;../index.html&apos;; 这样 html 文件中的图片就可以被打包进 bundle 文件夹里了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>gif</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat常用配置]]></title>
    <url>%2F2019%2F03%2F29%2Ftomcat%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、启动跳过jar包检查 在conf/catalina.properties中加入 1org.apache.el.parser.SKIP_IDENTIFIER_CHECK=true 2、应用中需要绘图，例如activiti的流程图： 在catalina.sh加入]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react引入antd]]></title>
    <url>%2F2019%2F03%2F29%2Freact%E5%BC%95%E5%85%A5antd%2F</url>
    <content type="text"><![CDATA[需安装babel-plugin-import插件 12345678910&#123; test: /\.(js|jsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; plugins: [ ['import', [&#123; libraryName: 'antd', style: true &#125;]], // import less 'react-hot-loader/babel' ]&#125;,]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用命令]]></title>
    <url>%2F2019%2F03%2F29%2Fnrm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、常用命令12345678910111213#查看包信息npm list -g gulp #安装并查看安装信息npm -loglevel info install -g gulp #发布到https://registry.npmjs.org/npm --registry https://registry.npmjs.org/ publish #设置npm库npm config set registry https://registry.npm.taobao.org/npm config set registry http://registry.npmjs.org #查看当前npm库cat ~/.npmrc#登录npm adduser –-registry http://192.168.101.30:10005/repository/npm-repo-hosted/ 二、nrm的使用开发的npm registry 管理工具 nrm, 能够查看和切换当前使用的registry, 最近NPM经常 down 掉, 这个还是很有用的哈哈 Install1$ npm install -g nrm Example1234567$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ 12$ nrm use cnpm //switch registry to cnpm Registry has been set to: http://r.cnpmjs.org/ 12345cmdnrm help // show helpnrm list // show all registriesnrm use cnpm // switch to cnpmnrm home // go to a registry home page]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>nrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle常用命令]]></title>
    <url>%2F2019%2F03%2F29%2Foracle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Oracle中用命令参数详解1、exp/imp——导入、导出【用 exp 数 据 导 出】：1 将数据库TEST完全导出,用户名system 密码manager 导出到D:\daochu.dmp中 1exp east/east@xe file=/root/east.dmp full=y exp east/east@xe file=/root/east.dmp full=yexp east/east file=/root/east.dmp full=y imp east/east@xe file=east.dmp log=east.dmp full=y ignore=y 2、创建表空间2.1先创建一个表空间，例如（临时表空间）create temporary tablespace fitech_temp tempfile ‘/u01/app/oracle/oradata/XE/fitech_temp.dbf’ size 50m autoextend on next 50m maxsize 20480m extent management local; （永久表空间） create tablespace fitech_data logging datafile ‘/u01/app/oracle/oradata/XE/fitech_data.dbf’ size 50m autoextend on next 50m maxsize 20480m extent management local; 2.2创建用户并指定表空间（第一个east为用户名，第二个east为密码） create user east identified by east default tablespace fitech_data temporary tablespace fitech_temp; 修改用户表空间 alter user 用户名 default tablespace 表空间名字 ;–创建时候指定表空间 alter user east default tablespace fitech_data temporary tablespace fitech_temp; 2.3给用户分配权限grant connect,resource,dba to east; 2.4使用east用户登录，查看数据库用户正常访问即可3、查看数据库状态lsnrctl status]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus 上搭建npm本地服务器-2]]></title>
    <url>%2F2019%2F03%2F29%2Fnexus%20%E4%B8%8A%E6%90%AD%E5%BB%BAnpm%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-2%2F</url>
    <content type="text"><![CDATA[1.在本地运行nexus附上下载链接：Nexus Repository OSS 下载链接附上文档链接：Nexus Repository OSS 文档链接 有几个值得注意的是 我的 系统为 64位 win 7，平时只配置了java的基本环境，没有配置编译环境。很尴尬，配置javac耽误了我一点时间。需要的同学，在运行之前 需要配置一下jre环境。 我下载的是 nexus-3.5.0-02 这个版本。事实证明在win下虽然看起来一副人畜无害的样子，似乎可以直接点击安装，但是事实上，啧啧啧。 Paste_Image.png 这里没有好好阅读文档，也消耗了我的一些时间，下面放出win 下正确启动方法 12// 在 \nexus-3.5.0-02\bin 目录下执行$ nexus.exe /run 这里经测试 用win自带的cmd，和budun都可以比较好的启动，用git bash则启动不是很好 ​ ​ Paste_Image.png 启动之后默认地址为 localhost:8081, 默认账号密码 admin/ admin123 Nexus Repository Manager 中添加 npm如果点击： Paste_Image.png 这里有三个类型的npm选项： Paste_Image.png 文档中对这三个类型的仓库有详细的解释： Paste_Image.png 附上某歌翻译： Proxying npm Registries为了减少开发人员和CI服务器的重复下载量并提高下载速度，您应该对托管在https://registry.npmjs.org上的注册表进行代理。 默认情况下，npm直接访问此注册表。 您还可以代理您需要的任何其他注册表。要代理外部npm注册表，您只需创建一个新的npm（代理），如“存储库管理”中所述。最小配置步骤是： 定义名称 定义远程存储的URL，例如https://registry.npmjs.org 选择存储的Blob存储 Private npm Registries私人npm注册表可用于上传您自己的软件包以及第三方软件包。 您可以通过在存储库管理器中设置npm格式的托管存储库来创建私有的npm注册表。 为了这些目的，建立两个独立的托管存储库是一个很好的做法。要创建具有npm格式的托管存储库，只需创建一个新的npm（托管），如“存储库管理”中所述。最小配置步骤是： 定义名称 选择存储的Blob存储 随着软件包从存储库部署或删除，npm注册表信息将立即更新。 Grouping npm Registries存储库组是将所有npm注册表存储库从存储库管理器公开给您的用户的推荐方式，而不需要任何其他客户端配置。存储库组允许您将多个代理和托管存储库的聚合内容公开为一个URL到npm和其他工具。这可以通过创建一个新的npm（组），如“存储库管理”中所述，用于npm存储库。最小配置步骤是： 定义名称 选择存储的Blob存储 以所需的顺序将npm存储库添加到成员列表中 典型的有用的示例是将代理存储库分组：代理npm注册表，npm托管存储库与内部软件包和另一个npm托管存储库与第三方软件包。使用存储库组的URL作为客户端工具中的npm存储库URL，您可以使用一个URL访问所有三个存储库中的软件包。添加的任何新软件包以及添加到组中的任何新存储库将自动可用。 创建 Proxying npm Registries 代理仓库 Paste_Image.png 创建 Hosted npm Registries 代理仓库 Paste_Image.png 创建 Grouping npm Registries 仓库需要注意的是组仓库要把之前的 proxy 和 hosted 都添加上。 Paste_Image.png 我的目录对应为 mytest/myhost/mygroup 在home目录下， 的.npmrc文件中添加 registry = http://localhost:8081/repository/npm-all/ 。这个路径要和自己的路径一致，并且最后的rep名要和group相同。 win下 home路径： Paste_Image.png 这时尝试一下 12// 查看一下 是否从本地服务器中下载$ npm -loglevel info install grunt 图片我抄的，我自己的没截图 此时可以验证一下 是否依赖走了代理： Paste_Image.png 设置权限把这个选项拖到右边就可以了 Paste_Image.png 在admin之外可以重新设置一个账号，以及权限 Paste_Image.png 123// 使用$ npm login –registry=http://localhost:8081/repository/mygroup// 进行登陆，需要填写账号、密码以及邮箱。 Paste_Image.png 发布到hosted 我和原教程不一样的是：我发布到本地hosted， 而不是直接到npm社区，这里需要注意的是 通过proxy是可以直接发布到npm社区的，使用的是社区的账号密码，这个需要提前申请 要发布的模块，必须保证在根目录下有package.json文件，否则会报错。 pachage.json文件内容比较随意，如果比较懒 可以用 npm init 直接自动生成。 1234&#123; &quot;name&quot;: &quot;myhost&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 然后执行发布命令： 1$ npm publish –registry http://localhost:8081/repository/myhost Paste_Image.png 然后我遇到了报错，按照报错执行 1$ npm adduser –registry http://localhost:8081/repository/myhost 这里值得注意的是， adduser的时候要指明是哪个rep，要不就会add到默认的.npmrc 里添加的 rep中 Paste_Image.png 添加完用户之后，再执行发布命令就ok了。 Paste_Image.png package.json可以指定name 和version并且可以添加发布路径的配置： 1234567&#123; &quot;name&quot;: &quot;intro&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;publishConfig&quot; : &#123; &quot;registry&quot; : &quot;http://localhost:8081/repository/myhost/&quot; &#125;&#125; 这样的话发布直接用 npm publish就可以了。 发布之后可以在 系统中的 左侧browse 中的assets中看到上传的资源 Paste_Image.png group 中可以同时看到 proxy 和 hosted 的资源， proxy会存下第一次下载过的目录，之后再下载时走的是代理，hosted存的是本地上传的包资源。 然后可以在本地下载一下刚才上传到hosted的包： Paste_Image.png 以上，为所有内容。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexus 上搭建npm本地服务器-1]]></title>
    <url>%2F2019%2F03%2F29%2Fnexus%20%E4%B8%8A%E6%90%AD%E5%BB%BAnpm%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-1%2F</url>
    <content type="text"><![CDATA[Nexus作为私库管理最为流行的工具之一，用于包的管理和Docker镜像管理的私库管理场景中非常常用，但同时也可以用于NPM私库等的管理。 Why Nexus 3这里整理了为什么使用Nexus 3的一些理由，在做选型的时候可以做一个简单参照。 项目 详细 为什么使用Nexus 3 http://blog.csdn.net/liumiaocn/article/details/62050525 docker版本本次使用的docker的版本为17.09.0-ce，但是并不限于此版本，其他版本未作验证。 123456789101112131415161718[root@angular ~]# docker versionClient: Version: 17.09.0-ce API version: 1.32 Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:39:28 2017 OS/Arch: linux/amd64Server: Version: 17.09.0-ce API version: 1.32 (minimum version 1.12) Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:45:38 2017 OS/Arch: linux/amd64 Experimental: false[root@angular ~]#123456789101112131415161718 下载镜像123456789101112[root@angular ~]# docker pull liumiaocn/nexusUsing default tag: latestlatest: Pulling from liumiaocn/nexusd9aaf4d82f24: Pull complete 1bf6f9237306: Pull complete 2cb68a4c7b1e: Pull complete a81c750844e6: Pull complete ea509a1d48c2: Pull complete 24d48f5e8202: Pull complete Digest: sha256:3480d50b7ddfb72fe77ce55c7b5ce0a9aa7b6cfa90886a8f8ddc4a2401f1b7c9Status: Downloaded newer image for liumiaocn/nexus:latest[root@angular ~]#123456789101112 启动Nexus 项目 详细 Nexus UI 8081 private repo 8082 proxy repo 8083 URL http://192.168.163.151:8081/ 123[root@angular ~]# docker run -d -p 8081:8081 -p 8082:8082 -p 8083:8083 --name nexus liumiaocn/nexusd5807c07c10c1f55d4ea85e774529dd6c0daf8833d1e505d4c1f09db00491e87[root@angular ~]#123 logon 项目 详细 URL http://192.168.163.151:8081/ 用户名称 admin 用户密码 admin123 登陆之后 仓库类型具体仓库类型主要分为hosted/proxy/group三种。具体含义如下： 项目 详细说明 hosted 本地存储，提供本地私库功能 proxy 提供代理其他仓库的类型 group 组类型，可以组合多个仓库为一个地址提供服务 创建blob创建一个blob用于存放npm相关数据。 项目 详细说明 Type File Name npm-repo-blob PATH /nexus-data/blobs/npm-repo-blob 建议实际项目中各个仓库根据具体情况决定是否要分别创建blob进行对应，此处进行演示就通篇使用一个blob 创建priavete仓库创建一个Hosted的仓库作为private仓库，用于管理非npm社区的第三方包或者自己开发的内容。具体设定信息如下： 项目 详细说明 类型 npm(hosted) Name npm-repo-hosted Blob store npm-repo-blob 其余Default设定即可 创建proxy仓库创建一个proxy仓库，具体设定信息如下： 项目 详细说明 类型 npm(proxy) Name npm-repo-proxy Remote Storage https://registry.npmjs.org Blob store npm-repo-blob 其余Default设定即可 注意：此处的Remote Storage即为可以连接的npm的registry的地址，需要保证正确，并且当前机器能够访问到，比如可以使用curl确认： 12[root@angular ~]# curl https://registry.npmjs.org&#123;&quot;db_name&quot;:&quot;registry&quot;,&quot;doc_count&quot;:715000,&quot;doc_del_count&quot;:344,&quot;update_seq&quot;:8090315,&quot;purge_seq&quot;:0,&quot;compact_running&quot;:false,&quot;disk_size&quot;:5368389766,&quot;data_size&quot;:3541008450,&quot;instance_start_time&quot;:&quot;1510668164237911&quot;,&quot;disk_format_version&quot;:6,&quot;committed_update_seq&quot;:8090315&#125;[root@angular ~]# 12 注意此处，可以还设定与社区相关的账号和密码等信息进行进一步连接。 创建group仓库创建一个group仓库，具体设定信息如下： 项目 详细说明 类型 npm(group) Name npm-repo-group Blob store npm-repo-blob Member repositories npm-repo-hosted Member repositories npm-repo-proxy 本地npm设定验证用npm版本12345[root@angular ~]# npm -v5.5.1[root@angular ~]# node -vv9.1.0[root@angular ~]# 12345 具体安装可以参看：http://blog.csdn.net/liumiaocn/article/details/78510679 设定.npmrc可以使用如下命令，也可直接修改.npmrc文件 12[root@angular ~]# npm config set registry http://192.168.163.151:8081/repository/npm-repo-proxy/[root@angular ~]#12 确认.npmrc 123[root@angular ~]# cat ~/.npmrcregistry=http://192.168.163.151:8081/repository/npm-repo-proxy/[root@angular ~]# 123 确认至此，Nexus的设定准备基本就绪，可以确认结果了。 事前确认12345[root@angular ~]# npm list -g gulp/usr/local/npm/node/lib└── (empty)[root@angular ~]# 12345 安装gulp打开loglevel将其设定为info，在安装的过程中可以看到npm http fetch与新创建的proxy仓库的交互，因为其会将相关的依赖下载到本地nexus的npm私库中。 123456789101112131415[root@angular ~]# npm -loglevel info install -g gulpnpm info it worked if it ends with oknpm info using npm@5.5.1npm info using node@v9.1.0...npm http fetch GET 200 http://192.168.163.151:8081/repository/npm-repo-proxy/gulplog/-/gulplog-1.0.0.tgz 4439ms.../usr/local/npm/node/bin/gulp -&gt; /usr/local/npm/node/lib/node_modules/gulp/bin/gulp.js...npm info lifecycle gulp@3.9.1~postinstall: gulp@3.9.1+ gulp@3.9.1added 186 packages in 143.59snpm info ok [root@angular ~]# 123456789101112131415 结果确认12345[root@angular ~]# npm list -g gulp/usr/local/npm/node/lib└── gulp@3.9.1 [root@angular ~]# 12345 group仓库确认gulp 3.9.1已经通过group仓库可以看到 proxy仓库确认gulp 3.9.1已经通过proxy仓库可以看到 总结这篇文章简单介绍了如何使用nexus3进行npm私库设定和使用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset revert 回退回滚取消提交返回上一版本]]></title>
    <url>%2F2019%2F03%2F29%2Fgit%20reset%20revert%20%E5%9B%9E%E9%80%80%E5%9B%9E%E6%BB%9A%E5%8F%96%E6%B6%88%E6%8F%90%E4%BA%A4%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[总有一天你会遇到下面的问题.(1)改完代码匆忙提交,上线发现有问题,怎么办? 赶紧回滚.(2)改完代码测试也没有问题,但是上线发现你的修改影响了之前运行正常的代码报错,必须回滚. 这些开发中很常见的问题,所以git的取消提交,回退甚至返回上一版本都是特别重要的.大致分为下面2种情况: 1.没有push这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令resetgit reset –soft | –mixed | –hard 上面常见三种类型 –mixed会保留源码,只是将git commit和index 信息回退到了某个版本.git reset 默认是 –mixed 模式git reset –mixed 等价于 git reset –soft保留源码,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可. –hard源码也会回退到某个版本,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)当然有人在push代码以后,也使用 reset –hard \&lt;commit…> 回退代码到某个版本之前,但是这样会有一个问题,你线上的代码没有变,线上commit,index都没有变,当你把本地代码修改完提交的时候你会发现权是冲突…..所以,这种情况你要使用下面的方式 2.已经push对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令 revertgit revert用于反转提交,执行evert命令时要求工作树必须是干净的.git revert用一个新提交来消除一个历史提交所做的任何修改.revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题) revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61通常,前几位即可git revert c011eb3 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同.第一:上面我们说的如果你已经push到线上代码库, reset 删除指定commit以后,你git push可能导致一大堆冲突.但是revert 并不会.第二:如果在日后现有分支和历史分支需要合并的时候,reset 恢复部分的代码依然会出现在历史分支里.但是revert 方向提交的commit 并不会出现在历史分支里.第三:reset 是在正常的commit历史中,删除了指定的commit,这时 HEAD 是向后移动了,而 revert 是在正常的commit历史中再commit一次,只不过是反向提交,他的 HEAD 是一直向前的.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[componentWillReceiveProps详解（this.props）状态改变检测机制]]></title>
    <url>%2F2019%2F03%2F29%2FcomponentWillReceiveProps%E8%AF%A6%E8%A7%A3%EF%BC%88this.props%EF%BC%89%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[关于组件挂载的经典的图片： 下面一一说一下这几个生命周期的意义： getDefaultPropsobject getDefaultProps()执行过一次后，被创建的类会有缓存，映射的值会存在this.props,前提是这个prop不是父组件指定的这个方法在对象被创建之前执行，因此不能在方法内调用this.props ，另外，注意任何getDefaultProps()返回的对象在实例中共享，不是复制 getInitialStateobject getInitialState()控件加载之前执行，返回值会被用于state的初始化值 componentWillMountvoid componentWillMount()执行一次，在初始化render之前执行，如果在这个方法内调用setState，render()知道state发生变化，并且只执行一次 renderReactElement render()render的时候会调用render()会被调用调用render()方法时，首先检查this.props和this.state返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现如果不想渲染可以返回null或者false，这种场景下，react渲染一个\&lt;noscript>标签，当返回null或者false时，ReactDOM.findDOMNode(this)返回nullrender()方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互，如果必须如服务器交互，在componentDidMount()方法中实现或者其他生命周期的方法中实现，保持render()方法纯净使得服务器更准确，组件更简单 componentDidMountvoid componentDidMount()在初始化render之后只执行一次，在这个方法内，可以访问任何组件，componentDidMount()方法中的子组件在父组件之前执行从这个函数开始，就可以和 js 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求 shouldComponentUpdateboolean shouldComponentUpdate( object nextProps, object nextState}这个方法在初始化render时不会执行，当props或者state发生变化时执行，并且是在render之前，当新的props或者state不需要更新组件时，返回falseshouldComponentUpdate: function(nextProps, nextState) { return nextProps.id !== this.props.id;}当shouldComponentUpdate方法返回false时，就不会执行render()方法，componentWillUpdate和componentDidUpdate方法也不会被调用默认情况下，shouldComponentUpdate方法返回true防止state快速变化时的问题，但是如果·state不变，props只读，可以直接覆盖shouldComponentUpdate用于比较props和state的变化，决定UI是否更新，当组件比较多时，使用这个方法能有效提高应用性能 componentWillUpdatevoid componentWillUpdate( object nextProps, object nextState)当props和state发生变化时执行，并且在render方法之前执行，当然初始化render时不执行该方法，需要特别注意的是，在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。紧接着这个函数，就会调用render()来更新界面了 componentDidUpdatevoid componentDidUpdate( object prevProps, object prevState)组件更新结束之后执行，在初始化render时不执行 componentWillReceivePropsvoid componentWillReceiveProps( object nextProps)当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用componentWillReceiveProps: function(nextProps) { this.setState({likesIncreasing: nextProps.likeCount > this.props.likeCount });} componentWillUnmountvoid componentWillUnmount()当组件要被从界面上移除的时候，就会调用componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>componentWillReceiveProps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[add host]]></title>
    <url>%2F2019%2F03%2F29%2Fadd_host%2F</url>
    <content type="text"><![CDATA[配置免密登录ssh-copy-id &lt;新节点的IP&gt; 基础环境 关闭selinux 12sed -i &apos;/SELINUX/s/enforcing/disabled/&apos; /etc/selinux/configsetenforce 0 关闭防火墙 12systemctl stop firewalld.servicsystemctl disable firewalld.service 将IP写入/etc/mesos-slave/hostname中： 1234567vim /etc/mesos-slave/hostnamefitech01 xxx.xxx.xxx.xxxfitech02 xxx.xxx.xxx.xxxfitech03 xxx.xxx.xxx.xxxfitech04 xxx.xxx.xxx.xxx... 在主节点上配置主节点到新增节点的免密码登录 1fitech01: ssh-copy-id agent4 Docker 安装必要的packages 123sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 配置阿里镜像源 123sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker 1yum install docker-ce 更新daemon.json 12vim /etc/docker/daemon.json# 内容和其他节点的 /etc/docker/daemon.json 相同 开启docker服务 1systemctl start docker GlusterFS 安装依赖 123456yum install glusterfsyum install glusterfs-cliyum install glusterfs-libsyum install glusterfs-serveryum install glusterfs-fuseyum install glusterfs-geo-replication 挂载gluster卷 1234mkdir -p /data/replica # 这个文件夹存储内容会做副本mkdir -p /data/mnt # 这个文件夹存储内容是分布式的mount -t glusterfs fitech01:volume1 /data/replica # volume1 还是 volume2 挂到这个位置忘记了，去其他机器上df -h 看一看mount -t glusterfs fitech01:volume2 /data/mnt Mesos 添加mesos的yum源 1rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm 安装Mesos1.5.0 1yum install -y mesos 配置Mesos 1vim /etc/default/mesos-slave #内容和其他节点相同，其中有个 export MESOS_ip 注意填当前节点的 IP 配置marathon调用mesos运行docker容器 1echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers 启动slave 1systemctl enable mesos-slave &amp;&amp; systemctl start mesos-slave 配置完毕后，去 fitech01:5050 上看 agent 页面是否增加了新增的节点]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>mesos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全文搜索引擎 Elasticsearch 入门教程]]></title>
    <url>%2F2019%2F03%2F29%2F%5B%E8%BD%AC%5D%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%20Elasticsearch%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文转载自：阮一峰的网络日志 全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 Elastic）是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。 Elastic 的底层是开源库Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。 一、安装Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考这篇文章，注意要保证环境变量JAVA_HOME正确设置。安装完 Java，就可以跟着官方文档安装 Elastic。直接下载压缩包比较简单。 123$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip$ unzip elasticsearch-5.5.1.zip$ cd elasticsearch-5.5.1/ 接着，进入解压后的目录，运行下面的命令，启动 Elastic。 1$ ./bin/elasticsearch 如果这时报错”max virtual memory areas vm.maxmapcount 65530 is too low”，要运行下面的命令。 1$ sudo sysctl -w vm.max_map_count=262144 如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。 123456789101112131415$ curl localhost:9200&#123; "name" : "atntrTf", "cluster_name" : "elasticsearch", "cluster_uuid" : "tf9250XhQ6ee4h7YI11anA", "version" : &#123;"number" : "5.5.1","build_hash" : "19c13d0","build_date" : "2017-07-18T20:44:24.823Z","build_snapshot" : false,"lucene_version" : "6.6.0" &#125;, "tagline" : "You Know, for Search"&#125; 上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。按下 Ctrl + C，Elastic 就会停止运行。默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动 Elastic。network.host: 0.0.0.0上面代码中，设成0.0.0.0让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。 二、基本概念2.1 Node 与 ClusterElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 2.2 IndexElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。下面的命令可以查看当前节点的所有 Index。 1$ curl -X GET 'http://localhost:9200/_cat/indices?v' 2.3 DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示，下面是一个例子。 12345&#123; "user": "张三", "title": "工程师", "desc": "数据库管理"&#125; 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 2.4 TypeDocument 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。下面的命令可以列出每个 Index 所包含的 Type。 1$ curl 'localhost:9200/_mapping?pretty=true' 根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。 三、新建和删除 Index新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。 1$ curl -X PUT 'localhost:9200/weather' 服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。 1234&#123; "acknowledged":true, "shards_acknowledged":true&#125; 然后，我们发出 DELETE 请求，删除这个 Index。$ curl -X DELETE ‘localhost:9200/weather’ 四、中文分词设置首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。 1$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip 上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。接着，重新启动 Elastic，就会自动加载这个新安装的插件。然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。 123456789101112131415161718192021222324$ curl -X PUT 'localhost:9200/accounts' -d '&#123; "mappings": &#123;"person": &#123; "properties": &#123;"user": &#123; "type": "text", "analyzer": "ik_max_word", "search_analyzer": "ik_max_word"&#125;,"title": &#123; "type": "text", "analyzer": "ik_max_word", "search_analyzer": "ik_max_word"&#125;,"desc": &#123; "type": "text", "analyzer": "ik_max_word", "search_analyzer": "ik_max_word"&#125; &#125;&#125; &#125;&#125;' 上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。usertitledesc这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。Elastic 的分词器称为 analyzer。我们对每个字段指定分词器。 12345"user": &#123; "type": "text", "analyzer": "ik_max_word", "search_analyzer": "ik_max_word"&#125; 上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。 五、数据操作5.1 新增记录向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。 123456$ curl -X PUT 'localhost:9200/accounts/person/1' -d '&#123; "user": "张三", "title": "工程师", "desc": "数据库管理"&#125;' 服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。 123456789&#123; "_index":"accounts", "_type":"person", "_id":"1", "_version":1, "result":"created", "_shards":&#123;"total":2,"successful":1,"failed":0&#125;, "created":true&#125; 如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。 123456$ curl -X POST 'localhost:9200/accounts/person' -d '&#123; "user": "李四", "title": "工程师", "desc": "系统管理"&#125;' 上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。 123456789&#123; "_index":"accounts", "_type":"person", "_id":"AV3qGfrC6jMbsbXb6k1p", "_version":1, "result":"created", "_shards":&#123;"total":2,"successful":1,"failed":0&#125;, "created":true&#125; 注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。 5.2 查看记录向/Index/Type/Id发出 GET 请求，就可以查看这条记录。 1$ curl 'localhost:9200/accounts/person/1?pretty=true' 上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。返回的数据中，found字段表示查询成功，_source字段返回原始记录。 123456789101112&#123; "_index" : "accounts", "_type" : "person", "_id" : "1", "_version" : 1, "found" : true, "_source" : &#123;"user" : "张三","title" : "工程师","desc" : "数据库管理" &#125;&#125; 如果 Id 不正确，就查不到数据，found字段就是false。 12345678$ curl 'localhost:9200/weather/beijing/abc?pretty=true'&#123; "_index" : "accounts", "_type" : "person", "_id" : "abc", "found" : false&#125; 5.3 删除记录删除记录就是发出 DELETE 请求。 1$ curl -X DELETE 'localhost:9200/accounts/person/1' 这里先不要删除这条记录，后面还要用到。 5.4 更新记录更新记录就是使用 PUT 请求，重新发送一次数据。 12345678910111213141516$ curl -X PUT 'localhost:9200/accounts/person/1' -d '&#123;"user" : "张三","title" : "工程师","desc" : "数据库管理，软件开发"&#125;' &#123; "_index":"accounts", "_type":"person", "_id":"1", "_version":2, "result":"updated", "_shards":&#123;"total":2,"successful":1,"failed":0&#125;, "created":false&#125; 上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。 123"_version" : 2,"result" : "updated","created" : false 可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。 六、数据查询6.1 返回所有记录使用 GET 方法，直接请求/Index/Type/search，就会返回所有记录。 1234567891011121314151617181920212223242526272829303132333435$ curl 'localhost:9200/accounts/person/_search'&#123; "took":2, "timed_out":false, "_shards":&#123;"total":5,"successful":5,"failed":0&#125;, "hits":&#123;"total":2,"max_score":1.0,"hits":[ &#123;"_index":"accounts","_type":"person","_id":"AV3qGfrC6jMbsbXb6k1p","_score":1.0,"_source": &#123; "user": "李四", "title": "工程师", "desc": "系统管理"&#125; &#125;, &#123;"_index":"accounts","_type":"person","_id":"1","_score":1.0,"_source": &#123; "user" : "张三", "title" : "工程师", "desc" : "数据库管理，软件开发"&#125; &#125;] &#125;&#125; 上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。total：返回记录数，本例是2条。max_score：最高的匹配程度，本例是1.0。hits：返回的记录组成的数组。返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。 6.2 全文搜索Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。 1234$ curl 'localhost:9200/accounts/person/_search' -d '&#123; "query" : &#123; "match" : &#123; "desc" : "软件" &#125;&#125;&#125;' 上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含”软件”这个词。返回结果如下。 12345678910111213141516171819202122&#123; "took":3, "timed_out":false, "_shards":&#123;"total":5,"successful":5,"failed":0&#125;, "hits":&#123;"total":1,"max_score":0.28582606,"hits":[ &#123;"_index":"accounts","_type":"person","_id":"1","_score":0.28582606,"_source": &#123; "user" : "张三", "title" : "工程师", "desc" : "数据库管理，软件开发"&#125; &#125;] &#125;&#125; Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。 12345$ curl 'localhost:9200/accounts/person/_search' -d '&#123; "query" : &#123; "match" : &#123; "desc" : "管理" &#125;&#125;, "size": 1&#125;' 上面代码指定，每次只返回一条结果。还可以通过from字段，指定位移。 123456$ curl 'localhost:9200/accounts/person/_search' -d '&#123; "query" : &#123; "match" : &#123; "desc" : "管理" &#125;&#125;, "from": 1, "size": 1&#125;' 上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。 6.3 逻辑运算如果有多个搜索关键字， Elastic 认为它们是or关系。 1234$ curl 'localhost:9200/accounts/person/_search' -d '&#123; "query" : &#123; "match" : &#123; "desc" : "软件 系统" &#125;&#125;&#125;' 上面代码搜索的是软件 or 系统。如果要执行多个关键词的and搜索，必须使用布尔查询。 1234567891011$ curl 'localhost:9200/accounts/person/_search' -d '&#123; "query": &#123;"bool": &#123; "must": [&#123; "match": &#123; "desc": "软件" &#125; &#125;,&#123; "match": &#123; "desc": "系统" &#125; &#125; ]&#125; &#125;&#125;' 七、参考链接&nbsp;&nbsp; &nbsp;&nbsp; ElasticSearch 官方手册&nbsp;&nbsp; &nbsp;&nbsp; A Practical Introduction to Elasticsearch （完）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>全文搜索</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SocialCalc即时渲染]]></title>
    <url>%2F2019%2F03%2F29%2FSocialCalc%E5%8D%B3%E6%97%B6%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[SocialCalc即时渲染简介作者：DanBricklin 源码地址： https://github.com/DanBricklin/socialcalc 使用技术： JavaScript+HTML+CSS 主界面截图: 初始化sheet 创建sheet 1SocialCalc.CreateTableEditor = function (editor, width, height) &#123;&#125; 一、初始化参数12345678910111213141516var scc = SocialCalc.Constants;var AssignID = SocialCalc.AssignID;editor.toplevel = document.createElement("div");editor.width = width;editor.height = height;editor.griddiv = document.createElement("div");editor.tablewidth = width - scc.defaultTableControlThickness;editor.tableheight = height - scc.defaultTableControlThickness;editor.griddiv.style.width = editor.tablewidth + "px";editor.griddiv.style.height = editor.tableheight + "px";editor.griddiv.style.overflow = "hidden";editor.griddiv.style.cursor = "default";if (scc.cteGriddivClass) editor.griddiv.className = scc.cteGriddivClass;AssignID(editor, editor.griddiv, "griddiv"); 二、适配屏幕大小，设置页面显示行数、列数1editor.FitToEditTable(); ​ 核心代码 123456789101112131415161718192021222324252627282930totalwidth = context.showRCHeaders ? context.rownamewidth - 0 : 0;for (colpane = 0; colpane &lt; context.colpanes.length - 1; colpane++) &#123; // Get width of all but last pane for (colnum = context.colpanes[colpane].first; colnum &lt;= context.colpanes[colpane].last; colnum++) &#123; colname = SocialCalc.rcColname(colnum); colwidth = sheetobj.colattribs.width[colname] || sheetobj.attribs.defaultcolwidth || SocialCalc.Constants.defaultColWidth; if (colwidth == "blank" || colwidth == "auto") colwidth = ""; totalwidth += (colwidth &amp;&amp; ((colwidth - 0) &gt; 0)) ? (colwidth - 0) : 10; &#125;&#125;for (colnum = context.colpanes[colpane].first; colnum &lt;= 10000; colnum++) &#123; //!!! max for safety, but makes that col max!!! colname = SocialCalc.rcColname(colnum); colwidth = sheetobj.colattribs.width[colname] || sheetobj.attribs.defaultcolwidth || SocialCalc.Constants.defaultColWidth; if (colwidth == "blank" || colwidth == "auto") colwidth = ""; totalwidth += (colwidth &amp;&amp; ((colwidth - 0) &gt; 0)) ? (colwidth - 0) : 10; if (totalwidth &gt; editor.tablewidth) break;&#125;context.colpanes[colpane].last = colnum;// Calculate row height datatotalrows = context.showRCHeaders ? 1 : 0;for (rowpane = 0; rowpane &lt; context.rowpanes.length - 1; rowpane++) &#123; // count all panes but last one totalrows += context.rowpanes[rowpane].last - context.rowpanes[rowpane].first + 1;&#125;needed = editor.tableheight - totalrows * context.pixelsPerRow; // estimate amount neededcontext.rowpanes[rowpane].last = context.rowpanes[rowpane].first + Math.floor(needed / context.pixelsPerRow) + 1; 三、渲染sheet，更新fullgrid1editor.EditorRenderSheet(); 12345678910111213SocialCalc.EditorRenderSheet = function (editor) &#123; editor.EditorMouseUnregister(); editor.fullgrid = editor.context.RenderSheet(editor.fullgrid); if (editor.ecell) editor.SetECellHeaders("selected"); SocialCalc.AssignID(editor, editor.fullgrid, "fullgrid"); // give it an id editor.EditorMouseRegister();&#125; 1、取消editor鼠标事件2、渲染sheet​ 一系列的sheet渲染操作，代码略 3、配置当前选中cell4、为fullgrid分配id5、重新注册editor鼠标事件​ 设置鼠标单击、双击等事件 12345678if (element.addEventListener) &#123; // DOM Level 2 -- Firefox, et al element.addEventListener("mousedown", SocialCalc.ProcessEditorMouseDown, false); element.addEventListener("dblclick", SocialCalc.ProcessEditorDblClick, false);&#125;else if (element.attachEvent) &#123; // IE 5+ element.attachEvent("onmousedown", SocialCalc.ProcessEditorMouseDown); element.attachEvent("ondblclick", SocialCalc.ProcessEditorDblClick);&#125; 四、添加fullgrid节点1editor.griddiv.appendChild(editor.fullgrid); 五、纵向、横向滚动条配置1234567891011//纵向滚动条配置editor.verticaltablecontrol = new SocialCalc.TableControl(editor, true, editor.tableheight);editor.verticaltablecontrol.CreateTableControl();AssignID(editor, editor.verticaltablecontrol.main, "tablecontrolv");//横向滚动条配置editor.horizontaltablecontrol = new SocialCalc.TableControl(editor, false, editor.tablewidth);editor.horizontaltablecontrol.CreateTableControl();AssignID(editor, editor.horizontaltablecontrol.main, "tablecontrolh"); 六、table配置及渲染12345678910111213141516var table, tbody, tr, td, img, anchor, ta;table = document.createElement("table");editor.layouttable = table;table.cellSpacing = 0;table.cellPadding = 0;AssignID(editor, table, "layouttable");tbody = document.createElement("tbody");table.appendChild(tbody);//tabletr = document.createElement("tr");tbody.appendChild(tr);td = document.createElement("td");td.appendChild(editor.griddiv);tr.appendChild(td); 七、纵向、横向滚动条渲染123456789101112131415161718//纵向滚动条td = document.createElement("td");td.appendChild(editor.verticaltablecontrol.main);tr.appendChild(td);//横向滚动条tr = document.createElement("tr");tbody.appendChild(tr);td = document.createElement("td");td.appendChild(editor.horizontaltablecontrol.main);tr.appendChild(td);td = document.createElement("td"); // logo display: Required by CPAL License for this code!td.style.background = "url(" + editor.imageprefix + "logo.gif) no-repeat center center";td.innerHTML = "&lt;div style='cursor:pointer;font-size:1px;'&gt;&lt;img src='" + editor.imageprefix + "1x1.gif' border='0' width='18' height='18'&gt;&lt;/div&gt;";tr.appendChild(td);editor.logo = td;AssignID(editor, editor.logo, "logo");SocialCalc.TooltipRegister(td.firstChild.firstChild, "SocialCalc", null); 八、添加table节点1editor.toplevel.appendChild(editor.layouttable); 九、添加滚动条监听事件，实现滚动即时渲染123// sheet滚动操作 重点*****SocialCalc.MouseWheelRegister(editor.toplevel, &#123;WheelMove: SocialCalc.EditorProcessMouseWheel, editor: editor&#125;); 1、实现流程：2.1、将监听节点放入监听数组中12345var mousewheelinfo = SocialCalc.MouseWheelInfo;mousewheelinfo.registeredElements.push( &#123;element: element, functionobj: functionobj&#125;); 1.2、兼容浏览器配置监听事件ProcessMouseWheel12345678910if (element.addEventListener) &#123; // DOM Level 2 -- Firefox, et al element.addEventListener("DOMMouseScroll", SocialCalc.ProcessMouseWheel, false); element.addEventListener("mousewheel", SocialCalc.ProcessMouseWheel, false); // Opera needs this&#125;else if (element.attachEvent) &#123; // IE 5+ element.attachEvent("onmousewheel", SocialCalc.ProcessMouseWheel);&#125;else &#123; // don't handle this throw SocialCalc.Constants.s_BrowserNotSupported;&#125; 1.2.1监听事件ProcessMouseWheel流程1、获取滚动滚动对象event、滚动个数delta、鼠标滚动信息mousewheelinfo、sheet等对象信息wobj 2、调用WheelMove方法，即SocialCalc.EditorProcessMouseWheel方法，见下2.2 12345678910111213141516171819202122232425262728SocialCalc.ProcessMouseWheel = function (e) &#123; var event = e || window.event; var delta; if (SocialCalc.Keyboard.passThru) return; // ignore var mousewheelinfo = SocialCalc.MouseWheelInfo; var ele = event.target || event.srcElement; // source object is often within what we want var wobj; for (wobj = null; !wobj &amp;&amp; ele; ele = ele.parentNode) &#123; // go up tree looking for one of our elements wobj = SocialCalc.LookupElement(ele, mousewheelinfo.registeredElements); &#125; if (!wobj) return; // not one of our elements if (event.wheelDelta) &#123; delta = event.wheelDelta / 120; &#125; else delta = -event.detail / 3; if (!delta) delta = 0; if (wobj.functionobj &amp;&amp; wobj.functionobj.WheelMove) wobj.functionobj.WheelMove(event, delta, mousewheelinfo, wobj); if (event.preventDefault) event.preventDefault(); event.returnValue = false;&#125; 2、其中参数：2.1、editor.toplevel2.2、WheelMove:SocialCalc.EditorProcessMouseWheel2.2.1 判断editor此时状态，true则返回2.2.2 sheet滚动处理123456789101112SocialCalc.EditorProcessMouseWheel = function (event, delta, mousewheelinfo, wobj) &#123; if (wobj.functionobj.editor.busy) return; // ignore if busy if (delta &gt; 0) &#123; wobj.functionobj.editor.ScrollRelative(true, -1); &#125; if (delta &lt; 0) &#123; wobj.functionobj.editor.ScrollRelative(true, +1); &#125;&#125; 2.2.3 判断滚动方式为垂直还是水平，垂直则上下加减1，水平则左右加减11234567891011SocialCalc.ScrollRelative = function (editor, vertical, amount) &#123; if (vertical) &#123; editor.ScrollRelativeBoth(amount, 0); &#125; else &#123; editor.ScrollRelativeBoth(0, amount); &#125; return;&#125; 2.2.4 调用ScrollRelativeBoth，处理横向、纵向滚动及渲染操作12345678910111213141516171819202122232425262728293031323334353637383940SocialCalc.ScrollRelativeBoth = function (editor, vamount, hamount) &#123; var context = editor.context; var vplen = context.rowpanes.length; var vlimit = vplen &gt; 1 ? context.rowpanes[vplen - 2].last + 1 : 1; // don't scroll past here 不要在这里滚动 if (context.rowpanes[vplen - 1].first + vamount &lt; vlimit) &#123; // limit amount vamount = (-context.rowpanes[vplen - 1].first) + vlimit; &#125; var hplen = context.colpanes.length; var hlimit = hplen &gt; 1 ? context.colpanes[hplen - 2].last + 1 : 1; // don't scroll past here if (context.colpanes[hplen - 1].first + hamount &lt; hlimit) &#123; // limit amount hamount = (-context.colpanes[hplen - 1].first) + hlimit; &#125; if ((vamount == 1 || vamount == -1) &amp;&amp; hamount == 0) &#123; // special case quick scrolls 针对快速滚动的情况 if (vamount == 1) &#123; editor.ScrollTableUpOneRow(); &#125; else &#123; editor.ScrollTableDownOneRow(); &#125; if (editor.ecell) editor.SetECellHeaders("selected"); editor.SchedulePositionCalculations(); return; &#125; // Do a gross move and render 做一个总的滚动和渲染操作 if (vamount != 0 || hamount != 0) &#123; context.rowpanes[vplen - 1].first += vamount; context.rowpanes[vplen - 1].last += vamount; context.colpanes[hplen - 1].first += hamount; context.colpanes[hplen - 1].last += hamount; editor.FitToEditTable(); editor.ScheduleRender(); &#125;&#125; 2.3、editor​ sheet编辑对象，存放参数、方法等]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>SocialCalc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SocialCalc即时渲染-高宽处理]]></title>
    <url>%2F2019%2F03%2F29%2FSocialCalc%E5%8D%B3%E6%97%B6%E6%B8%B2%E6%9F%93-%E9%AB%98%E5%AE%BD%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[SocialCalc即时渲染-高宽处理一、主页面socialcalc2demo-0-8-1.html调用1spreadsheet.InitializeSpreadsheetControl("tableeditor"); 二、调用socialcalcspreadsheetcontrol中InitializeSpreadsheetControl方法123SocialCalc.SpreadsheetControl.prototype.InitializeSpreadsheetControl = function (node, height, width, spacebelow) &#123; return SocialCalc.InitializeSpreadsheetControl(this, node, height, width, spacebelow);&#125;; 1SocialCalc.InitializeSpreadsheetControl = function (spreadsheet, node, height, width, spacebelow)&#123;&#125; 1、初始化requestedHeight、requestedWidth、requestedSpaceBelow，方法中height、width、spacebelow均为undefined123spreadsheet.requestedHeight = height;spreadsheet.requestedWidth = width;spreadsheet.requestedSpaceBelow = spacebelow; 2、计算主页面高度、宽度1spreadsheet.SizeSSDiv(); // calculate and fill in the size values 2.1、得到spreadsheet.height整个页面高度，spreadsheet.width整个页面宽度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455SocialCalc.SizeSSDiv = function (spreadsheet) &#123; // console.log('SizeSSDiv........') var sizes, pos, resized, nodestyle, newval; var fudgefactorX = 10; // for IE var fudgefactorY = 10; resized = false; //result.width = window.innerWidth; //result.height = window.innerHeight; //result.horizontalScroll = window.pageXOffset; //result.verticalScroll = window.pageYOffset; sizes = SocialCalc.GetViewportInfo(); pos = SocialCalc.GetElementPosition(spreadsheet.parentNode); pos.bottom = 0; pos.right = 0; nodestyle = spreadsheet.parentNode.style; if (nodestyle.marginTop) &#123; pos.top += nodestyle.marginTop.slice(0, -2) - 0; &#125; if (nodestyle.marginBottom) &#123; pos.bottom += nodestyle.marginBottom.slice(0, -2) - 0; &#125; if (nodestyle.marginLeft) &#123; pos.left += nodestyle.marginLeft.slice(0, -2) - 0; &#125; if (nodestyle.marginRight) &#123; pos.right += nodestyle.marginRight.slice(0, -2) - 0; &#125; //计算主页面高度 newval = spreadsheet.requestedHeight || sizes.height - (pos.top + pos.bottom + fudgefactorY) - (spreadsheet.requestedSpaceBelow || 0); if (spreadsheet.height != newval) &#123; spreadsheet.height = newval; spreadsheet.spreadsheetDiv.style.height = newval + "px"; resized = true; &#125; //计算主页面宽度 newval = spreadsheet.requestedWidth || sizes.width - (pos.left + pos.right + fudgefactorX) || 700; if (spreadsheet.width != newval) &#123; spreadsheet.width = newval; spreadsheet.spreadsheetDiv.style.width = newval + "px"; resized = true; &#125; return resized;&#125; 3、计算表格宽度、高度1234567891011// create sheet view and others // spreadsheet.statuslineheight // spreadsheet.spreadsheetDiv.firstChild.offsetHeight-工具栏高度 // spreadsheet.spreadsheetDiv.lastChild.offsetHeight-公式框高度 spreadsheet.nonviewheight = spreadsheet.statuslineheight + spreadsheet.spreadsheetDiv.firstChild.offsetHeight + spreadsheet.spreadsheetDiv.lastChild.offsetHeight; spreadsheet.viewheight = spreadsheet.height - spreadsheet.nonviewheight; // spreadsheet.width = width // spreadsheet.viewheight = height spreadsheet.editorDiv = spreadsheet.editor.CreateTableEditor(spreadsheet.width, spreadsheet.viewheight); 三、调用CreateTableEditor方法渲染sheet1SocialCalc.CreateTableEditor = function (editor, width, height) &#123;&#125; 1、初始化参数12345678910111213141516171819var scc = SocialCalc.Constants;var AssignID = SocialCalc.AssignID;// spreadsheet.width = width// spreadsheet.viewheight = heighteditor.toplevel = document.createElement("div");editor.width = width;editor.height = height;editor.griddiv = document.createElement("div");//scc.defaultTableControlThickness滚动条的大小editor.tablewidth = width - scc.defaultTableControlThickness;editor.tableheight = height - scc.defaultTableControlThickness;editor.griddiv.style.width = editor.tablewidth + "px";editor.griddiv.style.height = editor.tableheight + "px";editor.griddiv.style.overflow = "hidden";editor.griddiv.style.cursor = "default";if (scc.cteGriddivClass) editor.griddiv.className = scc.cteGriddivClass;AssignID(editor, editor.griddiv, "griddiv"); 2、适配屏幕大小，设置页面显示行数、列数1editor.FitToEditTable(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051SocialCalc.FitToEditTable = function (editor) &#123; // console.log('FitToEditTable............') var colnum, colname, colwidth, totalwidth, totalrows, rowpane, needed; var context = editor.context; var sheetobj = context.sheetobj; // var sheetcolattribs = sheetobj.colattribs; // 计算列宽 // context.showRCHeaders 是否展示首行首列 // ontext.rownamewidth 首列宽度 // totalwidth 需要显示的表格宽度 totalwidth = context.showRCHeaders ? context.rownamewidth - 0 : 0; //获取除了最后一个单元格的总宽度 for (colpane = 0; colpane &lt; context.colpanes.length - 1; colpane++) &#123; // Get width of all but last pane for (colnum = context.colpanes[colpane].first; colnum &lt;= context.colpanes[colpane].last; colnum++) &#123; // 获取该单元格name colname = SocialCalc.rcColname(colnum); // 获取该单元格width colwidth = sheetobj.colattribs.width[colname] || sheetobj.attribs.defaultcolwidth || SocialCalc.Constants.defaultColWidth; if (colwidth == "blank" || colwidth == "auto") colwidth = ""; totalwidth += (colwidth &amp;&amp; ((colwidth - 0) &gt; 0)) ? (colwidth - 0) : 10; &#125; &#125; for (colnum = context.colpanes[colpane].first; colnum &lt;= 10000; colnum++) &#123; //!!! max for safety, but makes that col max!!! // 获取该单元格name colname = SocialCalc.rcColname(colnum); // 获取该单元格width colwidth = sheetobj.colattribs.width[colname] || sheetobj.attribs.defaultcolwidth || SocialCalc.Constants.defaultColWidth; if (colwidth == "blank" || colwidth == "auto") colwidth = ""; // 计算需要显示的表格宽度 totalwidth += (colwidth &amp;&amp; ((colwidth - 0) &gt; 0)) ? (colwidth - 0) : 10; // 当totalwidth大于实际宽度editor.tablewidth时结束，此时colnum即为最后colnum if (totalwidth &gt; editor.tablewidth) break; &#125; context.colpanes[colpane].last = colnum; // 计算行高 // context.showRCHeaders 是否显示首行首列 totalrows = context.showRCHeaders ? 1 : 0; for (rowpane = 0; rowpane &lt; context.rowpanes.length - 1; rowpane++) &#123; // count all panes but last one totalrows += context.rowpanes[rowpane].last - context.rowpanes[rowpane].first + 1; &#125; // pixelsPerRow 默认行高 needed = editor.tableheight - totalrows * context.pixelsPerRow; // estimate amount needed context.rowpanes[rowpane].last = context.rowpanes[rowpane].first + Math.floor(needed / context.pixelsPerRow) + 1;&#125; 四、添加滚动条监听事件，实现滚动即时渲染123// sheet滚动操作SocialCalc.MouseWheelRegister(editor.toplevel, &#123;WheelMove: SocialCalc.EditorProcessMouseWheel, editor: editor&#125;); 1、配置鼠标滚动监听事件123456789101112131415161718192021 SocialCalc.MouseWheelRegister = function (element, functionobj) &#123; var mousewheelinfo = SocialCalc.MouseWheelInfo; mousewheelinfo.registeredElements.push( &#123;element: element, functionobj: functionobj&#125; ); if (element.addEventListener) &#123; // DOM Level 2 -- Firefox, et al element.addEventListener("DOMMouseScroll", SocialCalc.ProcessMouseWheel, false); element.addEventListener("mousewheel", SocialCalc.ProcessMouseWheel, false); // Opera needs this &#125; else if (element.attachEvent) &#123; // IE 5+ element.attachEvent("onmousewheel", SocialCalc.ProcessMouseWheel); &#125; else &#123; // don't handle this throw SocialCalc.Constants.s_BrowserNotSupported; &#125; return;&#125;xxxxxxxxxx var mousewheelinfo = SocialCalc.MouseWheelInfo;mousewheelinfo.registeredElements.push( &#123;element: element, functionobj: functionobj&#125;); 2、监听事件ProcessMouseWheel1、获取滚动滚动对象event、滚动个数delta、鼠标滚动信息mousewheelinfo、sheet等对象信息wobj 2、调用WheelMove方法，即SocialCalc.EditorProcessMouseWheel方法，见下2.2 12345678910111213141516171819202122232425262728SocialCalc.ProcessMouseWheel = function (e) &#123; var event = e || window.event; var delta; if (SocialCalc.Keyboard.passThru) return; // ignore var mousewheelinfo = SocialCalc.MouseWheelInfo; var ele = event.target || event.srcElement; // source object is often within what we want var wobj; for (wobj = null; !wobj &amp;&amp; ele; ele = ele.parentNode) &#123; // go up tree looking for one of our elements wobj = SocialCalc.LookupElement(ele, mousewheelinfo.registeredElements); &#125; if (!wobj) return; // not one of our elements if (event.wheelDelta) &#123; delta = event.wheelDelta / 120; &#125; else delta = -event.detail / 3; if (!delta) delta = 0; if (wobj.functionobj &amp;&amp; wobj.functionobj.WheelMove) wobj.functionobj.WheelMove(event, delta, mousewheelinfo, wobj); if (event.preventDefault) event.preventDefault(); event.returnValue = false;&#125; 2、其中参数：2.1、editor.toplevel2.2、WheelMove:SocialCalc.EditorProcessMouseWheel2.2.1 判断editor此时状态，true则返回2.2.2 sheet滚动处理123456789101112SocialCalc.EditorProcessMouseWheel = function (event, delta, mousewheelinfo, wobj) &#123; if (wobj.functionobj.editor.busy) return; // ignore if busy if (delta &gt; 0) &#123; wobj.functionobj.editor.ScrollRelative(true, -1); &#125; if (delta &lt; 0) &#123; wobj.functionobj.editor.ScrollRelative(true, +1); &#125;&#125; 2.2.3 判断滚动方式为垂直还是水平，垂直则上下加减1，水平则左右加减11234567891011SocialCalc.ScrollRelative = function (editor, vertical, amount) &#123; if (vertical) &#123; editor.ScrollRelativeBoth(amount, 0); &#125; else &#123; editor.ScrollRelativeBoth(0, amount); &#125; return;&#125; 2.2.4 调用ScrollRelativeBoth，处理横向、纵向滚动及渲染操作1234567891011121314151617181920212223242526272829303132333435363738394041424344// ScrollRelativeBoth(editor, vamount, hamount)//// 垂直、横向滚动通用渲染（包括处理行、列冻结）SocialCalc.ScrollRelativeBoth = function (editor, vamount, hamount) &#123; var context = editor.context; // vplen为rowpanes参数个数，无冻结为1，冻结为2，数据中第一个为冻结参数，第二个为非冻结参数 var vplen = context.rowpanes.length; // 处理向上滚动到表格顶部或者冻结区域的情况 var vlimit = vplen &gt; 1 ? context.rowpanes[vplen - 2].last + 1 : 1; // 不要在这里滚动 行冻结 if (context.rowpanes[vplen - 1].first + vamount &lt; vlimit) &#123; // 限制数量，滚动后的first小于vlimit vamount = (-context.rowpanes[vplen - 1].first) + vlimit; &#125; var hplen = context.colpanes.length; var hlimit = hplen &gt; 1 ? context.colpanes[hplen - 2].last + 1 : 1; // 不要在这里滚动 列冻结 if (context.colpanes[hplen - 1].first + hamount &lt; hlimit) &#123; // 限制数量，滚动后的first小于vlimit hamount = (-context.colpanes[hplen - 1].first) + hlimit; &#125; if ((vamount == 1 || vamount == -1) &amp;&amp; hamount == 0) &#123; // 针对特别快速的滚动 special case quick scrolls if (vamount == 1) &#123; editor.ScrollTableUpOneRow(); &#125; else &#123; editor.ScrollTableDownOneRow(); &#125; if (editor.ecell) editor.SetECellHeaders("selected"); editor.SchedulePositionCalculations(); return; &#125; // 做一个总的滚动动作和渲染 if (vamount != 0 || hamount != 0) &#123; // 更新rowpanes、colpanes context.rowpanes[vplen - 1].first += vamount; context.rowpanes[vplen - 1].last += vamount; context.colpanes[hplen - 1].first += hamount; context.colpanes[hplen - 1].last += hamount; editor.FitToEditTable(); editor.ScheduleRender(); &#125;&#125; 2.3、editor​ sheet编辑对象，存放参数、方法等 3、滚动后重新渲染​ 1、根据context.rowpanes、context.colpanes获取到冻结行、非冻结行、冻结列、非冻结列的信息，并从单元格数据集中获取对应的单元格数据渲染出来]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>SocialCalc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React总结]]></title>
    <url>%2F2019%2F03%2F29%2FReact%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[做React需要会什么？react的功能其实很单一，主要负责渲染的功能，现有的框架，比如angular是一个大而全的框架，用了angular几乎就不需要用其他工具辅助配合，但是react不一样，他只负责ui渲染，想要做好一个项目，往往需要其他库和工具的配合，比如用redux来管理数据，react-router管理路由，react已经全面拥抱es6，所以es6也得掌握，webpack就算是不会配置也要会用，要想提高性能，需要按需加载，immutable.js也得用上，还有单元测试。。。。 React 是什么用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。因为这个原因react的虚拟dom就显得难能可贵了，它创造了虚拟dom并且将它们储存起来，每当状态发生变化的时候就会创造新的虚拟节点和以前的进行对比，让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个渲染的过程，所以react说是一个ui框架。 React的组件化react的一个组件很明显的由dom视图和state数据组成，两个部分泾渭分明。state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。 React的 Diff算法react的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。 对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。 React组件是怎么来的组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。 这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类Main 继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。了解了这些之后我们在看组件的时候就清楚很多。 当我们使用组件\&lt; Main />时，其实是对Main类的实例化——new Main，只不过react对这个过程进行了封装，让它看起来更像是一个标签。 有三点值得注意：1、定义类名字的首字母必须大写 2、因为class变成了关键字，类选择器需要用className来代替。 3、类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。 组件的生命周期 组件在初始化时会触发5个钩子函数： 1、getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性。 2、getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 5、componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 在更新时也会触发5个钩子函数： 6、componentWillReceivePorps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 8、componentWillUpdate(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state 9、render() 不多说 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 还有一个卸载钩子函数 11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。 React-Router路由Router就是React的一个组件，它并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。Route则对路由地址和组件进行绑定，Route具有嵌套功能，表示路由地址的包涵关系，这和组件之间的嵌套并没有直接联系。Route可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。 当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。 1234567891011121314151617181920212223242526272829`const chooseProducts = (location, cb) =\&gt; &#123;require.ensure([](), require =\&gt; &#123;cb(null, require('../Component/chooseProducts').default)&#125;,'chooseProducts')&#125;const helpCenter = (location, cb) =\&gt; &#123;require.ensure([](), require =\&gt; &#123;cb(null, require('../Component/helpCenter').default)&#125;,'helpCenter')&#125;const saleRecord = (location, cb) =\&gt; &#123;require.ensure([](), require =\&gt; &#123;cb(null, require('../Component/saleRecord').default)&#125;,'saleRecord')&#125;const RouteConfig = (\&lt;Router history=&#123;history&#125;\&gt;\&lt;Route path="/" component=&#123;Roots&#125;\&gt;\&lt;IndexRoute component=&#123;index&#125; /\&gt;//首页\&lt;Route path="index" component=&#123;index&#125; /\&gt;\&lt;Route path="helpCenter" getComponent=&#123;helpCenter&#125; /\&gt;//帮助中心\&lt;Route path="saleRecord" getComponent=&#123;saleRecord&#125; /\&gt;//销售记录\&lt;Redirect from='*' to='/' /\&gt;\&lt;/Route\&gt;\&lt;/Router\&gt;); `## 组件之间的通信 react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。 组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。 兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。 组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。 Redux首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。我第一次做react项目的时候并没有用redux，所有的逻辑都是在组件内部实现，当时为了实现一个逻辑比较复杂的购物车，洋洋洒洒居然写了800多行代码，回头一看我自己都不知道写的是啥，画面太感人。 先简单说一下redux和react是怎么配合的。react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。 流程是这个样子的： 值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起。 接下来具体分析一下，redux以及react-redux到底是怎么实现的。先上一张图 明显比第一张要复杂，其实两张图说的是同一件事。从上而下慢慢分析： 先说说redux：redux主要由三部分组成：store，reducer，action。store是一个对象，它有四个主要的方法： 1、dispatch: 用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。 2、subscribe： 监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 et unsubscribe = store.subscribe(() => {console.log(‘state发生了变化’)}) 3、getState： 获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。 4、replaceReducer: 替换reducer，改变state修改的逻辑。 store可以通过createStore()方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。 action: action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。 reducer: reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。 像这个样子：12345`const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;) `combineReducers: 其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。 redux的state和react的state两者完全没有关系，除了名字一样。 上面分析了redux的主要功能，那么react-redux到底做了什么？ React-Redux如果只使用redux，那么流程是这样的： component –> dispatch(action) –> reducer –> subscribe –> getState –> component 用了react-redux之后流程是这样的： component –> actionCreator(data) –> reducer –> component store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。 Provider是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过context获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。 connect –connect(mapStateToProps, mapDispatchToProps, mergeProps, options) 是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。 所以它的完整写法是这样的：connect(mapStateToProps, mapDispatchToProps, mergeProps, options)(component) mapStateToProps(state, ownProps)： mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps 123`function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125; `mapDispatchToProps(dispatch, ownProps)： mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的 123456`function mapDispatchToProps(dispatch) &#123; return &#123; todoActions: bindActionCreators(todoActionCreators, dispatch), counterActions: bindActionCreators(counterActionCreators, dispatch) &#125;;&#125; `mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps。 mergeProps(stateProps, dispatchProps, ownProps)： 将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。 options： pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。 其实connect函数并没有做什么，大部分的逻辑都是在它返回的wrapWithConnect函数内实现的，确切的说是在wrapWithConnect内定义的Connect组件里实现的。 下面是一个完整的 react –> redux –> react 流程：一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。 三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。dispatch在state返回新的值之后会调用所有注册的listener函数其中包括handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –> redux –> react 的一次流程结束。 上面的有点复杂，简化版的流程是： 一、Provider组件接受redux的store作为props，然后通过context往下传。 二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。 connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。 简化版本：1`connect(state =\&gt; state, action)(Component); ` 项目搭建上面说了react，react-router和redux的知识点。但是怎么样将它们整合起来，搭建一个完整的项目。 1、先引用 react.js，redux，react-router 等基本文件，建议用npm安装，直接在文件中引用。 2、从 react.js，redux，react-router 中引入所需要的对象和方法。12345`import React, &#123;Component, PropTypes&#125; from 'react';import ReactDOM, &#123;render&#125; from 'react-dom';import &#123;Provider, connect&#125; from 'react-redux';import &#123;createStore, combineReducers, applyMiddleware&#125; from 'redux';import &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; from 'react-router'; `3、根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。 4、创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。 5、利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。 6、利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。 7、将Router放入最顶层组件Provider，引入store作为Provider的属性。 8、调用render渲染Provider组件且放入页面的标签中。 可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。 通常我们在顶层的ui组件打印props时可以看到一堆属性： 上图的顶层ui组件属性总共有18个，如果刚刚接触react，可能对这些属性怎么来的感到困惑，其实这些属性来自五个地方： 组件自定义属性1个，actionCreator返回的对象6个，reducer返回的state4个，Connect组件属性0个，以及Router注入的属性7个。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <url>%2F2019%2F03%2F29%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、计算表达式and、or：python 中的 and 从左到右计算表达式，若所有值均为真，则返回最后一个值，若存在假，返回第一个假值； or 也是从左到有计算表达式，返回第一个为真的值； 其中数字 0 是假，其他都是真； 字符 “” 是假，其他都是真； 2、二进制问题1a = 00111100 这么个赋值语句被提示了错误，于是去搜了下相关的博客得知 python 中数字有以下的表示方式： 2 进制是以 0b 开头的: 例如: 0b11 则表示十进制的 3 8 进制是以 0o 开头的: 例如: 0o11 则表示十进制的 9 16 进制是以 0x 开头的: 例如: 0x11 则表示十进制的 17 但是在测试的时候又遇到了个问题，那就是输出来的被自动转化成了十进制： 123&gt;&gt;&gt; a=0b111100&gt;&gt;&gt; a60 于是又去找了怎么输出二进制，得到了以下内容： 分别使用 bin，oct，hex 可输出数字的二进制，八进制，十六进制形式，例如： 12345678&gt;&gt;&gt; a=0b111100&gt;&gt;&gt; a=60&gt;&gt;&gt; bin(a)&apos;0b111100&apos;&gt;&gt;&gt; oct(a)&apos;0o74&apos;&gt;&gt;&gt; hex(a)&apos;0x3c&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Marathon操作手册]]></title>
    <url>%2F2019%2F03%2F29%2FMarathon%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[​ Marathon操作手册 选择Create Application弹出选项共有两种模式：填写模式、JSON模式 一、通用设置CPU、Memory、Disk Space、Instance根据需要配置 Instance说明： instances 里 ACTIVE 的数量就是实例的个数，一般都是给1个，特殊情况下给多个，比如说要跑多个容器承载负载多个实例通过统一的访问入口访问 在 Configuration 里有个service endpoint ，host port 是统一的入口 1、填写模式 2、JSON模式 二、容器配置选择bridge模式 三、端口设置containerport-hostport-serviceport 容器内部端口-&gt;宿主机端口-&gt;LB端口 访问服务有两个方式，一个是宿主机+宿主机端口 四、环境变量 五、label设置1、需要通过lb管理的容器需要配置HAPROXY_GROUP为external 这个label表示要把容器的端口通过load_balance暴露出去，会自动分配一个端口，即service-port 2、需要绑定域名的容器配置HAPROXY_0_VHOST为对应域名，数字0根据域名绑定的端口顺序进行设置 仅有一个端口的则配置为0，像gitlab有3个端口443、80、22的需要暴露端口80，该端口是第二个，则设置属性HAPROXY_1_VHOST 六、健康检查默认 7、存储卷配置挂载Volumes，避免重启容器导致数据丢失 八、其他配置默认容器重启后平台会从主机集群中自动匹配主机进行重启 配置Constrains限制该容器均从该主机重启 /nexus-data/blobs/npm-repo-blob /data/nexus/npm/npm-repo-blob]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Marathon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统安装PHP7教程]]></title>
    <url>%2F2019%2F03%2F29%2FMac%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85PHP7%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装教程： 1.首先我们需要安装Homebrew一条命令完美安装：http://brew.sh/index_zh-cn.html 2.终端输入以下命令12345678910111213141516171819202122// 创建目录,如果你没有创建过该目录sudo mkdir /usr/local/varsudo chmod 777 /usr/local/var//修改成你自己的用户名和组,如果你没有创建过该目录sudo mkdir /usr/local/sbin/sudo chown -R &lt;username&gt;:&lt;group&gt; /usr/local/sbin//由于我本身一直在使用5.6版本，故上述步骤省略，下面进入正题//添加PHP库brew tap homebrew/dupesbrew tap homebrew/versionsbrew tap homebrew/homebrew-php//关闭老版本的PHP56或55或更早版本 进程brew unlink php56//开始安装PHP7brew install php70//开启PHP70进程brew link php70//输入命令，查看是否成功php -v//成功后显示下面信息PHP 7.0.8 (cli) (built: Jul 13 2016 15:19:21) ( NTS )Copyright (c) 1997-2016 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies 注：遇未生成libphp7.so 1brew install php70 --with-apxs2 --with-apache --with-gmp --with-imap --with-tidy --with-debug 3.配置Apache123456789$ sudo vim /etc/apache2/httpd.conf找到这行注释掉(大概在168行）Comment out the PHP5 module LoadModule php5_module libexec/apache2/libphp5.soEnable PHP 7 module LoadModule php7_module /usr/local/opt/php70/libexec/apache2/libphp7.so &lt;FilesMatch \.php$&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 4.重启Apache1sudo apachectl restart 5.到你的Apache的默认目录/Library/WebServer/Documents下面去增加一个info.php的文件123&lt;?php phpinfo(); ?&gt; 最后到你的 http://localhost/info.php 去看看测试以下，如果看到相关的信息，就说明已经安装好了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>PHP7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac配置Iterm2自动登录expect脚本]]></title>
    <url>%2F2019%2F03%2F29%2FMac%E9%85%8D%E7%BD%AEIterm2%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95expect%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[1、新增文件auto_login.sh 1234567891011#/usr/bin/expectset timeout 30spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]expect &#123; "(yes/no)?" &#123;send "yes\n";exp_continue&#125; "password:" &#123;send "[lindex $argv 3]\n"&#125;&#125;interact 2、将auto_login.sh移到/usr/local/bin 设置权限755 3、iterm2配置Login Shell 1auto_ssh.sh 22 fitech01 192.168.101.30 12345678]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>expect</tag>
        <tag>iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F03%2F29%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、ssh连接主机 12ssh root@192.168.2.156 12345678 2、ssh连接主机copy文件 1scp root@192.168.2.156:/root/docker-oracle-xe-11g.tar （路径) 3、ssh连接主机copy文件夹及其下文件 1scp -r root@192.168.2.156:/root/docker-oracle-xe-11g.tar （路径) 4、chowm 1chown -R root:root /usr/meng 5、用户、用户组 123groupadd users(users组其实默认已经存在) #创建用户组useradd usera #创建用户cat /etc/group #查看用户组 6、ifconfig查看更多 1ifconfig | more 然后按 j k 上下移动 7、查看端口占用 1netstat -tunlp]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之Java环境变量配置]]></title>
    <url>%2F2019%2F03%2F29%2FLinux%E4%B9%8Bjava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[12345678910# vi /etc/profileexport JAVA_HOME=/home/fitech03/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH# source /etc/profile 1234567#/etc/environmentexport JAVA_HOME=/home/fitech03/jdk1.8.0_161export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib# source /etc/environment]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中几种循环的区别与相同点]]></title>
    <url>%2F2019%2F03%2F29%2FJS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%9B%B8%E5%90%8C%E7%82%B9%2F</url>
    <content type="text"><![CDATA[循环语句，用于重复执行某个操作，它有多种形式。 while循环 while语句的循环条件是一个表达式（express），必须放在圆括号中。代码块部分，如果只有一条语句（statement），可以省略大括号，否则就必须加上大括号。 123456while (expression) statement;// 或者while (expression) statement; 下面写个例子 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i当前为：&apos; + i); i += 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; for循环 for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (initialize; test; increment) statement// 或者for (initialize; test; increment) &#123; statement&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。 测试表达式（test）：检查循环条件，只要为真就进行后续操作。 递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件。 eg: 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize，test，increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 do…while循环 do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 123456789do statementwhile (expression);// 或者do &#123; statement&#125; while (expression); 不管条件是否为真，do..while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号不能省略。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break语句和continue语句 break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i%2 === 0) continue; console.log(&apos;i当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 标签（label） JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下: 12label: statement 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes常用命令]]></title>
    <url>%2F2019%2F03%2F29%2FKubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、批量删除Evicted Pods 12kubectl get pods | grep Evicted | awk '&#123;print $1&#125;' | xargs kubectl delete podkubectl get pods | grep OutOfcpu | awk '&#123;print $1&#125;' | xargs kubectl delete pod]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git撤销&回滚操作]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E6%92%A4%E9%94%80%26%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[开发过程中，你肯定会遇到这样的场景： 场景一： 糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！ 场景二： 彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！ 场景三： 刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！ 撤销上述场景一，在未进行git push前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！ 情况一：文件被修改了，但未执行git add操作(working tree内撤销)12git checkout fileNamegit checkout . 情况二：同时对多个文件执行了git add操作，但本次只想提交其中一部分文件1234$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt; 情况三：文件执行了git add操作，但想撤销对其的修改（index内回滚）1234# 取消暂存git reset HEAD fileName# 撤销修改git checkout fileName 情况四：修改的文件已被git commit，但想再次修改不再产生新的Commit123# 修改最后一次提交 $ git add sample.txt$ git commit --amend -m"说明" 情况五：已在本地进行了多次git commit操作，现在想撤销到其中某次Commit1git reset [--hard|soft|mixed|merge|keep] [commit|HEAD] 回滚上述场景二，已进行git push，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！如果你每次更新线上，都会打tag，那恭喜你，你可以很快的处理上述场景二的情况 1git checkout &lt;tag&gt; 如果你回到当前HEAD指向 1git checkout &lt;branch_name&gt; 情况一：撤销指定文件到指定版本1234# 查看指定文件的历史版本git log &lt;filename&gt;# 回滚到指定commitIDgit checkout &lt;commitID&gt; &lt;filename&gt; 情况二：删除最后一次远程提交方式一：使用revert12git revert HEADgit push origin master 方式二：使用reset12git reset --hard HEAD^git push origin master -f 二者区别： revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在； reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。情况三：回滚某次提交 123# 找到要回滚的commitIDgit loggit revert commitID 删除某次提交123git log --oneline -n5 git rebase -i "commit id"^ 注意：需要注意最后的^号，意思是commit id的前一次提交 1git rebase -i "5b3ba7a"^ 在编辑框中删除相关commit，如pick 5b3ba7a test2，然后保存退出（如果遇到冲突需要先解决冲突）！ 1git push origin master -f 通过上述操作，如果你想对历史多个commit进行处理或者，可以选择git rebase -i，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用命令]]></title>
    <url>%2F2019%2F03%2F29%2FDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. 查看docker信息（version、info）12345# 查看docker版本$ docker version# 显示docker系统的信息$ docker info 2、查看容器12$ docker ps #查看正在运行容器$ docker ps -a #查看所有容器 3、启动容器123456789$ docker run -d -p 8080:8080 --restart=always containerId-d: #后台启动-p: #映射端口--restart=always: #自动重启--name="zhengding/oracle": #为容器指定一个名称--dns 8.8.8.8 #指定容器使用的DNS服务器: 默认和宿主一致-e username="ritchie": #设置环境变量--env-file=[]: #从指定文件读入环境变量--net="bridge": #指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型 4、进入容器123$ docker exec -it fc873 /bin/bash或$ docker exec -it fc873 /bin/bash 5. 对容器的操作（rm、rmi、tag、stop、start、kill、logs、diff、top、cp、restart、attach）1234567891011121314151617181920212223242526272829303132333435363738394041# 删除所有容器$ docker rm `docker ps -a -q`#删除所有已退出容器$ docker rm $(docker ps -a | grep "Exited" | awk '&#123;print $1 &#125;') $ docker rm -v $(docker ps -aq -f status=exited)# 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container$ docker rm Name/ID# 停止、启动、杀死一个容器$ docker stop Name/ID#停止所有已退出容器$ docker stop $(docker ps -a | grep "Exited" | awk '&#123;print $1 &#125;') $ docker start Name/ID$ docker kill Name/ID#删除镜像$ docker rmi imageId #删除所有为none的镜像$ docker rmi $(docker images | grep "none" | awk '&#123;print $3&#125;') #标记本地镜像，将其归入某一仓库$ docker tag ubuntu:15.10 runoob/ubuntu:v3# 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps$ docker logs Name/ID# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的$ docker diff Name/ID# 显示一个运行的容器里面的进程信息$ docker top Name/ID# 从容器里面拷贝文件/目录到本地一个路径$ docker cp Name:/container_path to_path$ docker cp ID:/container_path to_path# 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10$ docker restart Name/ID# 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process$ docker attach ID Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。 6、使用Dockerfile创建镜像1234#使用当前目录的Dockerfile创建镜像。$ docker build -t runoob/ubuntu:v1 . #使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。$ docker build github.com/creack/docker-firefox 7、加载镜像1$ docker load --input runoob/ubuntu:v1 8、ssh配置123456789101112131415161718#一、进入容器之后进行编辑ssh文件，如果没有ssh,需要先安装：#安装ssh-client命令：$ sudo apt-get install openssh-client#安装ssh-server命令：$ sudo apt-get install openssh-server#安装完成以后，先启动服务：$ sudo /etc/init.d/ssh start#启动后，可以通过“ps -e|grep ssh”查看是否正确启动。#二、编辑ssh配置文件：$ sudo vim/etc/ssh/sshd_config#PermitRootLogin without-password 改为 PermitRootLogin yesPasswordAuthentication yes 改为 PasswordAuthentication no#三、重启服务：$ sudo service ssh restart#四、设置ssh密码：$ passwd rootEnter new UNIX password: Retype new UNIX password: passwd: password updated successfully 9、自动清理镜像容器1$ docker system prune 10、查看当前容器资源占用i情况1$ docker stats 11、保存和加载镜像（save、load）当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。 123456789# 保存镜像到一个tar包; -o, --output="" Write to an file$docker save image_name -o file_path# 加载一个tar包格式的镜像; -i, --input="" Read from a tar archive file$docker load -i file_path# 机器a$docker save image_name &gt; /home/save.tar# 使用scp将save.tar拷到机器b上，然后：$docker load &lt; /home/save.tar]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装oracle]]></title>
    <url>%2F2019%2F03%2F29%2FDocker%E5%AE%89%E8%A3%85oracle%2F</url>
    <content type="text"><![CDATA[常用命令将数据库文件生成镜像docker load —input docker-oracle-xe-11g.tar生成容器docker run -d -p 1522:1521 f785进入容器内部docker exec -it fc873 /bin/bash查看数据库状态lsnrctl status(BLOCKED非正常)配置文件路径/u01/app/oracle/product/11.2.0/xe/network/admin安装vimapt-get updateapt-get install vim 常见错误1、Connection to @192.168.2.156 failed.6600012528 Listener refused the connection with the following error:ORA-12528, TNS:listener: all appropriate instances are blocking new connections]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker备份和恢复]]></title>
    <url>%2F2019%2F03%2F29%2FDocker%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[今天，我们将学习如何快速地对docker容器进行快捷备份、恢复和迁移。Docker是一个开源平台，用于自动化部署应用，以通过快捷的途径在称之为容器的轻量级软件层下打包、发布和运行这些应用。它使得应用平台独立，因为它扮演了Linux上一个额外的操作系统级虚拟化的自动化抽象层。它通过其组件cgroups和命名空间利用Linux内核的资源分离特性，达到避免虚拟机开销的目的。它使得用于部署和扩展web应用、数据库和后端服务的大规模构建组件无需依赖于特定的堆栈或供应者。 所谓的容器，就是那些创建自Docker镜像的软件层，它包含了独立的Linux文件系统和开箱即用的应用程序。如果我们有一个在机器中运行着的Docker容器，并且想要备份这些容器以便今后使用，或者想要迁移这些容器，那么，本教程将帮助你掌握在Linux操作系统中备份、恢复和迁移Docker容器的方法。 我们怎样才能在Linux中备份、恢复和迁移Docker容器呢？这里为您提供了一些便捷的步骤。 1. 备份容器首先，为了备份Docker中的容器，我们会想看看我们想要备份的容器列表。要达成该目的，我们需要在我们运行着Docker引擎，并已创建了容器的Linux机器中运行 docker ps 命令。 # docker ps Docker Containers List 在此之后，我们要选择我们想要备份的容器，然后去创建该容器的快照。我们可以使用 docker commit 命令来创建快照。 # docker commit -p 30b8f18f20b4 container-backup Docker Commit 该命令会生成一个作为Docker镜像的容器快照，我们可以通过运行 docker images 命令来查看Docker镜像，如下。 # docker images Docker Images 正如我们所看见的，上面做的快照已经作为Docker镜像保存了。现在，为了备份该快照，我们有两个选择，一个是我们可以登录进Docker注册中心，并推送该镜像；另一个是我们可以将Docker镜像打包成tar包备份，以供今后使用。 如果我们想要在Docker注册中心上传或备份镜像，我们只需要运行 docker login 命令来登录进Docker注册中心，然后推送所需的镜像即可。 # docker login Docker Login # docker tag a25ddfec4d2a arunpyasi/container-backup:test # docker push arunpyasi/container-backup Docker Push 如果我们不想备份到docker注册中心，而是想要将此镜像保存在本地机器中，以供日后使用，那么我们可以将其作为tar包备份。要完成该操作，我们需要运行以下 docker save 命令。 # docker save -o ~/container-backup.tar container-backup taking tarball backup 要验证tar包是否已经生成，我们只需要在保存tar包的目录中运行 ls 命令即可。 2. 恢复容器接下来，在我们成功备份了我们的Docker容器后，我们现在来恢复这些制作了Docker镜像快照的容器。如果我们已经在注册中心推送了这些Docker镜像，那么我们仅仅需要把那个Docker镜像拖回并直接运行即可。 # docker pull arunpyasi/container-backup:test Docker Pull 但是，如果我们将这些Docker镜像作为tar包文件备份到了本地，那么我们只要使用 docker load 命令，后面加上tar包的备份路径，就可以加载该Docker镜像了。 # docker load -i ~/container-backup.tar 现在，为了确保这些Docker镜像已经加载成功，我们来运行 docker images 命令。 # docker images 在镜像被加载后，我们将用加载的镜像去运行Docker容器。 # docker run -d -p 80:80 container-backup Restoring Docker Tarball 3. 迁移Docker容器迁移容器同时涉及到了上面两个操作，备份和恢复。我们可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，首先我们将把容器备份为Docker镜像快照。然后，该Docker镜像或者是被推送到了Docker注册中心，或者被作为tar包文件保存到了本地。如果我们将镜像推送到了Docker注册中心，我们简单地从任何我们想要的机器上使用 docker run 命令来恢复并运行该容器。但是，如果我们将镜像打包成tar包备份到了本地，我们只需要拷贝或移动该镜像到我们想要的机器上，加载该镜像并运行需要的容器即可。 尾声最后，我们已经学习了如何快速地备份、恢复和迁移Docker容器，本教程适用于各个可以成功运行Docker的操作系统平台。真的，Docker是一个相当简单易用，然而功能却十分强大的工具。它的命令相当易记，这些命令都非常短，带有许多简单而强大的标记和参数。上面的方法让我们备份容器时很是安逸，使得我们可以在日后很轻松地恢复它们。这会帮助我们恢复我们的容器和镜像，即便主机系统崩溃，甚至意外地被清除。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7.0 中的中iptables、firewall和SELINUX]]></title>
    <url>%2F2019%2F03%2F29%2FCentos7.0%20%E4%B8%AD%E7%9A%84%E4%B8%ADiptables%E3%80%81firewall%E5%92%8CSELINUX%2F</url>
    <content type="text"><![CDATA[CentOS 7.0默认使用的是firewall作为防火墙，这里改为iptables防火墙。 firewallfirewall能够允许哪些服务可用，那些端口可用…. 属于更高一层的防火墙。firewall的底层是使用iptables进行数据过滤，建立在iptables之上。 firewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。 关闭firewall123systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） iptablesiptables用于过滤数据包，属于网络层防火墙. 在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。 iptables防火墙12yum install iptables-services #安装iptablesvi /etc/sysconfig/iptables #编辑iptables防火墙配置文件 12345678910111213141516Firewall configuration written by system-config-firewallManual customization of this file is not recommended.*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT:wq! #保存退出 123systemctl restart iptables.service #最后重启防火墙使配置生效systemctl enable iptables.service #设置防火墙开机启动yum remove iptables #卸载iptables SELinuxSELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。它不是用来防火墙设置的。但它对Linux系统的安全很有用。Linux内核(Kernel)从2.6就有了SELinux。 SELinux是一种基于 域-类型 模型（domain-type）的强制访问控制（MAC）安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略。任何程序对其资源享有完全的控制权。假设某个程序打算把含有潜在重要信息的文件扔到/tmp目录下，那么在DAC情况下没人能阻止他。SELinux提供了比传统的UNⅨ权限更好的访问控制。 关闭SELinux1vi /etc/selinux/config 123SELINUX=enforcing #注释掉 SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 :wq! #保存退出setenforce 0 #使配置立即生效]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局解决方案（终结版）]]></title>
    <url>%2F2019%2F03%2F29%2FCSS%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E7%BB%88%E7%BB%93%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端布局非常重要的一环就是页面框架的搭建，也是最基础的一环。在页面框架的搭建之中，又有居中布局、多列布局以及全局布局，今天我们就来总结总结前端干货中的CSS布局。 居中布局水平居中1）使用inline-block+text-align（1）原理、用法 原理：先将子框由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 用法：对子框设置display:inline-block，对父框设置text-align:center。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456.child&#123; display:inline-block;&#125;.parent&#123; text-align:center;&#125; （3）优缺点 优点:兼容性好，甚至可以兼容ie6、ie7 缺点:child里的文字也会水平居中，可以在.child添加text-align:left;还原 2）使用table+margin（1）原理、用法 原理：先将子框设置为块级表格来显示（类似 ），再设置子框居中以达到水平居中。 用法：对子框设置display:table，再设置margin:0 auto。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.child &#123; display:table; margin:0 auto;&#125; （3）优缺点： 优点：只设置了child，ie8以上都支持 缺点：不支持ie6、ie7,将div换成table 3）使用absolute+transform（1）原理、用法 原理：将子框设置为绝对定位，移动子框，使子框左侧距离相对框左侧边框的距离为相对框宽度的一半，再通过向左移动子框的一半宽度以达到水平居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：对父框设置position:relative，对子框设置position:absolute，left:50%，transform:translateX(-50%)。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; left:50%; transform:translateX(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 4）使用flex+margin（1）原理、用法 原理：通过CSS3中的布局利器flex将子框转换为flex item，再设置子框居中以达到居中。 用法：先将父框设置为display:flex，再设置子框margin:0 auto。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456.parent &#123; display:flex;&#125;.child &#123; margin:0 auto;&#125; （3）优缺点 缺点:低版本浏览器(ie6 ie7 ie8)不支持 5）使用flex+justify-content（1）原理、用法 原理：通过CSS3中的布局利器flex中的justify-content属性来达到水平居中。 用法：先将父框设置为display:flex，再设置justify-content:center。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:flex; justify-content:center;&#125; （3）优缺点 优点:设置parent即可 缺点:低版本浏览器(ie6 ie7 ie8)不支持 垂直居中1）使用table-cell+vertical-align（1）原理、用法 原理：通过将父框转化为一个表格单元格显示（类似 和 ），再通过设置属性，使表格单元格内容垂直居中以达到垂直居中。 用法：先将父框设置为display:table-cell，再设置vertical-align:middle。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; display:table-cell; vertical-align:middle;&#125; （3）优缺点 优点:兼容性较好，ie8以上均支持 2）使用absolute+transform（1）原理、用法 原理：类似于水平居中时的absolute+transform原理。将子框设置为绝对定位，移动子框，使子框上边距离相对框上边边框的距离为相对框高度的一半，再通过向上移动子框的一半高度以达到垂直居中。当然，在此之前，我们需要设置父框为相对定位，使父框成为子框的相对框。 用法：先将父框设置为position:relative，再设置子框position:absolute，top:50%，transform:translateY(-50%)。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; top:50%; transform:translateY(-50%);&#125; （3）优缺点 优点:居中元素不会对其他的产生影响 缺点:transform属于css3内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 3）使用flex+align-items（1）原理、用法 原理：通过设置CSS3中的布局利器flex中的属性align-times，使子框垂直居中。 用法：先将父框设置为position:flex，再设置align-items:center。 （1）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 1234.parent &#123; position:flex; align-items:center;&#125; （3）优缺点 优点:只设置parent 缺点:兼容性存在一定问题 水平垂直居中1）使用absolute+transform（1）原理、用法 原理：将水平居中时的absolute+transform和垂直居中时的absolute+transform相结合。详见：水平居中的3）和垂直居中的2）。 见水平居中的3）和垂直居中的2）。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 123456789.parent &#123; position:relative;&#125;.child &#123; position:absolute; left:50%; top:50%; transform:tranplate(-50%,-50%);&#125; （3）优缺点 优点:child元素不会对其他元素产生影响 缺点:兼容性存在一定问题 2）使用inline-block+text-align+table-cell+vertical-align（1）原理、用法 原理：使用inline-block+text-align水平居中，再用table-cell+vertical-align垂直居中，将二者结合起来。详见：水平居中的1）和垂直居中的1）。 见水平居中的1）和垂直居中的1）。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345678.parent &#123; text-align:center; display:table-cell; vertical-align:middle;&#125;.child &#123; display:inline-block;&#125; （3）优缺点 优点:兼容性较好 3）使用flex+justify-content+align-items（1）原理、用法 原理：通过设置CSS3布局利器flex中的justify-content和align-items，从而达到水平垂直居中。详见：水平居中的4）和垂直居中的3）。 见水平居中的4）和垂直居中的3）。 （2）代码实例 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&gt;DEMO&lt;/div&gt;&lt;/div&gt; 12345.parent &#123; display:flex; justify-content:center; align-items:center;&#125; （3）优缺点 优点:只设置了parent 缺点:兼容性存在一定问题 多列布局定宽+自适应1）使用float+overflow（1）原理、用法 原理：通过将左边框脱离文本流，设置右边规定当内容溢出元素框时发生的事情以达到多列布局。 用法：先将左框设置为float:left、width、margin-left，再设置实际的右框overflow:hidden。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678.left &#123; float:left; width:100px; margin-right:20px;&#125;.right &#123; overflow:hidden;&#125; （3）优缺点 优点:简单 缺点:不支持ie6 2）使用float+margin（1）原理、用法 原理：通过将左框脱离文本流，加上右框向右移动一定的距离，以达到视觉上的多列布局。 用法：先将左框设置为float:left、margin-left，再设置右框margin-left。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567.left &#123; float:left; width:100px;&#125;.right &#123; margin-left:120px;&#125; （3）优缺点 优点:简单，易理解 缺点:兼容性存在一定问题，ie6下有3px的bug。right下的p清除浮动将产生bug 3）使用float+margin（改良版）（1）原理、用法 原理：在1）的基础之上，通过向右框添加一个父框，再加上设置左、右父框属性使之产生BFC以去除bug。 用法：先将左框设置为float:left、margin-left、position:relative，再设置右父框float:right、width:100%、margin-left，最后设置实际的右框margin-left。 （2）代码实例 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;rigth-fix&quot;&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.left &#123; float:left; width:100px; position:relative;&#125;.right-fix &#123; float:right; width:100%; margin-left:-100px;&#125;.right &#123; margin-left:120px;&#125; （3）优缺点 优点:简单，易理解 4）使用table（1）原理、用法 原理：通过将父框设置为表格，将左右边框转化为类似于同一行的td，从而达到多列布局。 用法：先将父框设置为display:table、width:100%、table-layout:fixed，再设置左右框display:table-cell，最后设置左框width、padding-right。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.parent &#123; display:table; width:100%; table-layout:fixed;&#125;.left &#123; width:100px; padding-right:20px;&#125;.right,.left &#123; display:table-cell; &#125; 5）使用flex（1）原理、用法 原理：通过设置CSS3布局利器flex中的flex属性以达到多列布局。 用法：先将父框设置为display:flex，再设置左框flex:1，最后设置左框width、margin-right。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.parent &#123; display:flex;&#125;.left &#123; width:100px; margin-right:20px;&#125;.right &#123; flex:1;&#125; （3）优缺点 优点:flex很强大 缺点:兼容性存在一定问题，性能存在一定问题 两列定宽+一列自适应（1）原理、用法 原理：这种情况与两列定宽查不多。 用法：先将左、中框设置为float:left、width、margin-right，再设置右框overflow:hidden。 （2）代码实例 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;center&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678.left,.center &#123; float:left; width:100px; margin-right:20px;&#125;.right &#123; overflow:hidden;&#125; 不定宽+自适应1）使用float+overflow（1）原理、用法 原理：这种情况与两列定宽查不多。 用法：先将左框设置为float:left、margin-right，再设置右框overflow: hidden，最后设置左框中的内容width。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.left&#123; float: left; margin-right: 20px; &#125;.right&#123; overflow: hidden;&#125;.left p&#123; width: 200px;&#125; （3）优缺点 优点:简单 缺点:ie6下兼容性存在一定问题 2）使用table（1）原理、用法 原理：通过将父框改变为表格，将左右框转换为类似于同一行的td以达到多列布局，设置父框宽度100%，给左框子元素一个固定宽度从而达到自适应。 用法：先将父框设置为display: table、width: 100%，再设置左、右框display: table-cell，最后设置左框width: 0.1%、padding-right以及左框中的内容width。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.parent&#123; display: table; width: 100%; &#125;.left,.right&#123; display: table-cell;&#125;.left&#123; width: 0.1%; padding-right: 20px;&#125;.left p&#123; width:200px;&#125; （3）优缺点 缺点:ie6 ie7不支持 3）使用flex（1）原理、用法 原理：通过设置CSS3布局利器flex中的flex属性以达到多列布局，加上给左框中的内容定宽、给右框设置flex达到不定款+自适应。 用法：先将父框设置为display:flex，再设置右框flex:1，最后设置左框margin-right:20px、左框中的内容width。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.parent &#123; display:flex;&#125;.left &#123; margin-right:20px;&#125;.right &#123; flex:1;&#125;.left p&#123; width: 200px;&#125; （3）优缺点 优点:flex很强大 缺点:兼容性存在一定问题，性能存在一定问题 两列不定宽+一列自适应（1）原理、用法 原理：这个情况与一列不定宽+一列自适应查不多。 用法：先将左、中框设置为float:left、margin-right，再设置右框overflow:hidden，最后给左中框中的内容设置width。 （2）代码实例 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;center&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.left,.center&#123; float: left; margin-right: 20px;&#125;.right&#123; overflow: hidden;&#125;.left p,.center p&#123; width: 100px;&#125; 等分布局 12公式转化:l = w * n + g * (n-1) -&gt; l = w * n + g * n - g -&gt; l + g = （w + g） * n 因此，我们需要解决两个问题： 如何让总宽度增加g(即：L+g) 如何让每个宽包含g（即：w+g） 1）使用float（1）原理、用法 原理：增大父框的实际宽度后，使用CSS3属性box-sizing进行布局的辅助。 用法：先将父框设置为margin-left: -*px，再设置子框float: left、width: 25%、padding-left、box-sizing: border-box。 （2）代码实例 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 123456789.parent&#123; margin-left: -20px;//l增加g&#125;.column&#123; float: left; width: 25%; padding-left: 20px; box-sizing: border-box;//包含padding区域 w+g&#125; （3）优缺点 优点：兼容性较好 缺点：ie6 ie7百分比兼容存在一定问题 2）使用table（1）原理、用法 原理：通过增加一个父框的修正框，增大其宽度，并将父框转换为table，将子框转换为tabel-cell进行布局。 用法：先将父框的修正框设置为margin-left: -*px，再设置父框display: table、width:100%、table-layout: fixed，设置子框display: table-cell、padding-left。 （2）代码实例 12345678&lt;div class=&quot;parent-fix&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.parent-fix&#123; margin-left: -20px;//l+g&#125;.parent&#123; display: table; width:100%; table-layout: fixed;&#125;.column&#123; display: table-cell; padding-left: 20px;//w+g&#125; （3）优缺点 优点：结构和块数无关联 缺点：增加了一层 3）使用flex（1）原理、用法 原理：通过设置CSS3布局利器flex中的flex属性以达到等分布局。 用法：将父框设置为display: flex，再设置子框flex: 1，最后设置子框与子框的间距margin-left。 （2）代码实例 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 123456789.parent&#123; display: flex;&#125;.column&#123; flex: 1;&#125;.column+.column&#123; margin-left:20px;&#125; （3）优缺点 优点：代码量少，与块数无关 缺点：兼容性存在一定问题 定宽+自适应+两块高度一样高1）使用float（1）原理、用法 原理：通过过分加大左右子框的高度，辅助超出隐藏，以达到视觉上的等高。 用法：将父框设置overflow: hidden，再设置左右子框padding-bottom: 9999px、margin-bottom: -9999px，最后设置左框float: left、width、margin-right，右框overflow: hidden。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021p&#123; background: none!important;&#125;.left,.right&#123; background: #444;&#125;.parent&#123; overflow: hidden;&#125;.left,.right&#123; padding-bottom: 9999px; margin-bottom: -9999px;&#125;.left&#123; float: left; width: 100px; margin-right: 20px;&#125;.right&#123; overflow: hidden;&#125; (3)优缺点 优点：兼容性好 缺点：伪等高，不是真正意义上的等高 2）使用table（1）原理、用法 原理：将父框转化为tabel，将子框转化为tabel-cell布局，以达到定宽+自适应+两块高度一样高。 用法：先将父框设置为display:table、width:100%、table-layout:fixed，再设置左右框为display:table-cell，最后设置左框width、padding-right。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.parent &#123; display:table; width:100%; table-layout:fixed;&#125;.left &#123; width:100px; padding-right:20px;&#125;.right,.left &#123; display:table-cell;&#125; 3）使用flex（1）原理、用法 原理：通过设置CSS3布局利器flex中的flex属性以达到定宽+自适应+两块高度一样高。 用法：将父框设置为display: flex，再设置左框width、margin-right，最后设置右框flex:1。 （2）代码实例 123456789&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.parent &#123; display:flex;&#125;.left &#123; width:100px; margin-right:20px;&#125;.right &#123; flex:1;&#125; （3）优缺点 优点:代码少，flex很强大 缺点:兼容性存在一定问题 4)使用display（1）原理、用法 原理：通过设置display中的CSS3的-webkit-box属性以达到定宽+自适应+两块高度一样高。 用法：将父框设置为display: -webkit-box、width: 100%，再设置左框width、margin-right，最后设置右框-webkit-box-flex: 1。 （2）代码实例 1234&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right &lt;/div&gt;&lt;/div&gt; 1234567891011.parent &#123; width: 100%; display: -webkit-box;&#125;.left &#123; width:100px; margin-right: 20px;&#125;.right &#123; -webkit-box-flex: 1;&#125; (3)优缺点 缺点:兼容性存在较大的问题 全屏布局全屏布局的特点 滚动条不是全局滚动条，而是出现在内容区域里，往往是主内容区域 浏览器变大时，撑满窗口 全屏布局的方法 1）使用position（1）原理、用法 原理：将上下部分固定，中间部分使用定宽+自适应+两块高度一样高。 用法：见实例。 （2）代码实例 12345678&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;inner&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;bottom&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344html,body,.parent&#123; margin:0; height:100%; overflow:hidden;&#125;body&#123; color:white;&#125;.top&#123; position:absolute; top:0; left:0; right:0; height:100px; background:blue;&#125;.left&#123; position:absolute; left:0; top:100px; bottom:50px; width:200px; background:red;&#125;.right&#123; position:absolute; left:200px; top:100px; bottom:50px; right:0; background:pink; overflow: auto;&#125;.right .inner&#123; min-height: 1000px;&#125;.bottom&#123; position:absolute; left:0; right:0; bottom:0; height:50px; background: black;&#125; (3)优缺点 优点：兼容性好，ie6下不支持 2）使用flex（1）原理、用法 原理：通过灵活使用CSS3布局利器flex中的flex属性和flex-direction属性以达到全屏布局。 用法：见实例。 （2）代码实例 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;inner&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;bottom&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536html,body,.parent&#123; margin:0; height:100%; overflow:hidden;&#125;body&#123; color: white;&#125; .parent&#123; display: flex; flex-direction: column;&#125;.top&#123; height:100px; background: blue;&#125;.bottom&#123; height:50px; background: black;&#125;.middle&#123; flex:1; display:flex;&#125;.left&#123; width:200px; background: red;&#125;.right&#123; flex: 1; overflow: auto; background:pink;&#125;.right .inner&#123; min-height: 1000px;&#125; (3)优缺点 缺点：兼容性差，ie9及ie9以下不兼容 1）使用flex（1）原理、用法 原理：通过灵活使用CSS3布局利器flex中的flex属性和flex-direction属性以达到全屏布局。 用法：见实例。 （2）代码实例 12345678910&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;top&quot;&gt;top&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;inner&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;bottom&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233html,body,.parent&#123; margin:0; height:100%; overflow:hidden;&#125;body&#123; color:white;&#125; .parent&#123; display:flex; flex-direction:column;&#125;.top&#123; background:blue;&#125;.bottom&#123; background:black;&#125;.middle&#123; flex:1; display:flex;&#125;.left&#123; background: red;&#125;.right&#123; flex:1; overflow:auto; background: pink;&#125;.right .inner&#123; min-height:1000px;&#125; 全屏布局相关方案的兼容性、性能和自适应一览表 方案 兼容性 性能 是否自适应 Position 好 好 部分自适应 Flex 较差 差 可自适应 Grid 差 较好 可自适应 当然，最最最最最后，如果您喜欢这片文章，可以疯狂点赞和收藏喔！！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接登录docker容器]]></title>
    <url>%2F2019%2F03%2F29%2Fssh%E7%9B%B4%E6%8E%A5%E7%99%BB%E5%BD%95docker%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[docker容器，我们想直接通过ssh链接docker容器，而不是通过宿主机进入的方式 首先，先了解一下docker，docker 命令 启动docker，进入docker容器 1.如果是守护态容器，可以通过下面的方式进入： 1docker exec -it 42d099e3fdca /bin/bash （3c0498ea5254是CONTAINER ID） 2.进入docker后，使用passwd密码来修改密码（如提示没有这个命令行使用yum install passwd安装）： 123passwd xxx密码 xxx确认密码 3.安装Openssh（docker 容器中执行） 12sudo yum -y install openssh-server$ sudo yum -y install openssh-clients 修改SSH配置文件以下选项，去掉#注释，将四个选项启用： vi /etc/ssh/sshd_config 1234RSAAuthentication yes #启用 RSA 认证PubkeyAuthentication yes #启用公钥私钥配对认证方式AuthorizedKeysFile .ssh/authorized_keys #公钥文件路径（和上面生成的文件同）PermitRootLogin yes #root能使用ssh登录 重启ssh服务，并设置开机启动： 12service sshd restart$ chkconfig sshd on 4.退出容器并保存更改 使用exit命令或者ctrl+C来退出当前运行的容器： 1[root@ffe81683c404 /]# exit 注意：上面ffe81683c404是容器的ID，退出后用于保存的唯一ID。 当结束后，我们使用 exit 来退出 现在我们的容器已经被我们改变了，使用 docker commit 命令，将当前的容器生成镜像。 12sudo docker commit -m &apos;install openssh&apos; -a &apos;Docker Newbee&apos; ffe81683c404 centos6-jdk7:ssh4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c -m:来指定提交的说明信息，跟我们使用的版本控制工具一样 -a 可以指定更新的用户信息 ffe81683c404： 创建镜像的容器的ID，就是上面的容器id，也就是我们刚才进入的容器id centos6-jdk7:ssh: 目标镜像的仓库名和 tag 信息，冒号前面部分是生成的镜像的仓库名字，冒号后面是镜像tag 创建成功后会返回这个镜像的 ID 信息，查看镜像 1docker images 5.启动新的容器并打通22端口 将新的镜像启动，并将docker服务器的50001端口映射到容器的22端口上： 1docker run -d -p 2222:22 centos6-jdk7:ssh /usr/sbin/sshd -D 然后用xshell连接， ip: 为宿主主机的ip，而不是docker容器的ip 1端口`:就是上面的`2222 用户名： root 密码： 就是上面password部分设置的密码 即可连接成功 6.关掉该容器 在宿主机通过 docker stop 容器id 即可关闭 启动容器 docker start 容器id 启动后，就可以用xshell进行连接。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装 node-sass 的正确姿势]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%AE%89%E8%A3%85%20node-sass%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%20-%202%2F</url>
    <content type="text"><![CDATA[安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit） 方法一：使用淘宝镜像macOS 系统直接运行下面的命令即可：SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass我们一般更希望能跨平台、并且直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件： 1234sass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/electron_mirror=https://npm.taobao.org/mirrors/electron/registry=https://registry.npm.taobao.org 这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。 方法二：使用梯子假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com加入 PAC 列表）： 12345npm config set proxy http://127.0.0.1:1080npm i node-sass下载完成后删除 http 代理npm config delete proxy 嗯，这样下来就能正常安装了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node-sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git教程]]></title>
    <url>%2F2017%2F11%2F20%2Fgit%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[EAST项目部署常见问题项目启动报错 保证服务器jdk版本为1.8以上 首次部署仅将fitech.war,platform.war和libs.war放入服务器中间件中，防止日志太多，异常不容易排查 查看服务器日志，发现connection异常，检查fitech中的数据库配置是否正确 用户登录异常 检查数据脚本都正常执行了，可查看select * from sysuser是否有数据 访问浏览器控制台，F12，登录一下看看是否有异常，如果是404，检查platform中的fitech.js是否修改成功 登录之后系统常见问题 不要随意直接在数据库中修改数据，会导致页面显示有问题，如果实在想操作，请先询问产品开发 系统配置中的制度配置导入时间比较久，耐心等待一会，重复导入可能会导致数据问题，查看是否成功，可在报文配置中查看数据表\3. ETL数据调度常见问题 新平台EAST需要配置3个作业才可以正常运行 数据补录作业 数据补录系统待上报报文流程存储过程（east.create_bl_task|系统内置） 数据补录系统流程开启任务（JAVA任务） EAST收据调度作业 EAST待上报报文流程存储过程（east.proc_ledgerReport|系统内置） 数据拉取存储过程（客户现场人员编写） EAST流程开启任务（JAVA任务） EAST报文生成作业 EAST上报报文生成任务（JAVA任务） 安装部署手册中的案例都是范例，请根据实际情况进行配置 调度任务有没有成功执行，可以查看控制台日志是否执行成功 数据库连接异常，可查看fitech-etl-1.0.war是否配置成功 出现数组越界，可能是作业中的任务配置有问题，可截图发给开发排查问题 ETL会根据配置频度来控制执行状态，例如日频度，则当天只能执行一次，如果想多次执行，则到数据调度监控中重新执行作业，或者执行SQL手动删除ETL调度任务 例如： 123456select * from etl_job_monitor;select * from ETL_TASK_MONITOR;delete from ETL_JOB_MONITOR where yxrq = '20171020';delete from ETL_TASK_MONITOR where yxrq = '20171020';commit; EAST项目部署手册服务器环境 数据库（如果是oracle需要安装oracle客户端，用作sqluldr2报文生成） jdk1.8以上 服务器中间件（需要支持jdk1.8） 项目说明 项目分成4个子服务，由于模块之间有相互调用，需要分先后启动，分别配置 fitech.war平台主服务,处理平台业务逻辑 fitech-etl-1.0.warETL调度系统服务，处理数据抽取等调度任务 platform.war前端主服务 libs.war前端框架lib包 项目部署主服务部署配置 将fitech.war放入服务中间件 修改服务配置文件application-env.properties 需要修改的配置 数据库配置，修改对应IP,端口和监听，以及用户名和密码 initPassword是系统创建用户初始化密码的默认密码，根据需求修改 template_path是系统模板存放路径，用于机构，用户等功能的模板下载 ledgerRptFIle_tempPath和ledgerRptFIle_path是EAST生成报文存放的路径和临时文件生成的存放路径 DBurl是sqluldr2报文生成数据链接配置 客户端部署配置 将platform.war和libs.war放入服务中间件 修改配置文件fitech.js pathcs是配置ETL调度系统地址 path是配置主服务地址(包括服务项目名) 创建数据库表 启动服务，主服务会自动创建系统表 下载脚本 执行初始化数据 EAST3.0初始化脚本.sql（初始化条线，角色等基础信息） EAST脱敏函数.sql（初始化脱敏函数，复制该脚本中的函数依次执行） EAST脱敏公式.sql（初始化脱敏公式） 拉链表存储过程.sql（初始化拉链表存储过程，复制该脚本中的存储过程依次执行） ETL初始化脚本.sql（初始化ETL基础数据） ETL存储过程.sql（ETL存储过程） ETD指标建表语句.sql（根据需求执行，免费的10个指标） ETD初始化数据.sql（根据需求执行，免费的10个指标） 数据补录系统存储过程.sql（数据补录系统存储过程） 数据补录初始化脚本.sql（数据补录系统初始化脚本） 初始化EAST3.0校验公式（validata_rule05.sql脚本中有N个变量，根据提示进行输入。输入&amp;&amp;+变量,如：&amp;&amp;CHANGE） 将template文件夹下的excel放到application-env.properties配置文件下的template_path路径下，用于模板下载 启动项目 启动服务器中间件 打开浏览器访问http://IP:port/platform 访问成功，点击登录使用superadmin登录，密码123456进行登录 配置业务制度 进入系统配置》制度管理 进入银监标准化业务条线》手工配置 新增一个制度 点击批量载入，选择系统导入文件夹下的EASTtemplate0530.xlsx和fields.xlsx，点击确定，待导入完成后，可生成EAST的58张数据表 进入报文配置功能，查看报文是否生成成功，如果成功可进入操作手册进行机构，用户，角色等业务配置 数据配置 系统需要现场实施人员根据客户现场情况创建机构，角色和用户信息 机构信息配置 角色信息配置 用户信息配置 流程信息配置（重要，ETL数据调度流程需要此步骤） 详见用户操作手册 配置ETL调度任务 进入业务条线 》 数据调度 进入‘作业分类’菜单，新建一个‘作业分类’，用于管理系统调度作业 进入‘作业管理’菜单，在新建的作业分类下创建调度作业，用于数据调度；例如： 新增作业；例如： 选择当前调度作业 目前仅支持shell脚本和存储过程配置作业频度之后，只有满足当前配置的启动条件，调度作业才会启动 shell和存储过程必须要有回调true/false 进入‘任务管理’菜单，用于配置调度作业所需要的任务；例如： 选择任务类型新建任务1.新建procedure存储过程任务；例如：所有的存储过程必须要有回调函数true/false;例如： 12345678910111213141516171819202122232425262728create or replace procedure testproc(term in VARCHAR2, result OUT varchar)as CURSOR c1 ISselect l.id, t.tablename, i.institutionid from ledgerreport l left join ledgerrpttemplate t on l.ledgerreporttemplate_id = t.id left join institution i on l.institution_id = i.id where l.submitstatetype = '2' and l.term = term and i.institutionid='3011';beginFOR acct IN c1 LOOP update test.t_gx_ygb set reportid = acct.id where nbjgh = '3011'; insert into yjbzh.t_gx_ygb select SEQ_FITECH.nextval id,REPORTID,CJRQ,GWBH,YGZT,YXJGMC,ZW,YXJGDM,SFZH,XM,JRXKZH,SSBM,WDH,LXDH,GH,NBJGH,SYNCABLE from test.t_gx_ygb; END LOOP; commit; result := 'true';exception when storage_error then result := 'false'; when others then result := 'false';end testproc; 2.新加java调度任务；例如： 新平台EAST需要配置3个作业才可以正常运行 数据补录作业 数据补录系统待上报报文流程存储过程（east.create_bl_task|系统内置） 数据补录系统流程开启任务（JAVA任务） EAST收据调度作业 EAST待上报报文流程存储过程（east.proc_ledgerReport|系统内置） 数据拉取存储过程（客户现场人员编写） EAST流程开启任务（JAVA任务） EAST报文生成作业 EAST上报报文生成任务（JAVA任务） 作业任务为Java任务的实例如下 EAST流程开启任务（POST请求） ```ruby类名：com.fitechsoft.util.HttpRequest方法名：sendPostURL：http://IP:端口/项目名/task/startProcess/ 12345- EAST上报报文生成任务（GET请求） ```ruby类名：com.fitechsoft.util.HttpRequest方法名：sendGetURL：http://IP:端口/项目名/ledgerReportFile/reportFileGenerated/create 数据补录系统流程开启任务（POST请求） 123类名：com.fitechsoft.util.HttpRequest方法名：sendPostURL:http://IP:端口/项目名/accountTask/startProcess/ 进入‘作业管理’ 将任务管理中创建的任务配置到作业中 选择你要维护的作业，点击作业维护 添加新步骤，将任务配置到作业管理中 部署ETL调度任务 将fitech-etl-1.0.war放入应用服务器中间件中 修改ETL系统配置 config.properties 修改ETL调度任务配置数据库 config1.properties 修改ETL调度任务存储过程数据表配置 启动服务，控制台正常启动即可，操作员登录系统，查看代办任务是否有数据，有数据即可Home 新平台activiti参数说明 git安装教程 新平台开发手册git安装教程安装介质 Git-1.9.5-preview20150319.exe TortoiseGit-1.8.14.0-64bit.msi Tor4toiseGit-LanguagePack-1.8.14.0-64bit-zh_CN.msi 下载 基本配置 配置SSH密钥 找到生成的git授权KEY,路径默认生成在 C:\Users\rui.ssh 配置TortoiseGit 常用语法 查看当前git仓库获取和提交服务地址 1git remote -v 查看所有分支 1git branch 创建分支 1git branch dev 删除分支 1git branch -d dev 切换分支 1git checkout dev 创建并切换 1git checkout -b dev 查看工作区修改文件 1git status 查看修改内容 1git diff 添加修改到缓存区 12git add ***git add -A 版本提交 1git commit -m "branch test" 合并分支dev到当前分支 1git merge dev 指定定远程版本更新到本地指定版本 12git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;git pull origin dev:master 将当前分支提交到远程分支 12git push &lt;远程主机名&gt; &lt;远程分支名&gt;git push origin dev 切换git地址 1231. git remote rm origin2. git remote add origin git@github.com:yuquan0821/demo.git3. git push origin GIT教程 网络教程 oracle数据导出工具sqluldr2配置安装步骤 由于sqluldr2是基于oracle客户端的一个插件，则需要在平台服务端安装oracle_client 下载sqluldr2.bin（根据操作系统自行判定版本）到$ORACLE_HOME的bin目录，重命名为sqluldr2.bin 修改oracle安装$HOME目录下.bash_profile 增加如下环境变量 1export LD_LIBRARY_PATH=$ORACLE_HOME/bin:$ORACLE_HOME/lib:/lib:/usr/lib 执行 sqluldr2.bin 执行成功即可 新平台activiti参数说明activiti配置 新建bpmn流程 绘制流程图，具体画法网上有 设置流程参数 配置流程图ID ; name ; namespaces属性（自定义）; 配置启动监听（该监听为自定义，平台已经初始化一个，无特殊需求可直接使用） 配置任务节点属性 配置ID和name(此ID有特殊用处) 配置指派角色和督办角色， 变量规则：${任务节点ID_assignee};${任务节点ID_supervise} 设置任务节点参数 argname: 路由KEY，固定为input argvalues: 页面按钮参数，几个路由跳转几个参数，可自定义 handleEntry 当前任务节点页面路由地址 completeEntry 暂时为空，预留 isAssign:是否支持任务转派， ${任务节点ID_isAssign} 路由扭转控制参数 设定页面跳转路由参数${input==’refuse’} 说明 input:为步骤三中argname 的参数，无明显需求暂统一定义为input 说明’refuse’ 为步骤三中argvalues参数中定义的value，指定下一节点跳转新平台开发手册开发环境 开发工具IDE：IntelliJ IDEA/Eclipse 数据库：mysql/oracle JDK:1.8 版本管理工具：GIT 项目管理工具：MAVEN 开发规范 项目包名:com.fitech.功能名.项目名 项目类名: 领域模型：根据领域模型实际意义创建（能用英文标识的必须使用英文，无法使用英文标识的用拼音首字母创建类名，首字母必须大写) 持久化层：领域模型名+Repository 业务层： 接口：领域模型名+Service 实现：领域模型名+ServiceImpl 注释: 类名注释：当前类的中文描述+作者 接口名注释：当前接口作用+入参说明+出参说明 业务代码注释：每10行必须有至少有一个注释，业务复杂的3行内要有注释，判断条件（if）必须有注释 预留接口，预留逻辑必须使用//TODO进行标记，并且加上备 如果修改业务逻辑代码，在修改处添加备注，标识修改原因，修改时间和修改人 测试用例 每个模块有独立的测试用例配置文件，放置位置在 每个业务逻辑添加单元测试，测试通过再提交代码 GIT代码管理 仓库中默认版本master，是我们开发版本 本地更新后，创建本地开发版本dev (git checkout -b dev) 本地开发完成并测试通过后提交本地仓库 切换版本到master （git checkout master） 更新最新的开发版本 合并DEV版本到master （git merge dev） 确定无冲突之后提交远程仓库 技术说明 domain说明 添加注释@entity 主体继承FBSubject,客体继承FBObject 每个字段属性添加@Description(“角色名称”)注解，方便后期功能扩充 service说明 添加@Service注解，加入spring容器管理 添加@ServiceTrace注解，系统会自动管理service接口日志，记录到logback 接口的增删改操作需要捕获reporsitory发生的异常，然后throw出appException异常，这个是自定义异常，统一处理系统异常，记录logback,可自定义入参，第一个是异常码，可自定义，第二个是系统异常，可自定义; 对于一个服务接口有2个及以上“增”“删”“改”操作的，需要添加事务@Transactional controller说明 添加控制层上添加@RequestMapping ，定位当前接口位置，便于后期权限控制 controller回调GenericResult\&lt;?>封装回调函数，里面有当前请求是否成功，成功状态，异常状态，异常码，数据集对象等，系统回封装成json返回前端; controller中需要记录用户的操作日志，可以只对增删改操作记录，查询根据具体情况记录，addOperateLog第一个为日志信息，自定义，第二个是请求上下文对象，系统需要根据请求上下文获取登录用户信息和IP等; 操作日志需要在finally中记录，防止系统异常没有记录; war 说明 Activiti.cfg.xml：activiti流程引擎配置 applicationContext-jpa.xml：配置持久化层springdata配置 applicationContext.xml：spring相关配置 Security.cfg.xml：权限框架springsecutity相关配置 secutityAcl.cfg.xml：数据权限acl相关配置 Spring-mvc.xml Springbatch-content Application-evn.properties:数据源配置及其他的一些参数配置 Logback.xml：配置系统日志， 注：可根据具体需求进行配置修改 开发注意事项 clean install -Dmaven.test.skip=true 模块编译 jetty:run 项目执行数据库版本切换 目前系统支持mysql和Oracle数据库，由于制度报文生成接口是由不同数据库语法编写所以在切换数据库的同时要修改对应的数据库方言配置 修改pom.xml 目前0.0.1-SNAPSHOT版本对应mysql;0.0.2-SNAPSHOT版本对应oracle 修改配置文件applicationContext-jpa.xml，改为数据库所对应的接口实现类 如果需要新加SQL实现函数，则在对应的系统模块中添加，例如 实现自己的业务逻辑即可，然后在applicationContext-jpa.xml添加相应配置加入spring管理容器]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[filter配置跨域访问]]></title>
    <url>%2F2017%2F11%2F20%2Ffilter%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[Java代码：CommonInterceptor.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.List;public class CommonInterceptor implements HandlerInterceptor &#123; private List&lt;String&gt; excludedUrls; public List&lt;String&gt; getExcludedUrls() &#123; return excludedUrls; &#125; public void setExcludedUrls(List&lt;String&gt; excludedUrls) &#123; this.excludedUrls = excludedUrls; &#125; /** * 在业务处理器处理请求之前被调用 如果返回false * 从当前的拦截器往回执行所有拦截器的afterCompletion(), * 再退出拦截器链, 如果返回true 执行下一个拦截器, * 直到所有的拦截器都执行完毕 再执行被拦截的Controller * 然后进入拦截器链, * 从最后一个拦截器往回执行所有的postHandle() * 接着再从最后一个拦截器往回执行所有的afterCompletion() * * @param request * @param response */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; response.setHeader("Access-Control-Allow-Origin", "*"); response.setHeader("Access-Control-Allow-Methods", "*"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding"); return true; &#125; // 在业务处理器处理请求执行完成后,生成视图之前执行的动作 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; /** * 在DispatcherServlet完全处理完请求后被调用 * 当有拦截器抛出异常时, * 会从当前拦截器往回执行所有的拦截器的afterCompletion() * * @param request * @param response * @param handler */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; ServletContextConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.List;public class CommonInterceptor implements HandlerInterceptor &#123; private List&lt;String&gt; excludedUrls; public List&lt;String&gt; getExcludedUrls() &#123; return excludedUrls; &#125; public void setExcludedUrls(List&lt;String&gt; excludedUrls) &#123; this.excludedUrls = excludedUrls; &#125; /** * 在业务处理器处理请求之前被调用 如果返回false * 从当前的拦截器往回执行所有拦截器的afterCompletion(), * 再退出拦截器链, 如果返回true 执行下一个拦截器, * 直到所有的拦截器都执行完毕 再执行被拦截的Controller * 然后进入拦截器链, * 从最后一个拦截器往回执行所有的postHandle() * 接着再从最后一个拦截器往回执行所有的afterCompletion() * * @param request * @param response */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; response.setHeader("Access-Control-Allow-Origin", "*"); response.setHeader("Access-Control-Allow-Methods", "*"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,Content-Encoding"); return true; &#125; // 在业务处理器处理请求执行完成后,生成视图之前执行的动作 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; /** * 在DispatcherServlet完全处理完请求后被调用 * 当有拦截器抛出异常时, * 会从当前拦截器往回执行所有的拦截器的afterCompletion() * * @param request * @param response * @param handler */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>filter</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手搭建Hexo+OSChina博客]]></title>
    <url>%2F2017%2F11%2F17%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BAHexo%2BOSChina%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册OSChina账号，创建一个以https://gitee.com/ding-data/zhengdingblog.git命名的仓库，其中zhengdingblog为仓库名，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册OSChina时候的邮箱），打开Git Bash(MAC打开终端即可)，键入： 12$ git config --global user.name "username"$ git config --global user.email "email@example.com" 3.本地Git与OSChina建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH 1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好： 1$ ssh-keygen -t rsa -C "emailt@example.com" 然后键入以下指令： 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可： 1$ ssh-agent bash 再重新输入指令： 1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）： 1$ clip &lt; ~/.ssh/id_rsa.pub 在OSChina上点击你的头像–>设置–> SSH 公钥标题自己随便取，然后这个公钥就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后点击确定。最后还是测试一下吧，键入以下命令： 1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到OSChina的https://gitee.com/ding-data/zhengdingblog.git仓库下，点击克隆/下载,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here（windows）或者终端 中在目标目录下: 键入git clone -b develop \&lt;刚复制的地址> 12$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git$ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹 1$ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装: 1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件: 12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。 12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件config.yml找到： 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令： 123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：http://ding-data.gitee.io/zhengdingblog/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样： 123To https://github.com/chaooo/chaooo.github.io.git7f3b50a..128a10d HEAD -&gt; masterINFO Deploy done: git 当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\source_posts\文章标题.md 。 1$ hexo new [layout] "文章标题" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，同时你也可以编辑现有的layout，比如post的layout默认是 hexo\scaffolds\post.md 1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： 12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件”：”后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。 123$ git add .$ git commit -m "..."$ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。 1$ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库1$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令: 1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 小Tips:hexo 命令1234567891011121314hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>OSChina</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
